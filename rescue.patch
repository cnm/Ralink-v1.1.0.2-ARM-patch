diff --git a/sources/Module/Makefile.6 b/sources/Module/Makefile.6
index 79b1085..79353a3 100755
--- a/sources/Module/Makefile.6
+++ b/sources/Module/Makefile.6
@@ -23,8 +23,8 @@ CC := /tscrosstool/ts7800-crosstool-linux-gnueabi-2005q3-2-gcc3.4.4/arm-none-lin
 endif
 
 ifeq ($(TS),7500)
-KERNEL_SOURCE = /home/workspace/plaquinhas/kernel/linux-2.6.24-cavium
-CC := /home/workspace/plaquinhas/kernel/arm-uclibc-3.4.6/bin/arm-linux-gcc
+KERNEL_SOURCE = /home/fred/arm-linux/
+CC := /home/fred/ts7500_kernel/arm-uclibc-3.4.6/bin/arm-linux-gcc
 endif
 
 ifeq ($(TS),7400-26)
diff --git a/sources/Module/assoc.c b/sources/Module/assoc.c
index 885cdf9..6f8f683 100755
--- a/sources/Module/assoc.c
+++ b/sources/Module/assoc.c
@@ -1,76 +1,76 @@
 /*
- ***************************************************************************
- * Ralink Tech Inc.
- * 5F, No. 36 Taiyuan St.
- * Jhubei City
- * Hsinchu County 302, Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2008, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  * 
- * it under the terms of the GNU General Public License as published by  * 
- * the Free Software Foundation; either version 2 of the License, or     * 
- * (at your option) any later version.                                   * 
- *                                                                       * 
- * This program is distributed in the hope that it will be useful,       * 
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
- * GNU General Public License for more details.                          * 
- *                                                                       * 
- * You should have received a copy of the GNU General Public License     * 
- * along with this program; if not, write to the                         * 
- * Free Software Foundation, Inc.,                                       * 
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
- *                                                                       * 
- *************************************************************************
-
-	Module Name:
-	assoc.c
-
-	Abstract:
-
-	Revision History:
-	Who			When			What
-	--------	----------		----------------------------------------------
-	John		2004-9-3		porting from RT2500
+***************************************************************************
+* Ralink Tech Inc.
+* 5F, No. 36 Taiyuan St.
+* Jhubei City
+* Hsinchu County 302, Taiwan, R.O.C.
+*
+* (c) Copyright 2002-2008, Ralink Technology, Inc.
+*
+* This program is free software; you can redistribute it and/or modify  * 
+* it under the terms of the GNU General Public License as published by  * 
+* the Free Software Foundation; either version 2 of the License, or     * 
+* (at your option) any later version.                                   * 
+*                                                                       * 
+* This program is distributed in the hope that it will be useful,       * 
+* but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+* GNU General Public License for more details.                          * 
+*                                                                       * 
+* You should have received a copy of the GNU General Public License     * 
+* along with this program; if not, write to the                         * 
+* Free Software Foundation, Inc.,                                       * 
+* 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+*                                                                       * 
+*************************************************************************
+
+Module Name:
+assoc.c
+
+Abstract:
+
+Revision History:
+Who			When			What
+--------	----------		----------------------------------------------
+John		2004-9-3		porting from RT2500
 */
 #include "rt_config.h"
 #include <net/iw_handler.h>
 
 UCHAR	CipherWpaTemplate[] = {
-		0xdd, 					// WPA IE
-		0x16,					// Length
-		0x00, 0x50, 0xf2, 0x01,	// oui
-		0x01, 0x00,				// Version
-		0x00, 0x50, 0xf2, 0x02,	// Multicast
-		0x01, 0x00,				// Number of unicast
-		0x00, 0x50, 0xf2, 0x02,	// unicast
-		0x01, 0x00,				// number of authentication method
-		0x00, 0x50, 0xf2, 0x01	// authentication
-		};
+  0xdd, 					// WPA IE
+  0x16,					// Length
+  0x00, 0x50, 0xf2, 0x01,	// oui
+  0x01, 0x00,				// Version
+  0x00, 0x50, 0xf2, 0x02,	// Multicast
+  0x01, 0x00,				// Number of unicast
+  0x00, 0x50, 0xf2, 0x02,	// unicast
+  0x01, 0x00,				// number of authentication method
+  0x00, 0x50, 0xf2, 0x01	// authentication
+};
 UCHAR	CipherWpa2Template[] = {
-		0x30,					// RSN IE
-		0x14,					// Length	
-		0x01, 0x00,				// Version
-		0x00, 0x0f, 0xac, 0x02,	// group cipher, TKIP
-		0x01, 0x00,				// number of pairwise
-		0x00, 0x0f, 0xac, 0x02,	// unicast
-		0x01, 0x00,				// number of authentication method
-		0x00, 0x0f, 0xac, 0x02,	// authentication
-		0x00, 0x00,				// RSN capability
-		};
+  0x30,					// RSN IE
+  0x14,					// Length	
+  0x01, 0x00,				// Version
+  0x00, 0x0f, 0xac, 0x02,	// group cipher, TKIP
+  0x01, 0x00,				// number of pairwise
+  0x00, 0x0f, 0xac, 0x02,	// unicast
+  0x01, 0x00,				// number of authentication method
+  0x00, 0x0f, 0xac, 0x02,	// authentication
+  0x00, 0x00,				// RSN capability
+};
 UCHAR   CipherWpa2TemplateLen = (sizeof(CipherWpa2Template) / sizeof(UCHAR));	
 		
 /*  
     ==========================================================================
     Description: 
-        association state machine init, including state transition and timer init
+    association state machine init, including state transition and timer init
     Parameters: 
-        S - pointer to the association state machine
+    S - pointer to the association state machine
     Note:
-        The state machine looks like the following 
+    The state machine looks like the following 
         
-                               ASSOC_IDLE               ASSOC_WAIT_RSP             REASSOC_WAIT_RSP             DISASSOC_WAIT_RSP
+    ASSOC_IDLE               ASSOC_WAIT_RSP             REASSOC_WAIT_RSP             DISASSOC_WAIT_RSP
     MT2_MLME_ASSOC_REQ       mlme_assoc_req_action    invalid_state_when_assoc   invalid_state_when_assoc       invalid_state_when_assoc
     MT2_MLME_REASSOC_REQ     mlme_reassoc_req_action  invalid_state_when_reassoc invalid_state_when_reassoc     invalid_state_when_reassoc
     MT2_MLME_DISASSOC_REQ    mlme_disassoc_req_action mlme_disassoc_req_action   mlme_disassoc_req_action       mlme_disassoc_req_action
@@ -84,1169 +84,1165 @@ UCHAR   CipherWpa2TemplateLen = (sizeof(CipherWpa2Template) / sizeof(UCHAR));
     MT2_REASSOC_TIMEOUT      timer_nop                timer_nop                  reassoc_timeout_action         timer_nop
     MT2_DISASSOC_TIMEOUT     timer_nop                timer_nop                  timer_nop                      disassoc_timeout_action
     ==========================================================================
- */
+*/
 VOID AssocStateMachineInit(
-    IN	PRTMP_ADAPTER	pAd, 
-    IN  STATE_MACHINE *S, 
-    OUT STATE_MACHINE_FUNC Trans[]) 
+			   IN	PRTMP_ADAPTER	pAd, 
+			   IN  STATE_MACHINE *S, 
+			   OUT STATE_MACHINE_FUNC Trans[]) 
 {
-    StateMachineInit(S, (STATE_MACHINE_FUNC*)Trans, MAX_ASSOC_STATE, MAX_ASSOC_MSG, (STATE_MACHINE_FUNC)Drop, ASSOC_IDLE, ASSOC_MACHINE_BASE);
+  StateMachineInit(S, (STATE_MACHINE_FUNC*)Trans, MAX_ASSOC_STATE, MAX_ASSOC_MSG, (STATE_MACHINE_FUNC)Drop, ASSOC_IDLE, ASSOC_MACHINE_BASE);
 
-    // first column
-    StateMachineSetAction(S, ASSOC_IDLE, MT2_MLME_ASSOC_REQ, (STATE_MACHINE_FUNC)MlmeAssocReqAction);
-    StateMachineSetAction(S, ASSOC_IDLE, MT2_MLME_REASSOC_REQ, (STATE_MACHINE_FUNC)MlmeReassocReqAction);
-    StateMachineSetAction(S, ASSOC_IDLE, MT2_MLME_DISASSOC_REQ, (STATE_MACHINE_FUNC)MlmeDisassocReqAction);
-    StateMachineSetAction(S, ASSOC_IDLE, MT2_PEER_DISASSOC_REQ, (STATE_MACHINE_FUNC)PeerDisassocAction);
+  // first column
+  StateMachineSetAction(S, ASSOC_IDLE, MT2_MLME_ASSOC_REQ, (STATE_MACHINE_FUNC)MlmeAssocReqAction);
+  StateMachineSetAction(S, ASSOC_IDLE, MT2_MLME_REASSOC_REQ, (STATE_MACHINE_FUNC)MlmeReassocReqAction);
+  StateMachineSetAction(S, ASSOC_IDLE, MT2_MLME_DISASSOC_REQ, (STATE_MACHINE_FUNC)MlmeDisassocReqAction);
+  StateMachineSetAction(S, ASSOC_IDLE, MT2_PEER_DISASSOC_REQ, (STATE_MACHINE_FUNC)PeerDisassocAction);
    
-    // second column
-    StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenAssoc);
-    StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenReassoc);
-    StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_MLME_DISASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenDisassociate);
-    StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_PEER_DISASSOC_REQ, (STATE_MACHINE_FUNC)PeerDisassocAction);
-    StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_PEER_ASSOC_RSP, (STATE_MACHINE_FUNC)PeerAssocRspAction);
-    StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_ASSOC_TIMEOUT, (STATE_MACHINE_FUNC)AssocTimeoutAction);
-
-    // third column
-    StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenAssoc);
-    StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenReassoc);
-    StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_MLME_DISASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenDisassociate);
-    StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_PEER_DISASSOC_REQ, (STATE_MACHINE_FUNC)PeerDisassocAction);
-    StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_PEER_REASSOC_RSP, (STATE_MACHINE_FUNC)PeerReassocRspAction);
-    StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_REASSOC_TIMEOUT, (STATE_MACHINE_FUNC)ReassocTimeoutAction);
-
-    // fourth column
-    StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenAssoc);
-    StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenReassoc);
-    StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_MLME_DISASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenDisassociate);
-    StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_PEER_DISASSOC_REQ, (STATE_MACHINE_FUNC)PeerDisassocAction);
-    StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_DISASSOC_TIMEOUT, (STATE_MACHINE_FUNC)DisassocTimeoutAction);
-
-    // timer init
-	RTMPInitTimer(pAd, &pAd->MlmeAux.AssocTimer, GET_TIMER_FUNCTION(AssocTimeout), pAd, FALSE);
-	RTMPInitTimer(pAd, &pAd->MlmeAux.ReassocTimer, GET_TIMER_FUNCTION(ReassocTimeout), pAd, FALSE);
-	RTMPInitTimer(pAd, &pAd->MlmeAux.DisassocTimer, GET_TIMER_FUNCTION(DisassocTimeout), pAd, FALSE);
+  // second column
+  StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenAssoc);
+  StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenReassoc);
+  StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_MLME_DISASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenDisassociate);
+  StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_PEER_DISASSOC_REQ, (STATE_MACHINE_FUNC)PeerDisassocAction);
+  StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_PEER_ASSOC_RSP, (STATE_MACHINE_FUNC)PeerAssocRspAction);
+  StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_ASSOC_TIMEOUT, (STATE_MACHINE_FUNC)AssocTimeoutAction);
+
+  // third column
+  StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenAssoc);
+  StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenReassoc);
+  StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_MLME_DISASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenDisassociate);
+  StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_PEER_DISASSOC_REQ, (STATE_MACHINE_FUNC)PeerDisassocAction);
+  StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_PEER_REASSOC_RSP, (STATE_MACHINE_FUNC)PeerReassocRspAction);
+  StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_REASSOC_TIMEOUT, (STATE_MACHINE_FUNC)ReassocTimeoutAction);
+
+  // fourth column
+  StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenAssoc);
+  StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenReassoc);
+  StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_MLME_DISASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenDisassociate);
+  StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_PEER_DISASSOC_REQ, (STATE_MACHINE_FUNC)PeerDisassocAction);
+  StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_DISASSOC_TIMEOUT, (STATE_MACHINE_FUNC)DisassocTimeoutAction);
+
+  // timer init
+  RTMPInitTimer(pAd, &pAd->MlmeAux.AssocTimer, GET_TIMER_FUNCTION(AssocTimeout), pAd, FALSE);
+  RTMPInitTimer(pAd, &pAd->MlmeAux.ReassocTimer, GET_TIMER_FUNCTION(ReassocTimeout), pAd, FALSE);
+  RTMPInitTimer(pAd, &pAd->MlmeAux.DisassocTimer, GET_TIMER_FUNCTION(DisassocTimeout), pAd, FALSE);
     
 }
 
 /*
-    ==========================================================================
-    Description:
-        Association timeout procedure. After association timeout, this function 
-        will be called and it will put a message into the MLME queue
-    Parameters:
-        Standard timer parameters
-    ==========================================================================
- */
+  ==========================================================================
+  Description:
+  Association timeout procedure. After association timeout, this function 
+  will be called and it will put a message into the MLME queue
+  Parameters:
+  Standard timer parameters
+  ==========================================================================
+*/
 VOID AssocTimeout(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3)
+		  IN PVOID SystemSpecific1,
+		  IN PVOID FunctionContext,
+		  IN PVOID SystemSpecific2,
+		  IN PVOID SystemSpecific3)
 {
-    RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)FunctionContext;
-    DBGPRINT(RT_DEBUG_TRACE,"ASSOC - enqueue MT2_ASSOC_TIMEOUT \n");
-    MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_ASSOC_TIMEOUT, 0, NULL);
-    RTUSBMlmeUp(pAd);
+  RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)FunctionContext;
+  DBGPRINT(RT_DEBUG_TRACE,"ASSOC - enqueue MT2_ASSOC_TIMEOUT \n");
+  MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_ASSOC_TIMEOUT, 0, NULL);
+  RTUSBMlmeUp(pAd);
 }
 
 /*
-    ==========================================================================
-    Description:
-        Reassociation timeout procedure. After reassociation timeout, this 
-        function will be called and put a message into the MLME queue
-    Parameters:
-        Standard timer parameters
-    ==========================================================================
- */
+  ==========================================================================
+  Description:
+  Reassociation timeout procedure. After reassociation timeout, this 
+  function will be called and put a message into the MLME queue
+  Parameters:
+  Standard timer parameters
+  ==========================================================================
+*/
 VOID ReassocTimeout(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3)
+		    IN PVOID SystemSpecific1,
+		    IN PVOID FunctionContext,
+		    IN PVOID SystemSpecific2,
+		    IN PVOID SystemSpecific3)
 {
-    RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)FunctionContext;
-    DBGPRINT(RT_DEBUG_TRACE,"ASSOC - enqueue MT2_REASSOC_TIMEOUT \n");
-    MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_REASSOC_TIMEOUT, 0, NULL);
-    RTUSBMlmeUp(pAd);
+  RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)FunctionContext;
+  DBGPRINT(RT_DEBUG_TRACE,"ASSOC - enqueue MT2_REASSOC_TIMEOUT \n");
+  MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_REASSOC_TIMEOUT, 0, NULL);
+  RTUSBMlmeUp(pAd);
 }
 
 /*
-    ==========================================================================
-    Description:
-        Disassociation timeout procedure. After disassociation timeout, this 
-        function will be called and put a message into the MLME queue
-    Parameters:
-        Standard timer parameters
-    ==========================================================================
- */
+  ==========================================================================
+  Description:
+  Disassociation timeout procedure. After disassociation timeout, this 
+  function will be called and put a message into the MLME queue
+  Parameters:
+  Standard timer parameters
+  ==========================================================================
+*/
 VOID DisassocTimeout(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3)
+		     IN PVOID SystemSpecific1,
+		     IN PVOID FunctionContext,
+		     IN PVOID SystemSpecific2,
+		     IN PVOID SystemSpecific3)
 {
-    RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)FunctionContext;
-    DBGPRINT(RT_DEBUG_TRACE,"ASSOC - enqueue MT2_DISASSOC_TIMEOUT \n");
-    MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_DISASSOC_TIMEOUT, 0, NULL);
-    RTUSBMlmeUp(pAd);
+  RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)FunctionContext;
+  DBGPRINT(RT_DEBUG_TRACE,"ASSOC - enqueue MT2_DISASSOC_TIMEOUT \n");
+  MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_DISASSOC_TIMEOUT, 0, NULL);
+  RTUSBMlmeUp(pAd);
 }
 
 
 /*
-	==========================================================================
-	Description:
-		mlme assoc req handling procedure
-	Parameters:
-		Adapter - Adapter pointer
-		Elem - MLME Queue Element
-	Pre:
-		the station has been authenticated and the following information is stored in the config
-			-# SSID
-			-# supported rates and their length
-			-# listen interval (Adapter->PortCfg.default_listen_count)
-			-# Transmit power  (Adapter->PortCfg.tx_power)
-	Post  :
-		-# An association request frame is generated and sent to the air
-		-# Association timer starts
-		-# Association state -> ASSOC_WAIT_RSP
+  ==========================================================================
+  Description:
+  mlme assoc req handling procedure
+  Parameters:
+  Adapter - Adapter pointer
+  Elem - MLME Queue Element
+  Pre:
+  the station has been authenticated and the following information is stored in the config
+  -# SSID
+  -# supported rates and their length
+  -# listen interval (Adapter->PortCfg.default_listen_count)
+  -# Transmit power  (Adapter->PortCfg.tx_power)
+  Post  :
+  -# An association request frame is generated and sent to the air
+  -# Association timer starts
+  -# Association state -> ASSOC_WAIT_RSP
 		
-	==========================================================================
- */
+  ==========================================================================
+*/
 VOID MlmeAssocReqAction(
-	IN PRTMP_ADAPTER pAd, 
-	IN MLME_QUEUE_ELEM *Elem) 
+			IN PRTMP_ADAPTER pAd, 
+			IN MLME_QUEUE_ELEM *Elem) 
 {
-	UCHAR			 ApAddr[6];
-	HEADER_802_11	 AssocHdr;
-	UCHAR			 WmeIe[9] = {IE_VENDOR_SPECIFIC, 0x07, 0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, STA_QOS_CAPABILITY};
-	UCHAR			 CipherTmp[64];
-	UCHAR			 CipherTmpLen;	
-	USHORT			 ListenIntv;
-	ULONG			 Timeout;
-	USHORT			 CapabilityInfo;
-	PUCHAR			 pOutBuffer = NULL;
-	ULONG			 FrameLen = 0;
-	ULONG			 tmp;
-	UCHAR			 VarIesOffset;
-	USHORT			 Status;
-	ULONG			 idx;
-	BOOLEAN			 FoundPMK = FALSE;
-	USHORT			 NStatus;
-	BOOLEAN			TimerCancelled;
+  UCHAR			 ApAddr[6];
+  HEADER_802_11	 AssocHdr;
+  UCHAR			 WmeIe[9] = {IE_VENDOR_SPECIFIC, 0x07, 0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, STA_QOS_CAPABILITY};
+  UCHAR			 CipherTmp[64];
+  UCHAR			 CipherTmpLen;	
+  USHORT			 ListenIntv;
+  ULONG			 Timeout;
+  USHORT			 CapabilityInfo;
+  PUCHAR			 pOutBuffer = NULL;
+  ULONG			 FrameLen = 0;
+  ULONG			 tmp;
+  UCHAR			 VarIesOffset;
+  USHORT			 Status;
+  ULONG			 idx;
+  BOOLEAN			 FoundPMK = FALSE;
+  USHORT			 NStatus;
+  BOOLEAN			TimerCancelled;
 	
-	// Block all authentication request durning WPA block period
-	if (pAd->PortCfg.bBlockAssoc == TRUE)
+  // Block all authentication request durning WPA block period
+  if (pAd->PortCfg.bBlockAssoc == TRUE)
+    {
+      DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Block Assoc request durning WPA block period!\n");
+      pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+      Status = MLME_STATE_MACHINE_REJECT;
+      MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
+    }	
+  // check sanity first
+  else if (MlmeAssocReqSanity(pAd, Elem->Msg, Elem->MsgLen, ApAddr, &CapabilityInfo, &Timeout, &ListenIntv))
+    {	
+      RTMPCancelTimer(&pAd->MlmeAux.AssocTimer,&TimerCancelled);
+
+      COPY_MAC_ADDR(pAd->MlmeAux.Bssid, ApAddr);
+
+      // allocate and send out AssocRsp frame
+      NStatus = MlmeAllocateMemory(pAd, (PVOID *)&pOutBuffer);	//Get an unused nonpaged memory
+      if (NStatus != NDIS_STATUS_SUCCESS)
 	{
-		DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Block Assoc request durning WPA block period!\n");
-		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-		Status = MLME_STATE_MACHINE_REJECT;
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
-	}	
-	// check sanity first
-	else if (MlmeAssocReqSanity(pAd, Elem->Msg, Elem->MsgLen, ApAddr, &CapabilityInfo, &Timeout, &ListenIntv))
-	{	
-		RTMPCancelTimer(&pAd->MlmeAux.AssocTimer,&TimerCancelled);
-
-		COPY_MAC_ADDR(pAd->MlmeAux.Bssid, ApAddr);
-
-		// allocate and send out AssocRsp frame
-		NStatus = MlmeAllocateMemory(pAd, (PVOID *)&pOutBuffer);	//Get an unused nonpaged memory
-		if (NStatus != NDIS_STATUS_SUCCESS)
-		{
-			DBGPRINT(RT_DEBUG_TRACE,"ASSOC - MlmeAssocReqAction() allocate memory failed \n");
-			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-			Status = MLME_FAIL_NO_RESOURCE;
-			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
-			return;
-		}
+	  DBGPRINT(RT_DEBUG_TRACE,"ASSOC - MlmeAssocReqAction() allocate memory failed \n");
+	  pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+	  Status = MLME_FAIL_NO_RESOURCE;
+	  MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
+	  return;
+	}
 		
-		// Add by James 03/06/27
-		pAd->PortCfg.AssocInfo.Length = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION); 
-		// Association don't need to report MAC address
-		pAd->PortCfg.AssocInfo.AvailableRequestFixedIEs =
-			NDIS_802_11_AI_REQFI_CAPABILITIES | NDIS_802_11_AI_REQFI_LISTENINTERVAL;
-		pAd->PortCfg.AssocInfo.RequestFixedIEs.Capabilities = CapabilityInfo;
-		pAd->PortCfg.AssocInfo.RequestFixedIEs.ListenInterval = ListenIntv;		
-		// Only reassociate need this
-		//COPY_MAC_ADDR(pAd->PortCfg.AssocInfo.RequestFixedIEs.CurrentAPAddress, ApAddr);
-		pAd->PortCfg.AssocInfo.OffsetRequestIEs = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION);
+      // Add by James 03/06/27
+      pAd->PortCfg.AssocInfo.Length = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION); 
+      // Association don't need to report MAC address
+      pAd->PortCfg.AssocInfo.AvailableRequestFixedIEs =
+	NDIS_802_11_AI_REQFI_CAPABILITIES | NDIS_802_11_AI_REQFI_LISTENINTERVAL;
+      pAd->PortCfg.AssocInfo.RequestFixedIEs.Capabilities = CapabilityInfo;
+      pAd->PortCfg.AssocInfo.RequestFixedIEs.ListenInterval = ListenIntv;		
+      // Only reassociate need this
+      //COPY_MAC_ADDR(pAd->PortCfg.AssocInfo.RequestFixedIEs.CurrentAPAddress, ApAddr);
+      pAd->PortCfg.AssocInfo.OffsetRequestIEs = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION);
 		
-		// First add SSID
-		VarIesOffset = 0;
-		NdisMoveMemory(pAd->PortCfg.ReqVarIEs + VarIesOffset, &SsidIe, 1);
-		VarIesOffset += 1;
-		NdisMoveMemory(pAd->PortCfg.ReqVarIEs + VarIesOffset, &pAd->MlmeAux.SsidLen, 1);
-		VarIesOffset += 1;
-		NdisMoveMemory(pAd->PortCfg.ReqVarIEs + VarIesOffset, pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
-		VarIesOffset += pAd->MlmeAux.SsidLen;
-
-		// Second add Supported rates
-		NdisMoveMemory(pAd->PortCfg.ReqVarIEs + VarIesOffset, &SupRateIe, 1);
-		VarIesOffset += 1;
-		NdisMoveMemory(pAd->PortCfg.ReqVarIEs + VarIesOffset, &pAd->MlmeAux.SupRateLen, 1);
-		VarIesOffset += 1;
-		NdisMoveMemory(pAd->PortCfg.ReqVarIEs + VarIesOffset, pAd->MlmeAux.SupRate, pAd->MlmeAux.SupRateLen);
-		VarIesOffset += pAd->MlmeAux.SupRateLen;
-		// End Add by James
-
-		DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Send ASSOC request...\n");
-		MgtMacHeaderInit(pAd, &AssocHdr, SUBTYPE_ASSOC_REQ, 0, ApAddr, ApAddr);
+      // First add SSID
+      VarIesOffset = 0;
+      NdisMoveMemory(pAd->PortCfg.ReqVarIEs + VarIesOffset, &SsidIe, 1);
+      VarIesOffset += 1;
+      NdisMoveMemory(pAd->PortCfg.ReqVarIEs + VarIesOffset, &pAd->MlmeAux.SsidLen, 1);
+      VarIesOffset += 1;
+      NdisMoveMemory(pAd->PortCfg.ReqVarIEs + VarIesOffset, pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
+      VarIesOffset += pAd->MlmeAux.SsidLen;
+
+      // Second add Supported rates
+      NdisMoveMemory(pAd->PortCfg.ReqVarIEs + VarIesOffset, &SupRateIe, 1);
+      VarIesOffset += 1;
+      NdisMoveMemory(pAd->PortCfg.ReqVarIEs + VarIesOffset, &pAd->MlmeAux.SupRateLen, 1);
+      VarIesOffset += 1;
+      NdisMoveMemory(pAd->PortCfg.ReqVarIEs + VarIesOffset, pAd->MlmeAux.SupRate, pAd->MlmeAux.SupRateLen);
+      VarIesOffset += pAd->MlmeAux.SupRateLen;
+      // End Add by James
+
+      DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Send ASSOC request...\n");
+      MgtMacHeaderInit(pAd, &AssocHdr, SUBTYPE_ASSOC_REQ, 0, ApAddr, ApAddr);
 		
-		// Build basic frame first
-		MakeOutgoingFrame(pOutBuffer,				&FrameLen,
-						  sizeof(HEADER_802_11),	&AssocHdr,
-						  2,						&CapabilityInfo,
-						  2,						&ListenIntv,
-						  1,						&SsidIe,
-						  1,						&pAd->MlmeAux.SsidLen, 
-						  pAd->MlmeAux.SsidLen, 	pAd->MlmeAux.Ssid,
-						  1,						&SupRateIe,
-						  1,						&pAd->MlmeAux.SupRateLen,
-						  pAd->MlmeAux.SupRateLen,	pAd->MlmeAux.SupRate,
-						  END_OF_ARGS);
-
-		if (pAd->MlmeAux.ExtRateLen != 0)
-		{
-			MakeOutgoingFrame(pOutBuffer + FrameLen,	&tmp,
-							  1,						&ExtRateIe,
-							  1,						&pAd->MlmeAux.ExtRateLen,
-							  pAd->MlmeAux.ExtRateLen,	pAd->MlmeAux.ExtRate,							
-							  END_OF_ARGS);
-			FrameLen += tmp;
-		}
+      // Build basic frame first
+      MakeOutgoingFrame(pOutBuffer,				&FrameLen,
+			sizeof(HEADER_802_11),	&AssocHdr,
+			2,						&CapabilityInfo,
+			2,						&ListenIntv,
+			1,						&SsidIe,
+			1,						&pAd->MlmeAux.SsidLen, 
+			pAd->MlmeAux.SsidLen, 	pAd->MlmeAux.Ssid,
+			1,						&SupRateIe,
+			1,						&pAd->MlmeAux.SupRateLen,
+			pAd->MlmeAux.SupRateLen,	pAd->MlmeAux.SupRate,
+			END_OF_ARGS);
+
+      if (pAd->MlmeAux.ExtRateLen != 0)
+	{
+	  MakeOutgoingFrame(pOutBuffer + FrameLen,	&tmp,
+			    1,						&ExtRateIe,
+			    1,						&pAd->MlmeAux.ExtRateLen,
+			    pAd->MlmeAux.ExtRateLen,	pAd->MlmeAux.ExtRate,							
+			    END_OF_ARGS);
+	  FrameLen += tmp;
+	}
 
-		if (pAd->MlmeAux.APEdcaParm.bValid)
-		{
-			WmeIe[8] |= (pAd->MlmeAux.APEdcaParm.EdcaUpdateCount & 0x0f);
-			MakeOutgoingFrame(pOutBuffer + FrameLen,	&tmp,
-							  9,						&WmeIe[0],
-							  END_OF_ARGS);
-			FrameLen += tmp;
-		}
+      if (pAd->MlmeAux.APEdcaParm.bValid)
+	{
+	  WmeIe[8] |= (pAd->MlmeAux.APEdcaParm.EdcaUpdateCount & 0x0f);
+	  MakeOutgoingFrame(pOutBuffer + FrameLen,	&tmp,
+			    9,						&WmeIe[0],
+			    END_OF_ARGS);
+	  FrameLen += tmp;
+	}
 
 
-		// For WPA / WPA-PSK
-		if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA) || 
-			(pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK))			
-		{
-			// Copy WPA template to buffer
-			CipherTmpLen = sizeof(CipherWpaTemplate);
-			NdisMoveMemory(CipherTmp, CipherWpaTemplate, CipherTmpLen);
-			// Modify Group cipher
-			CipherTmp[11] = ((pAd->PortCfg.GroupCipher == Ndis802_11Encryption2Enabled) ? 0x2 : 0x4);
-			// Modify Pairwise cipher
-			CipherTmp[17] = ((pAd->PortCfg.PairCipher == Ndis802_11Encryption2Enabled) ? 0x2 : 0x4);
-			// Modify AKM
-			CipherTmp[23] = ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA) ? 0x1 : 0x2);
-			// Make outgoing frame
-			MakeOutgoingFrame(pOutBuffer + FrameLen,	&tmp,
-							  CipherTmpLen,				&CipherTmp[0],
-							  END_OF_ARGS);
-			FrameLen += tmp;
+      // For WPA / WPA-PSK
+      if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA) || 
+	  (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK))			
+	{
+	  // Copy WPA template to buffer
+	  CipherTmpLen = sizeof(CipherWpaTemplate);
+	  NdisMoveMemory(CipherTmp, CipherWpaTemplate, CipherTmpLen);
+	  // Modify Group cipher
+	  CipherTmp[11] = ((pAd->PortCfg.GroupCipher == Ndis802_11Encryption2Enabled) ? 0x2 : 0x4);
+	  // Modify Pairwise cipher
+	  CipherTmp[17] = ((pAd->PortCfg.PairCipher == Ndis802_11Encryption2Enabled) ? 0x2 : 0x4);
+	  // Modify AKM
+	  CipherTmp[23] = ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA) ? 0x1 : 0x2);
+	  // Make outgoing frame
+	  MakeOutgoingFrame(pOutBuffer + FrameLen,	&tmp,
+			    CipherTmpLen,				&CipherTmp[0],
+			    END_OF_ARGS);
+	  FrameLen += tmp;
 			
-			// Append Variable IE
-			printk("%s(): WPA/WPAPSK, Fill the ReqVarIEs with CipherTmp!\n", __FUNCTION__);
-			NdisMoveMemory(pAd->PortCfg.ReqVarIEs + VarIesOffset, CipherTmp, CipherTmpLen);
-			VarIesOffset += CipherTmpLen;
-
-			// Set Variable IEs Length
-			pAd->PortCfg.ReqVarIELen = VarIesOffset;
-			pAd->PortCfg.AssocInfo.RequestIELength = VarIesOffset;
-			// OffsetResponseIEs follow ReqVarIE
-			pAd->PortCfg.AssocInfo.OffsetResponseIEs = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION) + pAd->PortCfg.ReqVarIELen;
-		}
-		// For WPA2 / WPA2-PSK
-		else if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2) || 
-				 (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
+	  // Append Variable IE
+	  printk("%s(): WPA/WPAPSK, Fill the ReqVarIEs with CipherTmp!\n", __FUNCTION__);
+	  NdisMoveMemory(pAd->PortCfg.ReqVarIEs + VarIesOffset, CipherTmp, CipherTmpLen);
+	  VarIesOffset += CipherTmpLen;
+
+	  // Set Variable IEs Length
+	  pAd->PortCfg.ReqVarIELen = VarIesOffset;
+	  pAd->PortCfg.AssocInfo.RequestIELength = VarIesOffset;
+	  // OffsetResponseIEs follow ReqVarIE
+	  pAd->PortCfg.AssocInfo.OffsetResponseIEs = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION) + pAd->PortCfg.ReqVarIELen;
+	}
+      // For WPA2 / WPA2-PSK
+      else if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2) || 
+	       (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
+	{
+	  // Copy WPA2 template to buffer
+	  CipherTmpLen = sizeof(CipherWpa2Template);
+	  NdisMoveMemory(CipherTmp, CipherWpa2Template, CipherTmpLen);
+	  // Modify Group cipher
+	  CipherTmp[7] = ((pAd->PortCfg.GroupCipher == Ndis802_11Encryption2Enabled) ? 0x2 : 0x4);
+	  // Modify Pairwise cipher
+	  CipherTmp[13] = ((pAd->PortCfg.PairCipher == Ndis802_11Encryption2Enabled) ? 0x2 : 0x4);
+	  // Modify AKM
+	  CipherTmp[19] = ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2) ? 0x1 : 0x2);
+	  // Check for WPA PMK cache list
+	  if (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2)
+	    {
+	      // Search chched PMKID, append it if existed
+	      for (idx = 0; idx < PMKID_NO; idx++)
 		{
-			// Copy WPA2 template to buffer
-			CipherTmpLen = sizeof(CipherWpa2Template);
-			NdisMoveMemory(CipherTmp, CipherWpa2Template, CipherTmpLen);
-			// Modify Group cipher
-			CipherTmp[7] = ((pAd->PortCfg.GroupCipher == Ndis802_11Encryption2Enabled) ? 0x2 : 0x4);
-			// Modify Pairwise cipher
-			CipherTmp[13] = ((pAd->PortCfg.PairCipher == Ndis802_11Encryption2Enabled) ? 0x2 : 0x4);
-			// Modify AKM
-			CipherTmp[19] = ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2) ? 0x1 : 0x2);
-			// Check for WPA PMK cache list
-			if (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2)
-			{
-				// Search chched PMKID, append it if existed
-				for (idx = 0; idx < PMKID_NO; idx++)
-				{
-					if (NdisEqualMemory(ApAddr, &pAd->PortCfg.SavedPMK[idx].BSSID, 6))
-					{
-						FoundPMK = TRUE;
-						break;
-					}
-				}
-
-				if (FoundPMK)
-				{
-					// Update length within RSN IE
-					CipherTmp[1] += 18;
-					// Set PMK number
-					*(PUSHORT) &CipherTmp[CipherTmpLen] = 1;
-					NdisMoveMemory(&CipherTmp[CipherTmpLen + 2], &pAd->PortCfg.SavedPMK[idx].PMKID, 16);
-					CipherTmpLen += 18;
-				}
-			}
-
-			// Make outgoing frame
-			MakeOutgoingFrame(pOutBuffer + FrameLen,	&tmp,
-							  CipherTmpLen,				&CipherTmp[0],
-							  END_OF_ARGS);
-			FrameLen += tmp;
-
-			// Append Variable IE
-			printk("%s(): WPA2/WPA2PSK fill the ReqVarIEs with CipherTmp!\n", __FUNCTION__);
-			NdisMoveMemory(pAd->PortCfg.ReqVarIEs + VarIesOffset, CipherTmp, CipherTmpLen);
-			VarIesOffset += CipherTmpLen;
-
-			// Set Variable IEs Length
-			pAd->PortCfg.ReqVarIELen = VarIesOffset;
-			pAd->PortCfg.AssocInfo.RequestIELength = VarIesOffset;
-			// OffsetResponseIEs follow ReqVarIE
-			pAd->PortCfg.AssocInfo.OffsetResponseIEs = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION) + pAd->PortCfg.ReqVarIELen;			
+		  if (NdisEqualMemory(ApAddr, &pAd->PortCfg.SavedPMK[idx].BSSID, 6))
+		    {
+		      FoundPMK = TRUE;
+		      break;
+		    }
 		}
-		else
+
+	      if (FoundPMK)
 		{
-			// Do nothing
-			;
+		  // Update length within RSN IE
+		  CipherTmp[1] += 18;
+		  // Set PMK number
+		  *(PUSHORT) &CipherTmp[CipherTmpLen] = 1;
+		  NdisMoveMemory(&CipherTmp[CipherTmpLen + 2], &pAd->PortCfg.SavedPMK[idx].PMKID, 16);
+		  CipherTmpLen += 18;
 		}
+	    }
+
+	  // Make outgoing frame
+	  MakeOutgoingFrame(pOutBuffer + FrameLen,	&tmp,
+			    CipherTmpLen,				&CipherTmp[0],
+			    END_OF_ARGS);
+	  FrameLen += tmp;
+
+	  // Append Variable IE
+	  printk("%s(): WPA2/WPA2PSK fill the ReqVarIEs with CipherTmp!\n", __FUNCTION__);
+	  NdisMoveMemory(pAd->PortCfg.ReqVarIEs + VarIesOffset, CipherTmp, CipherTmpLen);
+	  VarIesOffset += CipherTmpLen;
+
+	  // Set Variable IEs Length
+	  pAd->PortCfg.ReqVarIELen = VarIesOffset;
+	  pAd->PortCfg.AssocInfo.RequestIELength = VarIesOffset;
+	  // OffsetResponseIEs follow ReqVarIE
+	  pAd->PortCfg.AssocInfo.OffsetResponseIEs = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION) + pAd->PortCfg.ReqVarIELen;			
+	}
+      else
+	{
+	  // Do nothing
+	  ;
+	}
 #if 0 //AGGREGATION_SUPPORT
-		// add Ralink proprietary IE to inform AP this STA is going to use AGGREGATION, only when -
-		// 1. user enable aggregation, AND
-		// 2. AP annouces it's AGGREGATION-capable in BEACON
-		if (pAd->PortCfg.bAggregationCapable && (pAd->MlmeAux.APRalinkIe & 0x00000001))
-		{
-			ULONG TmpLen;
-			UCHAR RalinkIe[9] = {IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43, 0x01, 0x00, 0x00, 0x00}; 
-			MakeOutgoingFrame(pOutBuffer+FrameLen,			 &TmpLen,
-							  9,							 RalinkIe,
-							  END_OF_ARGS);
-			FrameLen += TmpLen;
-		}
+      // add Ralink proprietary IE to inform AP this STA is going to use AGGREGATION, only when -
+      // 1. user enable aggregation, AND
+      // 2. AP annouces it's AGGREGATION-capable in BEACON
+      if (pAd->PortCfg.bAggregationCapable && (pAd->MlmeAux.APRalinkIe & 0x00000001))
+	{
+	  ULONG TmpLen;
+	  UCHAR RalinkIe[9] = {IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43, 0x01, 0x00, 0x00, 0x00}; 
+	  MakeOutgoingFrame(pOutBuffer+FrameLen,			 &TmpLen,
+			    9,							 RalinkIe,
+			    END_OF_ARGS);
+	  FrameLen += TmpLen;
+	}
 #endif
 		
-		MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
+      MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
 
 
-		RTMPSetTimer(&pAd->MlmeAux.AssocTimer, Timeout);
+      RTMPSetTimer(&pAd->MlmeAux.AssocTimer, Timeout);
 
-		pAd->Mlme.AssocMachine.CurrState = ASSOC_WAIT_RSP;
-	} 
-	else 
-	{
-		DBGPRINT(RT_DEBUG_TRACE,"ASSOC - MlmeAssocReqAction() sanity check failed. BUG!!!!!! \n");
-		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-		Status = MLME_INVALID_FORMAT;
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
-	}
+      pAd->Mlme.AssocMachine.CurrState = ASSOC_WAIT_RSP;
+    } 
+  else 
+    {
+      DBGPRINT(RT_DEBUG_TRACE,"ASSOC - MlmeAssocReqAction() sanity check failed. BUG!!!!!! \n");
+      pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+      Status = MLME_INVALID_FORMAT;
+      MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
+    }
 
 }
 
 /*
-	==========================================================================
-	Description:
-		mlme reassoc req handling procedure
-	Parameters:
-		Elem - 
-	Pre:
-		-# SSID  (Adapter->PortCfg.ssid[])
-		-# BSSID (AP address, Adapter->PortCfg.bssid)
-		-# Supported rates (Adapter->PortCfg.supported_rates[])
-		-# Supported rates length (Adapter->PortCfg.supported_rates_len)
-		-# Tx power (Adapter->PortCfg.tx_power)
+  ==========================================================================
+  Description:
+  mlme reassoc req handling procedure
+  Parameters:
+  Elem - 
+  Pre:
+  -# SSID  (Adapter->PortCfg.ssid[])
+  -# BSSID (AP address, Adapter->PortCfg.bssid)
+  -# Supported rates (Adapter->PortCfg.supported_rates[])
+  -# Supported rates length (Adapter->PortCfg.supported_rates_len)
+  -# Tx power (Adapter->PortCfg.tx_power)
 		
-	==========================================================================
- */
+  ==========================================================================
+*/
 VOID MlmeReassocReqAction(
-	IN PRTMP_ADAPTER pAd, 
-	IN MLME_QUEUE_ELEM *Elem) 
+			  IN PRTMP_ADAPTER pAd, 
+			  IN MLME_QUEUE_ELEM *Elem) 
 {
-	UCHAR			ApAddr[6];
-	HEADER_802_11	ReassocHdr;	
-	UCHAR			WmeIe[9] = {IE_VENDOR_SPECIFIC, 0x07, 0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, STA_QOS_CAPABILITY};
-	USHORT			CapabilityInfo, ListenIntv;
-	ULONG			Timeout;
-	ULONG			FrameLen = 0;
-	ULONG			tmp;
-	PUCHAR			pOutBuffer = NULL;
-	USHORT			Status;
-	USHORT			NStatus;
-	BOOLEAN         TimerCancelled;
+  UCHAR			ApAddr[6];
+  HEADER_802_11	ReassocHdr;	
+  UCHAR			WmeIe[9] = {IE_VENDOR_SPECIFIC, 0x07, 0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, STA_QOS_CAPABILITY};
+  USHORT			CapabilityInfo, ListenIntv;
+  ULONG			Timeout;
+  ULONG			FrameLen = 0;
+  ULONG			tmp;
+  PUCHAR			pOutBuffer = NULL;
+  USHORT			Status;
+  USHORT			NStatus;
+  BOOLEAN         TimerCancelled;
 	
-	// Block all authentication request durning WPA block period
-	if (pAd->PortCfg.bBlockAssoc == TRUE)
-	{
-		DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Block ReAssoc request durning WPA block period!\n");
-		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-		Status = MLME_STATE_MACHINE_REJECT;
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
-	}	
-	// the parameters are the same as the association
-	else if(MlmeAssocReqSanity(pAd, Elem->Msg, Elem->MsgLen, ApAddr, &CapabilityInfo, &Timeout, &ListenIntv))
-	{
-		RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer,&TimerCancelled);
+  // Block all authentication request durning WPA block period
+  if (pAd->PortCfg.bBlockAssoc == TRUE)
+    {
+      DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Block ReAssoc request durning WPA block period!\n");
+      pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+      Status = MLME_STATE_MACHINE_REJECT;
+      MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
+    }	
+  // the parameters are the same as the association
+  else if(MlmeAssocReqSanity(pAd, Elem->Msg, Elem->MsgLen, ApAddr, &CapabilityInfo, &Timeout, &ListenIntv))
+    {
+      RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer,&TimerCancelled);
 
-		// allocate and send out ReassocReq frame
-		NStatus = MlmeAllocateMemory(pAd, (PVOID *)&pOutBuffer);	//Get an unused nonpaged memory
-		if (NStatus != NDIS_STATUS_SUCCESS)
-		{
-			DBGPRINT(RT_DEBUG_TRACE,"ASSOC - MlmeReassocReqAction() allocate memory failed \n");
-			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-			Status = MLME_FAIL_NO_RESOURCE;
-			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
-			return;
-		}
+      // allocate and send out ReassocReq frame
+      NStatus = MlmeAllocateMemory(pAd, (PVOID *)&pOutBuffer);	//Get an unused nonpaged memory
+      if (NStatus != NDIS_STATUS_SUCCESS)
+	{
+	  DBGPRINT(RT_DEBUG_TRACE,"ASSOC - MlmeReassocReqAction() allocate memory failed \n");
+	  pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+	  Status = MLME_FAIL_NO_RESOURCE;
+	  MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
+	  return;
+	}
 
-		COPY_MAC_ADDR(pAd->MlmeAux.Bssid, ApAddr);
-
-		// make frame, use bssid as the AP address??
-		DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Send RE-ASSOC request...\n");
-		MgtMacHeaderInit(pAd, &ReassocHdr, SUBTYPE_REASSOC_REQ, 0, ApAddr, ApAddr);
-		MakeOutgoingFrame(pOutBuffer,				&FrameLen,
-						  sizeof(HEADER_802_11),	&ReassocHdr,
-						  2,						&CapabilityInfo,
-						  2,						&ListenIntv,
-						  MAC_ADDR_LEN, 			ApAddr,
-						  1,						&SsidIe,
-						  1,						&pAd->MlmeAux.SsidLen, 
-						  pAd->MlmeAux.SsidLen, 	pAd->MlmeAux.Ssid, 
-						  1,						&SupRateIe,
-						  1,						&pAd->MlmeAux.SupRateLen,
-						  pAd->MlmeAux.SupRateLen,	pAd->MlmeAux.SupRate,
-						  END_OF_ARGS);
-
-		if (pAd->MlmeAux.ExtRateLen != 0)
-		{
-			MakeOutgoingFrame(pOutBuffer + FrameLen,		&tmp,
-							  1,							&ExtRateIe,
-							  1,							&pAd->MlmeAux.ExtRateLen,
-							  pAd->MlmeAux.ExtRateLen,		pAd->MlmeAux.ExtRate,							
-							  END_OF_ARGS);
-			FrameLen += tmp;
-		}
+      COPY_MAC_ADDR(pAd->MlmeAux.Bssid, ApAddr);
+
+      // make frame, use bssid as the AP address??
+      DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Send RE-ASSOC request...\n");
+      MgtMacHeaderInit(pAd, &ReassocHdr, SUBTYPE_REASSOC_REQ, 0, ApAddr, ApAddr);
+      MakeOutgoingFrame(pOutBuffer,				&FrameLen,
+			sizeof(HEADER_802_11),	&ReassocHdr,
+			2,						&CapabilityInfo,
+			2,						&ListenIntv,
+			MAC_ADDR_LEN, 			ApAddr,
+			1,						&SsidIe,
+			1,						&pAd->MlmeAux.SsidLen, 
+			pAd->MlmeAux.SsidLen, 	pAd->MlmeAux.Ssid, 
+			1,						&SupRateIe,
+			1,						&pAd->MlmeAux.SupRateLen,
+			pAd->MlmeAux.SupRateLen,	pAd->MlmeAux.SupRate,
+			END_OF_ARGS);
+
+      if (pAd->MlmeAux.ExtRateLen != 0)
+	{
+	  MakeOutgoingFrame(pOutBuffer + FrameLen,		&tmp,
+			    1,							&ExtRateIe,
+			    1,							&pAd->MlmeAux.ExtRateLen,
+			    pAd->MlmeAux.ExtRateLen,		pAd->MlmeAux.ExtRate,							
+			    END_OF_ARGS);
+	  FrameLen += tmp;
+	}
 
-		if (pAd->MlmeAux.APEdcaParm.bValid)
-		{
-			WmeIe[8] |= (pAd->MlmeAux.APEdcaParm.EdcaUpdateCount & 0x0f);
-			MakeOutgoingFrame(pOutBuffer + FrameLen,	&tmp,
-							  9,						&WmeIe[0],
-							  END_OF_ARGS);
-			FrameLen += tmp;
-		}
+      if (pAd->MlmeAux.APEdcaParm.bValid)
+	{
+	  WmeIe[8] |= (pAd->MlmeAux.APEdcaParm.EdcaUpdateCount & 0x0f);
+	  MakeOutgoingFrame(pOutBuffer + FrameLen,	&tmp,
+			    9,						&WmeIe[0],
+			    END_OF_ARGS);
+	  FrameLen += tmp;
+	}
 #if 0 //AGGREGATION_SUPPORT
-		// add Ralink proprietary IE to inform AP this STA is going to use AGGREGATION, only when -
-		// 1. user enable aggregation, AND
-		// 2. AP annouces it's AGGREGATION-capable in BEACON
-		if (pAd->PortCfg.bAggregationCapable && (pAd->MlmeAux.APRalinkIe & 0x00000001))
-		{
-			ULONG TmpLen;
-			UCHAR RalinkIe[9] = {IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43, 0x01, 0x00, 0x00, 0x00}; 
-			MakeOutgoingFrame(pOutBuffer+FrameLen,			 &TmpLen,
-							  9,							 RalinkIe,
-							  END_OF_ARGS);
-			FrameLen += TmpLen;
-		}
-#endif
-		MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
-		
-		RTMPSetTimer(&pAd->MlmeAux.ReassocTimer, Timeout);
-		pAd->Mlme.AssocMachine.CurrState = REASSOC_WAIT_RSP;
-	} 
-	else 
+      // add Ralink proprietary IE to inform AP this STA is going to use AGGREGATION, only when -
+      // 1. user enable aggregation, AND
+      // 2. AP annouces it's AGGREGATION-capable in BEACON
+      if (pAd->PortCfg.bAggregationCapable && (pAd->MlmeAux.APRalinkIe & 0x00000001))
 	{
-		DBGPRINT(RT_DEBUG_TRACE,"ASSOC - MlmeReassocReqAction() sanity check failed. BUG!!!! \n");
-		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-		Status = MLME_INVALID_FORMAT;
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
+	  ULONG TmpLen;
+	  UCHAR RalinkIe[9] = {IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43, 0x01, 0x00, 0x00, 0x00}; 
+	  MakeOutgoingFrame(pOutBuffer+FrameLen,			 &TmpLen,
+			    9,							 RalinkIe,
+			    END_OF_ARGS);
+	  FrameLen += TmpLen;
 	}
+#endif
+      MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
+		
+      RTMPSetTimer(&pAd->MlmeAux.ReassocTimer, Timeout);
+      pAd->Mlme.AssocMachine.CurrState = REASSOC_WAIT_RSP;
+    } 
+  else 
+    {
+      DBGPRINT(RT_DEBUG_TRACE,"ASSOC - MlmeReassocReqAction() sanity check failed. BUG!!!! \n");
+      pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+      Status = MLME_INVALID_FORMAT;
+      MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
+    }
 }
 
 /*
-    ==========================================================================
-    Description:
-        Upper layer issues disassoc request
-    Parameters:
-        Elem -
-    ==========================================================================
- */
+  ==========================================================================
+  Description:
+  Upper layer issues disassoc request
+  Parameters:
+  Elem -
+  ==========================================================================
+*/
 VOID MlmeDisassocReqAction(
-    IN PRTMP_ADAPTER pAd, 
-    IN MLME_QUEUE_ELEM *Elem) 
+			   IN PRTMP_ADAPTER pAd, 
+			   IN MLME_QUEUE_ELEM *Elem) 
 {
-    PMLME_DISASSOC_REQ_STRUCT pDisassocReq;
-    HEADER_802_11         DisassocHdr;
-    PCHAR                 pOutBuffer = NULL;
-    ULONG                 FrameLen = 0;
-    ULONG                 Timeout = 0;
-    USHORT                Status;
-    USHORT                NStatus;
-	BOOLEAN               TimerCancelled;
+  PMLME_DISASSOC_REQ_STRUCT pDisassocReq;
+  HEADER_802_11         DisassocHdr;
+  PCHAR                 pOutBuffer = NULL;
+  ULONG                 FrameLen = 0;
+  ULONG                 Timeout = 0;
+  USHORT                Status;
+  USHORT                NStatus;
+  BOOLEAN               TimerCancelled;
 #ifdef RALINK_WPA_SUPPLICANT_SUPPORT
-    union iwreq_data      wrqu;
+  union iwreq_data      wrqu;
 #endif
     
-    // skip sanity check
-    pDisassocReq = (PMLME_DISASSOC_REQ_STRUCT)(Elem->Msg);
+  // skip sanity check
+  pDisassocReq = (PMLME_DISASSOC_REQ_STRUCT)(Elem->Msg);
 
-    // allocate and send out DeassocReq frame
-    NStatus = MlmeAllocateMemory(pAd, (PVOID *)&pOutBuffer);  //Get an unused nonpaged memory
-    if (NStatus != NDIS_STATUS_SUCCESS)
+  // allocate and send out DeassocReq frame
+  NStatus = MlmeAllocateMemory(pAd, (PVOID *)&pOutBuffer);  //Get an unused nonpaged memory
+  if (NStatus != NDIS_STATUS_SUCCESS)
     {
-        DBGPRINT(RT_DEBUG_TRACE, "ASSOC - MlmeDisassocReqAction() allocate memory failed\n");
-        pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-        Status = MLME_FAIL_NO_RESOURCE;
-        MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DISASSOC_CONF, 2, &Status);
-        return;
+      DBGPRINT(RT_DEBUG_TRACE, "ASSOC - MlmeDisassocReqAction() allocate memory failed\n");
+      pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+      Status = MLME_FAIL_NO_RESOURCE;
+      MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DISASSOC_CONF, 2, &Status);
+      return;
     }
 
-    RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer,&TimerCancelled);
+  RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer,&TimerCancelled);
     
-    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Send DISASSOC request\n");
-    MgtMacHeaderInit(pAd, &DisassocHdr, SUBTYPE_DISASSOC, 0, pDisassocReq->Addr, pDisassocReq->Addr);
-    MakeOutgoingFrame(pOutBuffer,           &FrameLen, 
-                      sizeof(HEADER_802_11),&DisassocHdr, 
-                      2,                    &pDisassocReq->Reason, 
-                      END_OF_ARGS);
-    MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
+  DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Send DISASSOC request\n");
+  MgtMacHeaderInit(pAd, &DisassocHdr, SUBTYPE_DISASSOC, 0, pDisassocReq->Addr, pDisassocReq->Addr);
+  MakeOutgoingFrame(pOutBuffer,           &FrameLen, 
+		    sizeof(HEADER_802_11),&DisassocHdr, 
+		    2,                    &pDisassocReq->Reason, 
+		    END_OF_ARGS);
+  MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
 	
 
-	// Set the control aux SSID to prevent it reconnect to old SSID
-	// Since calling this indicate user don't want to connect to that SSID anymore.
-	// 2004-11-10 can't reset this info, cause it may be the new SSID that user requests for
-	// pAd->MlmeAux.SsidLen = MAX_LEN_OF_SSID;
-	// NdisZeroMemory(pAd->MlmeAux.Ssid, MAX_LEN_OF_SSID);
-    // NdisZeroMemory(pAd->MlmeAux.Bssid, MAC_ADDR_LEN);
+  // Set the control aux SSID to prevent it reconnect to old SSID
+  // Since calling this indicate user don't want to connect to that SSID anymore.
+  // 2004-11-10 can't reset this info, cause it may be the new SSID that user requests for
+  // pAd->MlmeAux.SsidLen = MAX_LEN_OF_SSID;
+  // NdisZeroMemory(pAd->MlmeAux.Ssid, MAX_LEN_OF_SSID);
+  // NdisZeroMemory(pAd->MlmeAux.Bssid, MAC_ADDR_LEN);
     
 #ifdef RALINK_WPA_SUPPLICANT_SUPPORT
-    if (pAd->PortCfg.WPA_Supplicant == TRUE) {       
-        //send disassociate event to wpa_supplicant
-        memset(&wrqu, 0, sizeof(wrqu));
-        wrqu.data.flags = RT_DISASSOC_EVENT_FLAG;
-        wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, NULL);
-    } 
+  if (pAd->PortCfg.WPA_Supplicant == TRUE) {       
+    //send disassociate event to wpa_supplicant
+    memset(&wrqu, 0, sizeof(wrqu));
+    wrqu.data.flags = RT_DISASSOC_EVENT_FLAG;
+    wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, NULL);
+  } 
 #endif
 
 #ifdef NATIVE_WPA_SUPPLICANT_SUPPORT				
-	if (pAd->PortCfg.bNativeWpa == TRUE)  // add by johnli
-		wext_notify_event_assoc(pAd, SIOCGIWAP, FALSE);
+  if (pAd->PortCfg.bNativeWpa == TRUE)  // add by johnli
+    wext_notify_event_assoc(pAd, SIOCGIWAP, FALSE);
 #endif // NATIVE_WPA_SUPPLICANT_SUPPORT
 
-    pAd->PortCfg.DisassocReason = REASON_DISASSOC_STA_LEAVING;
-    COPY_MAC_ADDR(pAd->PortCfg.DisassocSta, pDisassocReq->Addr);
+  pAd->PortCfg.DisassocReason = REASON_DISASSOC_STA_LEAVING;
+  COPY_MAC_ADDR(pAd->PortCfg.DisassocSta, pDisassocReq->Addr);
 
-    RTMPSetTimer(&pAd->MlmeAux.DisassocTimer, Timeout);
+  RTMPSetTimer(&pAd->MlmeAux.DisassocTimer, Timeout);
     
-    pAd->Mlme.AssocMachine.CurrState = DISASSOC_WAIT_RSP;
+  pAd->Mlme.AssocMachine.CurrState = DISASSOC_WAIT_RSP;
 }
 
 #ifdef RALINK_WPA_SUPPLICANT_SUPPORT
 #ifdef DBG
 static void _rtmp_hexdump(int level, const char *title, const u8 *buf,
-			 size_t len, int show)
+			  size_t len, int show)
 {
-	size_t i;
-	if (level < RTDebugLevel)
-		return;
-	printk("%s - hexdump(len=%lu):", title, (unsigned long) len);
-	if (show) {
-		for (i = 0; i < len; i++)
-			printk(" %02x", buf[i]);
-	} else {
-		printk(" [REMOVED]");
-	}
-	printk("\n");
+  size_t i;
+  if (level < RTDebugLevel)
+    return;
+  printk("%s - hexdump(len=%lu):", title, (unsigned long) len);
+  if (show) {
+    for (i = 0; i < len; i++)
+      printk(" %02x", buf[i]);
+  } else {
+    printk(" [REMOVED]");
+  }
+  printk("\n");
 }
 
 void rtmp_hexdump(int level, const char *title, const u8 *buf, size_t len)
 {
-	_rtmp_hexdump(level, title, buf, len, 1);
+  _rtmp_hexdump(level, title, buf, len, 1);
 }
 #endif
 
 NDIS_STATUS miniport_query_info(
-     IN PRTMP_ADAPTER pAd,
-     IN USHORT oid,
-     OUT void *buf, 
-     OUT ULONG bufsize)
+				IN PRTMP_ADAPTER pAd,
+				IN USHORT oid,
+				OUT void *buf, 
+				OUT ULONG bufsize)
 {	
-    // First add AssocInfo
-	NdisMoveMemory(buf, &pAd->PortCfg.AssocInfo, sizeof(NDIS_802_11_ASSOCIATION_INFORMATION));
-	// Second add ReqVarIEs
-	NdisMoveMemory(buf + sizeof(NDIS_802_11_ASSOCIATION_INFORMATION), pAd->PortCfg.ReqVarIEs, pAd->PortCfg.ReqVarIELen);
-	// Third add ResVarIEs
-	NdisMoveMemory(buf + sizeof(NDIS_802_11_ASSOCIATION_INFORMATION) + pAd->PortCfg.ReqVarIELen, pAd->PortCfg.ResVarIEs, pAd->PortCfg.ResVarIELen);
+  // First add AssocInfo
+  NdisMoveMemory(buf, &pAd->PortCfg.AssocInfo, sizeof(NDIS_802_11_ASSOCIATION_INFORMATION));
+  // Second add ReqVarIEs
+  NdisMoveMemory(buf + sizeof(NDIS_802_11_ASSOCIATION_INFORMATION), pAd->PortCfg.ReqVarIEs, pAd->PortCfg.ReqVarIELen);
+  // Third add ResVarIEs
+  NdisMoveMemory(buf + sizeof(NDIS_802_11_ASSOCIATION_INFORMATION) + pAd->PortCfg.ReqVarIELen, pAd->PortCfg.ResVarIEs, pAd->PortCfg.ResVarIELen);
 	
-	return 0;
+  return 0;
 }
 
 VOID link_status_handler(
-    IN PRTMP_ADAPTER pAd)
+			 IN PRTMP_ADAPTER pAd)
 {
-	NDIS_802_11_ASSOCIATION_INFORMATION *ndis_assoc_info;
-
-	unsigned char *wpa_assoc_info_req, *wpa_assoc_info_resp, *ies;
-	unsigned char *p;
-	int i;
-	unsigned char *assoc_info;
-	union iwreq_data wrqu;
-	NDIS_STATUS res;
+  NDIS_802_11_ASSOCIATION_INFORMATION *ndis_assoc_info;
+
+  unsigned char *wpa_assoc_info_req, *wpa_assoc_info_resp, *ies;
+  unsigned char *p;
+  int i;
+  unsigned char *assoc_info;
+  union iwreq_data wrqu;
+  NDIS_STATUS res;
 	
-	const int assoc_size = sizeof(*ndis_assoc_info) + IW_CUSTOM_MAX;
-	assoc_info = kmalloc(assoc_size, MEM_ALLOC_FLAG);
+  const int assoc_size = sizeof(*ndis_assoc_info) + IW_CUSTOM_MAX;
+  assoc_info = kmalloc(assoc_size, MEM_ALLOC_FLAG);
 
-	if (!assoc_info) 
-	{
-        DBGPRINT(RT_DEBUG_TRACE, "couldn't allocate memory\n");
-		return;
-	}
+  if (!assoc_info) 
+    {
+      DBGPRINT(RT_DEBUG_TRACE, "couldn't allocate memory\n");
+      return;
+    }
 
-	memset(assoc_info, 0, assoc_size);
-	ndis_assoc_info = (NDIS_802_11_ASSOCIATION_INFORMATION *)assoc_info;
+  memset(assoc_info, 0, assoc_size);
+  ndis_assoc_info = (NDIS_802_11_ASSOCIATION_INFORMATION *)assoc_info;
        
-	res = miniport_query_info(pAd, OID_802_11_ASSOCIATION_INFORMATION,
-				  assoc_info, assoc_size);
-	if (res) 
-	{
-		DBGPRINT(RT_DEBUG_TRACE, "query assoc_info failed\n");
-		kfree(assoc_info);
-		return;
-	}
+  res = miniport_query_info(pAd, OID_802_11_ASSOCIATION_INFORMATION,
+			    assoc_info, assoc_size);
+  if (res) 
+    {
+      DBGPRINT(RT_DEBUG_TRACE, "query assoc_info failed\n");
+      kfree(assoc_info);
+      return;
+    }
 
-	/*
-	 * TODO: backwards compatibility would require that IWEVCUSTOM
-	 * is sent even if WIRELESS_EXT > 17. This version does not do
-	 * this in order to allow wpa_supplicant to be tested with
-	 * WE-18.
-	 */
+  /*
+   * TODO: backwards compatibility would require that IWEVCUSTOM
+   * is sent even if WIRELESS_EXT > 17. This version does not do
+   * this in order to allow wpa_supplicant to be tested with
+   * WE-18.
+   */
 
 #ifdef DBG
-	rtmp_hexdump(RT_DEBUG_TRACE, "ASSOCINFO", (const u8 *) ndis_assoc_info,
-		    sizeof(NDIS_802_11_ASSOCIATION_INFORMATION));
+  rtmp_hexdump(RT_DEBUG_TRACE, "ASSOCINFO", (const u8 *) ndis_assoc_info,
+	       sizeof(NDIS_802_11_ASSOCIATION_INFORMATION));
 #endif
 
-    wpa_assoc_info_req = kmalloc(IW_CUSTOM_MAX, MEM_ALLOC_FLAG);
+  wpa_assoc_info_req = kmalloc(IW_CUSTOM_MAX, MEM_ALLOC_FLAG);
 
-	if (!wpa_assoc_info_req) 
-	{
-		DBGPRINT(RT_DEBUG_TRACE, "couldn't allocate memory\n");
-		return;
-	}
+  if (!wpa_assoc_info_req) 
+    {
+      DBGPRINT(RT_DEBUG_TRACE, "couldn't allocate memory\n");
+      return;
+    }
 
-    //send ReqIEs
-    memset(wpa_assoc_info_req, 0, IW_CUSTOM_MAX);
-	p = wpa_assoc_info_req;
-	p += sprintf(p, "ASSOCINFO_ReqIEs=");
-	ies = ((char *)ndis_assoc_info) +
-		ndis_assoc_info->OffsetRequestIEs;
+  //send ReqIEs
+  memset(wpa_assoc_info_req, 0, IW_CUSTOM_MAX);
+  p = wpa_assoc_info_req;
+  p += sprintf(p, "ASSOCINFO_ReqIEs=");
+  ies = ((char *)ndis_assoc_info) +
+    ndis_assoc_info->OffsetRequestIEs;
 		
-	for (i = 0; i < ndis_assoc_info->RequestIELength; i++)
-		p += sprintf(p, "%c", ies[i]);
-
-    p += sprintf(p, "\0");
-	memset(&wrqu, 0, sizeof(wrqu));
-    wrqu.data.length = p - wpa_assoc_info_req;
-	wrqu.data.flags = RT_REQIE_EVENT_FLAG;
-	DBGPRINT(RT_DEBUG_TRACE, "adding %d bytes\n", wrqu.data.length);
-	wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, wpa_assoc_info_req);
-
-    wpa_assoc_info_resp = kmalloc(IW_CUSTOM_MAX, MEM_ALLOC_FLAG);
-	if (!wpa_assoc_info_resp) 
-	{
-		DBGPRINT(RT_DEBUG_TRACE, "couldn't allocate memory\n");
-		return;
-	}
+  for (i = 0; i < ndis_assoc_info->RequestIELength; i++)
+    p += sprintf(p, "%c", ies[i]);
 
-    //send RespIEs
-	memset(wpa_assoc_info_resp, 0, IW_CUSTOM_MAX);
-	p = wpa_assoc_info_resp;
-	p += sprintf(p, " RespIEs=");
-	ies = ((char *)ndis_assoc_info) +
-		ndis_assoc_info->OffsetResponseIEs;
+  memset(&wrqu, 0, sizeof(wrqu));
+  wrqu.data.length = p - wpa_assoc_info_req;
+  wrqu.data.flags = RT_REQIE_EVENT_FLAG;
+  DBGPRINT(RT_DEBUG_TRACE, "adding %d bytes\n", wrqu.data.length);
+  wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, wpa_assoc_info_req);
 
-	for (i = 0; i < ndis_assoc_info->ResponseIELength; i++)
-		p += sprintf(p, "%c", ies[i]);
+  wpa_assoc_info_resp = kmalloc(IW_CUSTOM_MAX, MEM_ALLOC_FLAG);
+  if (!wpa_assoc_info_resp) 
+    {
+      DBGPRINT(RT_DEBUG_TRACE, "couldn't allocate memory\n");
+      return;
+    }
 
-	p += sprintf(p, "\0");
+  //send RespIEs
+  memset(wpa_assoc_info_resp, 0, IW_CUSTOM_MAX);
+  p = wpa_assoc_info_resp;
+  p += sprintf(p, " RespIEs=");
+  ies = ((char *)ndis_assoc_info) +
+    ndis_assoc_info->OffsetResponseIEs;
 
-    memset(&wrqu, 0, sizeof(wrqu));
-	wrqu.data.length = p - wpa_assoc_info_resp;
-	wrqu.data.flags = RT_RESPIE_EVENT_FLAG;
-	wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, wpa_assoc_info_resp);
+  for (i = 0; i < ndis_assoc_info->ResponseIELength; i++)
+    p += sprintf(p, "%c", ies[i]);
 
-    memset(&wrqu, 0, sizeof(wrqu));
-    wrqu.data.flags = RT_ASSOCINFO_EVENT_FLAG;
-    wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, NULL);
+  memset(&wrqu, 0, sizeof(wrqu));
+  wrqu.data.length = p - wpa_assoc_info_resp;
+  wrqu.data.flags = RT_RESPIE_EVENT_FLAG;
+  wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, wpa_assoc_info_resp);
+
+  memset(&wrqu, 0, sizeof(wrqu));
+  wrqu.data.flags = RT_ASSOCINFO_EVENT_FLAG;
+  wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, NULL);
 
 #if 0
-	/* we need 28 extra bytes for the format strings */
-	if ((ndis_assoc_info->RequestIELength +
-	     ndis_assoc_info->ResponseIELength + 28) > IW_CUSTOM_MAX) 
+  /* we need 28 extra bytes for the format strings */
+  if ((ndis_assoc_info->RequestIELength +
+       ndis_assoc_info->ResponseIELength + 28) > IW_CUSTOM_MAX) 
     {
-		//WARNING("information element is too long! (%u,%u),"
-		//	"association information dropped",
-		//	ndis_assoc_info->RequestIELength,
-		//	ndis_assoc_info->ResponseIELength);
-		DBGPRINT(RT_DEBUG_TRACE, "information element is too long! "
-			"association information dropped\n");
-		kfree(assoc_info);
-		return;
-	}
+      //WARNING("information element is too long! (%u,%u),"
+      //	"association information dropped",
+      //	ndis_assoc_info->RequestIELength,
+      //	ndis_assoc_info->ResponseIELength);
+      DBGPRINT(RT_DEBUG_TRACE, "information element is too long! "
+	       "association information dropped\n");
+      kfree(assoc_info);
+      return;
+    }
 
-	wpa_assoc_info = kmalloc(IW_CUSTOM_MAX, MEM_ALLOC_FLAG);
-	if (!wpa_assoc_info) 
-	{
-		DBGPRINT(RT_DEBUG_TRACE, "couldn't allocate memory\n");
-		kfree(assoc_info);
-		return;
-	}
-	p = wpa_assoc_info;
-	p += sprintf(p, "ASSOCINFO(ReqIEs=");
-	ies = ((char *)ndis_assoc_info) +
-		ndis_assoc_info->OffsetRequestIEs;
-	for (i = 0; i < ndis_assoc_info->RequestIELength; i++)
-		p += sprintf(p, "%02x", ies[i]);
+  wpa_assoc_info = kmalloc(IW_CUSTOM_MAX, MEM_ALLOC_FLAG);
+  if (!wpa_assoc_info) 
+    {
+      DBGPRINT(RT_DEBUG_TRACE, "couldn't allocate memory\n");
+      kfree(assoc_info);
+      return;
+    }
+  p = wpa_assoc_info;
+  p += sprintf(p, "ASSOCINFO(ReqIEs=");
+  ies = ((char *)ndis_assoc_info) +
+    ndis_assoc_info->OffsetRequestIEs;
+  for (i = 0; i < ndis_assoc_info->RequestIELength; i++)
+    p += sprintf(p, "%02x", ies[i]);
 
        
-	p += sprintf(p, " RespIEs=");
-	ies = ((char *)ndis_assoc_info) +
-		ndis_assoc_info->OffsetResponseIEs;
-	for (i = 0; i < ndis_assoc_info->ResponseIELength; i++)
-		p += sprintf(p, "%02x", ies[i]);
+  p += sprintf(p, " RespIEs=");
+  ies = ((char *)ndis_assoc_info) +
+    ndis_assoc_info->OffsetResponseIEs;
+  for (i = 0; i < ndis_assoc_info->ResponseIELength; i++)
+    p += sprintf(p, "%02x", ies[i]);
 
-	p += sprintf(p, ")");
+  p += sprintf(p, ")");
 
-	memset(&wrqu, 0, sizeof(wrqu));
-	wrqu.data.length = p - wpa_assoc_info;
-	//DBGPRINT(RT_DEBUG_TRACE, "adding %d bytes\n", wrqu.data.length);	
-	wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, wpa_assoc_info);
+  memset(&wrqu, 0, sizeof(wrqu));
+  wrqu.data.length = p - wpa_assoc_info;
+  //DBGPRINT(RT_DEBUG_TRACE, "adding %d bytes\n", wrqu.data.length);	
+  wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, wpa_assoc_info);
 
-	kfree(wpa_assoc_info);
+  kfree(wpa_assoc_info);
 #endif
-    kfree(wpa_assoc_info_req);
-	kfree(wpa_assoc_info_resp);
-	kfree(assoc_info);
+  kfree(wpa_assoc_info_req);
+  kfree(wpa_assoc_info_resp);
+  kfree(assoc_info);
 
-	return;
+  return;
 }
 #endif
 
 
 /*
-    ==========================================================================
-    Description:
-        peer sends assoc rsp back
-    Parameters:
-        Elme - MLME message containing the received frame
-    ==========================================================================
- */
+  ==========================================================================
+  Description:
+  peer sends assoc rsp back
+  Parameters:
+  Elme - MLME message containing the received frame
+  ==========================================================================
+*/
 VOID PeerAssocRspAction(
-    IN PRTMP_ADAPTER pAd, 
-    IN MLME_QUEUE_ELEM *Elem) 
+			IN PRTMP_ADAPTER pAd, 
+			IN MLME_QUEUE_ELEM *Elem) 
 {
-    USHORT        CapabilityInfo, Status, Aid;
-    UCHAR         SupRate[MAX_LEN_OF_SUPPORTED_RATES], SupRateLen;
-    UCHAR         ExtRate[MAX_LEN_OF_SUPPORTED_RATES], ExtRateLen;
-    UCHAR         Addr2[MAC_ADDR_LEN];
-	EDCA_PARM     EdcaParm;
-	BOOLEAN       TimerCancelled;
+  USHORT        CapabilityInfo, Status, Aid;
+  UCHAR         SupRate[MAX_LEN_OF_SUPPORTED_RATES], SupRateLen;
+  UCHAR         ExtRate[MAX_LEN_OF_SUPPORTED_RATES], ExtRateLen;
+  UCHAR         Addr2[MAC_ADDR_LEN];
+  EDCA_PARM     EdcaParm;
+  BOOLEAN       TimerCancelled;
 
 #ifdef RALINK_WPA_SUPPLICANT_SUPPORT
-    union iwreq_data wrqu;
+  union iwreq_data wrqu;
 #endif
 
-    if (PeerAssocRspSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, &CapabilityInfo, &Status, &Aid, SupRate, &SupRateLen, ExtRate, &ExtRateLen, &EdcaParm))
+  if (PeerAssocRspSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, &CapabilityInfo, &Status, &Aid, SupRate, &SupRateLen, ExtRate, &ExtRateLen, &EdcaParm))
     {
-        // The frame is for me ?
-        if(MAC_ADDR_EQUAL(Addr2, pAd->MlmeAux.Bssid)) 
+      // The frame is for me ?
+      if(MAC_ADDR_EQUAL(Addr2, pAd->MlmeAux.Bssid)) 
         {
-            DBGPRINT(RT_DEBUG_TRACE, "ASSOC - receive ASSOC_RSP to me (status=%d)\n", Status);		
-            RTMPCancelTimer(&pAd->MlmeAux.AssocTimer,&TimerCancelled);
+	  DBGPRINT(RT_DEBUG_TRACE, "ASSOC - receive ASSOC_RSP to me (status=%d)\n", Status);		
+	  RTMPCancelTimer(&pAd->MlmeAux.AssocTimer,&TimerCancelled);
 
-            if(Status == MLME_SUCCESS) 
+	  if(Status == MLME_SUCCESS) 
             {
-                //
-				// There may some packets will be drop, if we haven't set the BSS type!
-				// For example: EAPOL packet and the case of WHQL lost Packets.
-				// Since this may some delays to set those variables at LinkUp(..) on this (Mlme) thread. 
-				// 
-				// This is a trick, set the BSS type here.
-				//
-				if (pAd->PortCfg.BssType == BSS_INFRA)
-				{
-					OPSTATUS_SET_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
-				}
-
-
-                // go to procedure listed on page 376
-                AssocPostProc(pAd, Addr2, CapabilityInfo, Aid, SupRate, SupRateLen, ExtRate, ExtRateLen, &EdcaParm);  	
+	      //
+	      // There may some packets will be drop, if we haven't set the BSS type!
+	      // For example: EAPOL packet and the case of WHQL lost Packets.
+	      // Since this may some delays to set those variables at LinkUp(..) on this (Mlme) thread. 
+	      // 
+	      // This is a trick, set the BSS type here.
+	      //
+	      if (pAd->PortCfg.BssType == BSS_INFRA)
+		{
+		  OPSTATUS_SET_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
+		}
+
+
+	      // go to procedure listed on page 376
+	      AssocPostProc(pAd, Addr2, CapabilityInfo, Aid, SupRate, SupRateLen, ExtRate, ExtRateLen, &EdcaParm);  	
 
 #ifdef RALINK_WPA_SUPPLICANT_SUPPORT
-                if (pAd->PortCfg.WPA_Supplicant == TRUE) {
-                    // collect associate info 
-                    link_status_handler(pAd);
-                    //send associnfo event to wpa_supplicant
-                    memset(&wrqu, 0, sizeof(wrqu));
-                    wrqu.data.flags = RT_ASSOC_EVENT_FLAG;
-                    wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, NULL);
-                }
+	      if (pAd->PortCfg.WPA_Supplicant == TRUE) {
+		// collect associate info 
+		link_status_handler(pAd);
+		//send associnfo event to wpa_supplicant
+		memset(&wrqu, 0, sizeof(wrqu));
+		wrqu.data.flags = RT_ASSOC_EVENT_FLAG;
+		wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, NULL);
+	      }
 #endif
 
 #ifdef NATIVE_WPA_SUPPLICANT_SUPPORT
-				// collect associate info and notify the wpa_supplicant. 
-				if (pAd->PortCfg.bNativeWpa == TRUE)  // add by johnli
-					wext_notify_event_assoc(pAd, SIOCGIWAP, TRUE);
+	      // collect associate info and notify the wpa_supplicant. 
+	      if (pAd->PortCfg.bNativeWpa == TRUE)  // add by johnli
+		wext_notify_event_assoc(pAd, SIOCGIWAP, TRUE);
 #endif // NATIVE_WPA_SUPPLICANT_SUPPORT
             } 
 			
-            pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-            MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
+	  pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+	  MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
         } 
     }
-    else
+  else
     {
-        DBGPRINT(RT_DEBUG_TRACE, "ASSOC - PeerAssocRspAction() sanity check fail\n");
+      DBGPRINT(RT_DEBUG_TRACE, "ASSOC - PeerAssocRspAction() sanity check fail\n");
     }
 }
 
 /*
-    ==========================================================================
-    Description:
-        peer sends reassoc rsp
-    Parametrs:
-        Elem - MLME message cntaining the received frame
-    ==========================================================================
- */
+  ==========================================================================
+  Description:
+  peer sends reassoc rsp
+  Parametrs:
+  Elem - MLME message cntaining the received frame
+  ==========================================================================
+*/
 VOID PeerReassocRspAction(
-    IN PRTMP_ADAPTER pAd, 
-    IN MLME_QUEUE_ELEM *Elem) 
+			  IN PRTMP_ADAPTER pAd, 
+			  IN MLME_QUEUE_ELEM *Elem) 
 {
-    USHORT      CapabilityInfo;
-    USHORT      Status;
-    USHORT      Aid;
-    UCHAR       SupRate[MAX_LEN_OF_SUPPORTED_RATES], SupRateLen;
-    UCHAR       ExtRate[MAX_LEN_OF_SUPPORTED_RATES], ExtRateLen;
-    UCHAR       Addr2[MAC_ADDR_LEN];
-    EDCA_PARM   EdcaParm;
-	BOOLEAN     TimerCancelled;
+  USHORT      CapabilityInfo;
+  USHORT      Status;
+  USHORT      Aid;
+  UCHAR       SupRate[MAX_LEN_OF_SUPPORTED_RATES], SupRateLen;
+  UCHAR       ExtRate[MAX_LEN_OF_SUPPORTED_RATES], ExtRateLen;
+  UCHAR       Addr2[MAC_ADDR_LEN];
+  EDCA_PARM   EdcaParm;
+  BOOLEAN     TimerCancelled;
     
 #ifdef RALINK_WPA_SUPPLICANT_SUPPORT
-    union iwreq_data wrqu;
+  union iwreq_data wrqu;
 #endif
 
-    if(PeerAssocRspSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, &CapabilityInfo, &Status, &Aid, SupRate, &SupRateLen, ExtRate, &ExtRateLen, &EdcaParm)) 
+  if(PeerAssocRspSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, &CapabilityInfo, &Status, &Aid, SupRate, &SupRateLen, ExtRate, &ExtRateLen, &EdcaParm)) 
     {
-        if(MAC_ADDR_EQUAL(Addr2, pAd->MlmeAux.Bssid)) // The frame is for me ?
+      if(MAC_ADDR_EQUAL(Addr2, pAd->MlmeAux.Bssid)) // The frame is for me ?
         {
-            DBGPRINT(RT_DEBUG_TRACE, "ASSOC - receive REASSOC_RSP to me (status=%d)\n", Status);
-            RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer,&TimerCancelled);
+	  DBGPRINT(RT_DEBUG_TRACE, "ASSOC - receive REASSOC_RSP to me (status=%d)\n", Status);
+	  RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer,&TimerCancelled);
             
-            if(Status == MLME_SUCCESS) 
+	  if(Status == MLME_SUCCESS) 
             {
-                // go to procedure listed on page 376
-                AssocPostProc(pAd, Addr2, CapabilityInfo, Aid, SupRate, SupRateLen, ExtRate, ExtRateLen, &EdcaParm);
+	      // go to procedure listed on page 376
+	      AssocPostProc(pAd, Addr2, CapabilityInfo, Aid, SupRate, SupRateLen, ExtRate, ExtRateLen, &EdcaParm);
 
 #ifdef RALINK_WPA_SUPPLICANT_SUPPORT
-                if (pAd->PortCfg.WPA_Supplicant == TRUE) {
-                    //collect associate info
-                    link_status_handler(pAd);
-                    //send associnfo event to wpa_supplicant
-                    memset(&wrqu, 0, sizeof(wrqu));
-                    wrqu.data.flags = RT_ASSOC_EVENT_FLAG;
-                    wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, NULL);
-                }
-		        DBGPRINT(RT_DEBUG_OFF, "ASSOC - receive REASSOC_RSP to me (status=%d)\n", Status);
+	      if (pAd->PortCfg.WPA_Supplicant == TRUE) {
+		//collect associate info
+		link_status_handler(pAd);
+		//send associnfo event to wpa_supplicant
+		memset(&wrqu, 0, sizeof(wrqu));
+		wrqu.data.flags = RT_ASSOC_EVENT_FLAG;
+		wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, NULL);
+	      }
+	      DBGPRINT(RT_DEBUG_OFF, "ASSOC - receive REASSOC_RSP to me (status=%d)\n", Status);
 #endif
 
 #ifdef NATIVE_WPA_SUPPLICANT_SUPPORT				
-				if (pAd->PortCfg.bNativeWpa == TRUE)  // add by johnli
-					wext_notify_event_assoc(pAd, SIOCGIWAP, TRUE);
+	      if (pAd->PortCfg.bNativeWpa == TRUE)  // add by johnli
+		wext_notify_event_assoc(pAd, SIOCGIWAP, TRUE);
 #endif // NATIVE_WPA_SUPPLICANT_SUPPORT
 
             } 
 
-            pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-            MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
+	  pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+	  MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
         } 
     }
-    else
+  else
     {
-        DBGPRINT(RT_DEBUG_TRACE, "ASSOC - PeerReassocRspAction() sanity check fail\n");
+      DBGPRINT(RT_DEBUG_TRACE, "ASSOC - PeerReassocRspAction() sanity check fail\n");
     }
 
 }
 
 /*
-    ==========================================================================
-    Description:
-        procedures on IEEE 802.11/1999 p.376 
-    Parametrs:
-    ==========================================================================
- */
+  ==========================================================================
+  Description:
+  procedures on IEEE 802.11/1999 p.376 
+  Parametrs:
+  ==========================================================================
+*/
 VOID AssocPostProc(
-    IN PRTMP_ADAPTER pAd, 
-    IN PUCHAR pAddr2, 
-    IN USHORT CapabilityInfo, 
-    IN USHORT Aid, 
-    IN UCHAR SupRate[], 
-    IN UCHAR SupRateLen,
-    IN UCHAR ExtRate[],
-    IN UCHAR ExtRateLen,
-    IN PEDCA_PARM pEdcaParm)
+		   IN PRTMP_ADAPTER pAd, 
+		   IN PUCHAR pAddr2, 
+		   IN USHORT CapabilityInfo, 
+		   IN USHORT Aid, 
+		   IN UCHAR SupRate[], 
+		   IN UCHAR SupRateLen,
+		   IN UCHAR ExtRate[],
+		   IN UCHAR ExtRateLen,
+		   IN PEDCA_PARM pEdcaParm)
 {
-	ULONG Idx;
-	UCHAR VarIesOffset;
-
-    pAd->MlmeAux.BssType = BSS_INFRA;
-    COPY_MAC_ADDR(pAd->MlmeAux.Bssid, pAddr2);
-    pAd->MlmeAux.Aid = Aid;
-    pAd->MlmeAux.CapabilityInfo = CapabilityInfo & SUPPORTED_CAPABILITY_INFO;
-    NdisMoveMemory(&pAd->MlmeAux.APEdcaParm, pEdcaParm, sizeof(EDCA_PARM));
+  ULONG Idx;
+  UCHAR VarIesOffset;
+
+  pAd->MlmeAux.BssType = BSS_INFRA;
+  COPY_MAC_ADDR(pAd->MlmeAux.Bssid, pAddr2);
+  pAd->MlmeAux.Aid = Aid;
+  pAd->MlmeAux.CapabilityInfo = CapabilityInfo & SUPPORTED_CAPABILITY_INFO;
+  NdisMoveMemory(&pAd->MlmeAux.APEdcaParm, pEdcaParm, sizeof(EDCA_PARM));
         
-    // filter out un-supported rates
-    pAd->MlmeAux.SupRateLen = SupRateLen;
-    NdisMoveMemory(pAd->MlmeAux.SupRate, SupRate, SupRateLen);
-    RTMPCheckRates(pAd, pAd->MlmeAux.SupRate, &pAd->MlmeAux.SupRateLen);
-
-    // filter out un-supported rates
-    pAd->MlmeAux.ExtRateLen = ExtRateLen;
-    NdisMoveMemory(pAd->MlmeAux.ExtRate, ExtRate, ExtRateLen);
-    RTMPCheckRates(pAd, pAd->MlmeAux.ExtRate, &pAd->MlmeAux.ExtRateLen);
-
-	// Set New WPA information
-	Idx = BssTableSearch(&pAd->ScanTab, pAddr2, pAd->MlmeAux.Channel);
-	if (Idx == BSS_NOT_FOUND) 
-	{
-		DBGPRINT_ERR("ASSOC - Can't find BSS after receiving Assoc response from[%02x:%02x:%02x:%02x:%02x:%02x]\n",
-				pAddr2[0], pAddr2[1], pAddr2[2], pAddr2[3], pAddr2[4], pAddr2[5]);
-	}
-	else
-	{
-		// Mod by James to fix OID_802_11_ASSOCIATION_INFORMATION
-		pAd->PortCfg.AssocInfo.Length = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION); //+ sizeof(NDIS_802_11_FIXED_IEs); 	// Filled in assoc request
-		pAd->PortCfg.AssocInfo.AvailableResponseFixedIEs =
-			NDIS_802_11_AI_RESFI_CAPABILITIES | NDIS_802_11_AI_RESFI_STATUSCODE | NDIS_802_11_AI_RESFI_ASSOCIATIONID;
-		pAd->PortCfg.AssocInfo.ResponseFixedIEs.Capabilities  = CapabilityInfo;
-		pAd->PortCfg.AssocInfo.ResponseFixedIEs.StatusCode    = MLME_SUCCESS;		// Should be success, add failed later
-		pAd->PortCfg.AssocInfo.ResponseFixedIEs.AssociationId = Aid;
-
-		// Copy BSS VarIEs to PortCfg associnfo structure.
-		// First add Supported rates
-		VarIesOffset = 0;
-		NdisMoveMemory(pAd->PortCfg.ResVarIEs + VarIesOffset, &SupRateIe, 1);
-		VarIesOffset += 1;
-		NdisMoveMemory(pAd->PortCfg.ResVarIEs + VarIesOffset, &SupRateLen, 1);
-		VarIesOffset += 1;
-		NdisMoveMemory(pAd->PortCfg.ResVarIEs + VarIesOffset, SupRate, SupRateLen);
-		VarIesOffset += SupRateLen;
-//		NdisMoveMemory(pAd->PortCfg.ResVarIEs + VarIesOffset, &ExtRateIe, 1);
-//		VarIesOffset += 1;
-//		NdisMoveMemory(pAd->PortCfg.ResVarIEs + VarIesOffset, &ExtRateLen, 1);
-//		VarIesOffset += 1;
-//		NdisMoveMemory(pAd->PortCfg.ResVarIEs + VarIesOffset, ExtRate, ExtRateLen);
-//		VarIesOffset += ExtRateLen;
-
-		// Second add RSN
-		NdisMoveMemory(pAd->PortCfg.ResVarIEs + VarIesOffset, pAd->ScanTab.BssEntry[Idx].VarIEs, pAd->ScanTab.BssEntry[Idx].VarIELen);
-		VarIesOffset += pAd->ScanTab.BssEntry[Idx].VarIELen;
+  // filter out un-supported rates
+  pAd->MlmeAux.SupRateLen = SupRateLen;
+  NdisMoveMemory(pAd->MlmeAux.SupRate, SupRate, SupRateLen);
+  RTMPCheckRates(pAd, pAd->MlmeAux.SupRate, &pAd->MlmeAux.SupRateLen);
+
+  // filter out un-supported rates
+  pAd->MlmeAux.ExtRateLen = ExtRateLen;
+  NdisMoveMemory(pAd->MlmeAux.ExtRate, ExtRate, ExtRateLen);
+  RTMPCheckRates(pAd, pAd->MlmeAux.ExtRate, &pAd->MlmeAux.ExtRateLen);
+
+  // Set New WPA information
+  Idx = BssTableSearch(&pAd->ScanTab, pAddr2, pAd->MlmeAux.Channel);
+  if (Idx == BSS_NOT_FOUND) 
+    {
+      DBGPRINT_ERR("ASSOC - Can't find BSS after receiving Assoc response from[%02x:%02x:%02x:%02x:%02x:%02x]\n",
+		   pAddr2[0], pAddr2[1], pAddr2[2], pAddr2[3], pAddr2[4], pAddr2[5]);
+    }
+  else
+    {
+      // Mod by James to fix OID_802_11_ASSOCIATION_INFORMATION
+      pAd->PortCfg.AssocInfo.Length = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION); //+ sizeof(NDIS_802_11_FIXED_IEs); 	// Filled in assoc request
+      pAd->PortCfg.AssocInfo.AvailableResponseFixedIEs =
+	NDIS_802_11_AI_RESFI_CAPABILITIES | NDIS_802_11_AI_RESFI_STATUSCODE | NDIS_802_11_AI_RESFI_ASSOCIATIONID;
+      pAd->PortCfg.AssocInfo.ResponseFixedIEs.Capabilities  = CapabilityInfo;
+      pAd->PortCfg.AssocInfo.ResponseFixedIEs.StatusCode    = MLME_SUCCESS;		// Should be success, add failed later
+      pAd->PortCfg.AssocInfo.ResponseFixedIEs.AssociationId = Aid;
+
+      // Copy BSS VarIEs to PortCfg associnfo structure.
+      // First add Supported rates
+      VarIesOffset = 0;
+      NdisMoveMemory(pAd->PortCfg.ResVarIEs + VarIesOffset, &SupRateIe, 1);
+      VarIesOffset += 1;
+      NdisMoveMemory(pAd->PortCfg.ResVarIEs + VarIesOffset, &SupRateLen, 1);
+      VarIesOffset += 1;
+      NdisMoveMemory(pAd->PortCfg.ResVarIEs + VarIesOffset, SupRate, SupRateLen);
+      VarIesOffset += SupRateLen;
+      //		NdisMoveMemory(pAd->PortCfg.ResVarIEs + VarIesOffset, &ExtRateIe, 1);
+      //		VarIesOffset += 1;
+      //		NdisMoveMemory(pAd->PortCfg.ResVarIEs + VarIesOffset, &ExtRateLen, 1);
+      //		VarIesOffset += 1;
+      //		NdisMoveMemory(pAd->PortCfg.ResVarIEs + VarIesOffset, ExtRate, ExtRateLen);
+      //		VarIesOffset += ExtRateLen;
+
+      // Second add RSN
+      NdisMoveMemory(pAd->PortCfg.ResVarIEs + VarIesOffset, pAd->ScanTab.BssEntry[Idx].VarIEs, pAd->ScanTab.BssEntry[Idx].VarIELen);
+      VarIesOffset += pAd->ScanTab.BssEntry[Idx].VarIELen;
 		
-		// Set Variable IEs Length
-		pAd->PortCfg.ResVarIELen = VarIesOffset;
-		pAd->PortCfg.AssocInfo.ResponseIELength = VarIesOffset;
-	}
+      // Set Variable IEs Length
+      pAd->PortCfg.ResVarIELen = VarIesOffset;
+      pAd->PortCfg.AssocInfo.ResponseIELength = VarIesOffset;
+    }
 }
 
 /*
-    ==========================================================================
-    Description:
-        left part of IEEE 802.11/1999 p.374 
-    Parameters:
-        Elem - MLME message containing the received frame
-    ==========================================================================
- */
+  ==========================================================================
+  Description:
+  left part of IEEE 802.11/1999 p.374 
+  Parameters:
+  Elem - MLME message containing the received frame
+  ==========================================================================
+*/
 VOID PeerDisassocAction(
-    IN PRTMP_ADAPTER pAd, 
-    IN MLME_QUEUE_ELEM *Elem) 
+			IN PRTMP_ADAPTER pAd, 
+			IN MLME_QUEUE_ELEM *Elem) 
 {
-    UCHAR         Addr2[MAC_ADDR_LEN];
-    USHORT        Reason;
+  UCHAR         Addr2[MAC_ADDR_LEN];
+  USHORT        Reason;
 
 #ifdef RALINK_WPA_SUPPLICANT_SUPPORT
-    union iwreq_data wrqu;
+  union iwreq_data wrqu;
 #endif
 
-    if(PeerDisassocSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, &Reason))
+  if(PeerDisassocSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, &Reason))
     {
-        if (INFRA_ON(pAd) && MAC_ADDR_EQUAL(pAd->PortCfg.Bssid, Addr2)) 
+      if (INFRA_ON(pAd) && MAC_ADDR_EQUAL(pAd->PortCfg.Bssid, Addr2)) 
         {
-            LinkDown(pAd, TRUE);
-            pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+	  LinkDown(pAd, TRUE);
+	  pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
     
 #ifdef RALINK_WPA_SUPPLICANT_SUPPORT
-            if (pAd->PortCfg.WPA_Supplicant == TRUE) {
-                // send disassoc event to wpa_supplicant 
-                memset(&wrqu, 0, sizeof(wrqu));
-                wrqu.data.flags = RT_DISASSOC_EVENT_FLAG;
-                wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, NULL);
-            }
+	  if (pAd->PortCfg.WPA_Supplicant == TRUE) {
+	    // send disassoc event to wpa_supplicant 
+	    memset(&wrqu, 0, sizeof(wrqu));
+	    wrqu.data.flags = RT_DISASSOC_EVENT_FLAG;
+	    wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, NULL);
+	  }
 #endif
 
 #ifdef NATIVE_WPA_SUPPLICANT_SUPPORT				
-			if (pAd->PortCfg.bNativeWpa == TRUE)  // add by johnli
-				wext_notify_event_assoc(pAd, SIOCGIWAP, FALSE);
+	  if (pAd->PortCfg.bNativeWpa == TRUE)  // add by johnli
+	    wext_notify_event_assoc(pAd, SIOCGIWAP, FALSE);
 #endif // NATIVE_WPA_SUPPLICANT_SUPPORT
 
 #if 0
-            // 2004-09-11 john: can't remember why AP will DISASSOCIATE us.
-            //   But since it says for 2430 only, we temporaily remove the patch.
-            // 2002/11/21 -
-            //   patch RT2430/RT2420 hangup issue. We suspect this AP DIS-ASSOCIATE frame
-            //   is caused by PHY hangup, so we reset PHY, then auto recover the connection.
-            //   if this attempt fails, then remains in LinkDown and leaves the problem
-            //   to MlmePeriodicExec()
-            // NICPatchRT2430Bug(pAd);
-            pAd->RalinkCounters.BeenDisassociatedCount ++;
-			// Remove auto recover effort when disassociate by AP, re-enable for patch 2430 only
-            DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Disassociated by AP, Auto Recovery attempt #%d\n", pAd->RalinkCounters.BeenDisassociatedCount);
-            MlmeAutoReconnectLastSSID(pAd);
+	  // 2004-09-11 john: can't remember why AP will DISASSOCIATE us.
+	  //   But since it says for 2430 only, we temporaily remove the patch.
+	  // 2002/11/21 -
+	  //   patch RT2430/RT2420 hangup issue. We suspect this AP DIS-ASSOCIATE frame
+	  //   is caused by PHY hangup, so we reset PHY, then auto recover the connection.
+	  //   if this attempt fails, then remains in LinkDown and leaves the problem
+	  //   to MlmePeriodicExec()
+	  // NICPatchRT2430Bug(pAd);
+	  pAd->RalinkCounters.BeenDisassociatedCount ++;
+	  // Remove auto recover effort when disassociate by AP, re-enable for patch 2430 only
+	  DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Disassociated by AP, Auto Recovery attempt #%d\n", pAd->RalinkCounters.BeenDisassociatedCount);
+	  MlmeAutoReconnectLastSSID(pAd);
 #endif
         }
     }
-    else
+  else
     {
-        DBGPRINT(RT_DEBUG_TRACE, "ASSOC - PeerDisassocAction() sanity check fail\n");
+      DBGPRINT(RT_DEBUG_TRACE, "ASSOC - PeerDisassocAction() sanity check fail\n");
     }
 
 }
 
 /*
-    ==========================================================================
-    Description:
-        what the state machine will do after assoc timeout
-    ==========================================================================
- */
+  ==========================================================================
+  Description:
+  what the state machine will do after assoc timeout
+  ==========================================================================
+*/
 VOID AssocTimeoutAction(
-    IN PRTMP_ADAPTER pAd, 
-    IN MLME_QUEUE_ELEM *Elem) 
+			IN PRTMP_ADAPTER pAd, 
+			IN MLME_QUEUE_ELEM *Elem) 
 {
-    USHORT Status;
-    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - AssocTimeoutAction\n");
-    pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-    Status = MLME_REJ_TIMEOUT;
-    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
+  USHORT Status;
+  DBGPRINT(RT_DEBUG_TRACE, "ASSOC - AssocTimeoutAction\n");
+  pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+  Status = MLME_REJ_TIMEOUT;
+  MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
     
 }
 
 /*
-    ==========================================================================
-    Description:
-        what the state machine will do after reassoc timeout
-    ==========================================================================
- */
+  ==========================================================================
+  Description:
+  what the state machine will do after reassoc timeout
+  ==========================================================================
+*/
 VOID ReassocTimeoutAction(
-    IN PRTMP_ADAPTER pAd, 
-    IN MLME_QUEUE_ELEM *Elem) 
+			  IN PRTMP_ADAPTER pAd, 
+			  IN MLME_QUEUE_ELEM *Elem) 
 {
-    USHORT Status;
-    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - ReassocTimeoutAction\n");
-    pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-    Status = MLME_REJ_TIMEOUT;
-    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
+  USHORT Status;
+  DBGPRINT(RT_DEBUG_TRACE, "ASSOC - ReassocTimeoutAction\n");
+  pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+  Status = MLME_REJ_TIMEOUT;
+  MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
 }
 
 /*
-    ==========================================================================
-    Description:
-        what the state machine will do after disassoc timeout
-    ==========================================================================
- */
+  ==========================================================================
+  Description:
+  what the state machine will do after disassoc timeout
+  ==========================================================================
+*/
 VOID DisassocTimeoutAction(
-    IN PRTMP_ADAPTER pAd, 
-    IN MLME_QUEUE_ELEM *Elem) 
+			   IN PRTMP_ADAPTER pAd, 
+			   IN MLME_QUEUE_ELEM *Elem) 
 {
-    USHORT Status;
-    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - DisassocTimeoutAction\n");
-    pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-    Status = MLME_SUCCESS;
-    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DISASSOC_CONF, 2, &Status);
+  USHORT Status;
+  DBGPRINT(RT_DEBUG_TRACE, "ASSOC - DisassocTimeoutAction\n");
+  pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+  Status = MLME_SUCCESS;
+  MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DISASSOC_CONF, 2, &Status);
 }
 
 VOID InvalidStateWhenAssoc(
-    IN PRTMP_ADAPTER pAd, 
-    IN MLME_QUEUE_ELEM *Elem) 
+			   IN PRTMP_ADAPTER pAd, 
+			   IN MLME_QUEUE_ELEM *Elem) 
 {
-    USHORT Status;
-    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - InvalidStateWhenAssoc(state=%d), reset ASSOC state machine\n", 
-        pAd->Mlme.AssocMachine.CurrState);
-    pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-    Status = MLME_STATE_MACHINE_REJECT;
-    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
+  USHORT Status;
+  DBGPRINT(RT_DEBUG_TRACE, "ASSOC - InvalidStateWhenAssoc(state=%d), reset ASSOC state machine\n", 
+	   pAd->Mlme.AssocMachine.CurrState);
+  pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+  Status = MLME_STATE_MACHINE_REJECT;
+  MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
 }
 
 VOID InvalidStateWhenReassoc(
-    IN PRTMP_ADAPTER pAd, 
-    IN MLME_QUEUE_ELEM *Elem) 
+			     IN PRTMP_ADAPTER pAd, 
+			     IN MLME_QUEUE_ELEM *Elem) 
 {
-    USHORT Status;
-    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - InvalidStateWhenReassoc(state=%d), reset ASSOC state machine\n", 
-        pAd->Mlme.AssocMachine.CurrState);
-    pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-    Status = MLME_STATE_MACHINE_REJECT;
-    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
+  USHORT Status;
+  DBGPRINT(RT_DEBUG_TRACE, "ASSOC - InvalidStateWhenReassoc(state=%d), reset ASSOC state machine\n", 
+	   pAd->Mlme.AssocMachine.CurrState);
+  pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+  Status = MLME_STATE_MACHINE_REJECT;
+  MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
 }
 
 VOID InvalidStateWhenDisassociate(
-    IN PRTMP_ADAPTER pAd, 
-    IN MLME_QUEUE_ELEM *Elem) 
+				  IN PRTMP_ADAPTER pAd, 
+				  IN MLME_QUEUE_ELEM *Elem) 
 {
-    USHORT Status;
-    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - InvalidStateWhenDisassoc(state=%d), reset ASSOC state machine\n", 
-        pAd->Mlme.AssocMachine.CurrState);
-    pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-    Status = MLME_STATE_MACHINE_REJECT;
-    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DISASSOC_CONF, 2, &Status);
+  USHORT Status;
+  DBGPRINT(RT_DEBUG_TRACE, "ASSOC - InvalidStateWhenDisassoc(state=%d), reset ASSOC state machine\n", 
+	   pAd->Mlme.AssocMachine.CurrState);
+  pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+  Status = MLME_STATE_MACHINE_REJECT;
+  MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DISASSOC_CONF, 2, &Status);
 }
 
 /*
-    ==========================================================================
-    Description:
-        right part of IEEE 802.11/1999 page 374
-    Note: 
-        This event should never cause ASSOC state machine perform state
-        transition, and has no relationship with CNTL machine. So we separate
-        this routine as a service outside of ASSOC state transition table.
-    ==========================================================================
- */
+  ==========================================================================
+  Description:
+  right part of IEEE 802.11/1999 page 374
+  Note: 
+  This event should never cause ASSOC state machine perform state
+  transition, and has no relationship with CNTL machine. So we separate
+  this routine as a service outside of ASSOC state transition table.
+  ==========================================================================
+*/
 VOID Cls3errAction(
-    IN PRTMP_ADAPTER pAd, 
-    IN PUCHAR      pAddr) 
+		   IN PRTMP_ADAPTER pAd, 
+		   IN PUCHAR      pAddr) 
 {
-    HEADER_802_11       DisassocHdr;
-    PCHAR               pOutBuffer = NULL;
-    ULONG               FrameLen = 0;
-    USHORT              Reason = REASON_CLS3ERR;
-    USHORT              NStatus;
+  HEADER_802_11       DisassocHdr;
+  PCHAR               pOutBuffer = NULL;
+  ULONG               FrameLen = 0;
+  USHORT              Reason = REASON_CLS3ERR;
+  USHORT              NStatus;
     
-    // allocate memory
-    NStatus = MlmeAllocateMemory(pAd, (PVOID *)&pOutBuffer);  //Get an unused nonpaged memory
-    if (NStatus != NDIS_STATUS_SUCCESS)
-        return;
+  // allocate memory
+  NStatus = MlmeAllocateMemory(pAd, (PVOID *)&pOutBuffer);  //Get an unused nonpaged memory
+  if (NStatus != NDIS_STATUS_SUCCESS)
+    return;
     
-    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Class 3 Error, Send DISASSOC frame\n");
+  DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Class 3 Error, Send DISASSOC frame\n");
     
-    MgtMacHeaderInit(pAd, &DisassocHdr, SUBTYPE_DISASSOC, 0, pAddr, pAd->PortCfg.Bssid);
-    MakeOutgoingFrame(pOutBuffer,               &FrameLen, 
-                      sizeof(HEADER_802_11),    &DisassocHdr, 
-                      2,                        &Reason, 
-                      END_OF_ARGS);
+  MgtMacHeaderInit(pAd, &DisassocHdr, SUBTYPE_DISASSOC, 0, pAddr, pAd->PortCfg.Bssid);
+  MakeOutgoingFrame(pOutBuffer,               &FrameLen, 
+		    sizeof(HEADER_802_11),    &DisassocHdr, 
+		    2,                        &Reason, 
+		    END_OF_ARGS);
 
-    MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
+  MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
     
     
-    pAd->PortCfg.DisassocReason = REASON_CLS3ERR;
-    COPY_MAC_ADDR(pAd->PortCfg.DisassocSta, pAddr);
+  pAd->PortCfg.DisassocReason = REASON_CLS3ERR;
+  COPY_MAC_ADDR(pAd->PortCfg.DisassocSta, pAddr);
 }
-
diff --git a/sources/Module/mlme.c b/sources/Module/mlme.c
index ec2536b..b0c80c6 100755
--- a/sources/Module/mlme.c
+++ b/sources/Module/mlme.c
@@ -856,10 +856,6 @@ VOID STAMlmePeriodicExec(
         // fast roaming
         if (pAd->PortCfg.bFastRoaming)
         {
-            // Check the RSSI value, we should begin the roaming attempt
-            INT RxSignal = pAd->PortCfg.LastRssi - pAd->BbpRssiToDbmDelta;
-
-            DBGPRINT(RT_DEBUG_TRACE, "RxSignal %d\n", RxSignal);
             // Only perform action when signal is less than or equal to setting from the UI or registry
             if (pAd->PortCfg.LastRssi <= (pAd->BbpRssiToDbmDelta - pAd->PortCfg.dBmToRoam))
             {
diff --git a/sources/Module/rt_config.h b/sources/Module/rt_config.h
index a440541..2898a60 100755
--- a/sources/Module/rt_config.h
+++ b/sources/Module/rt_config.h
@@ -108,7 +108,7 @@
 
 
 #ifndef ULONG
-#define CHAR            char
+#define CHAR            signed char
 #define INT             int
 #define SHORT           int
 #define UINT            u32
diff --git a/sources/Module/rtmp_info.c b/sources/Module/rtmp_info.c
index e10f37f..e23b4ec 100755
--- a/sources/Module/rtmp_info.c
+++ b/sources/Module/rtmp_info.c
@@ -2378,7 +2378,7 @@ INT RTMPSetInformation(
 					// reset SSID to null
 					if (pSsid->SsidLength == 0)
 					{
-						memcpy(pSsid->Ssid, "", 0);
+					  memset(pSsid->Ssid, 0, NDIS_802_11_LENGTH_SSID);
 					}
 
 					RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_SSID, TRUE, pSsid, sizeof(NDIS_802_11_SSID));
@@ -3687,7 +3687,7 @@ INT rt73_ioctl(
 			else
 			{	
 				Ssid.SsidLength = 0;  // ANY ssid 
-				memcpy(pSsid->Ssid, "", 0);	    
+				memset(Ssid.Ssid, 0, NDIS_802_11_LENGTH_SSID);	    
 			}
 			pSsid = &Ssid;
 			if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)
@@ -4885,7 +4885,7 @@ INT Set_SSID_Proc(
 		else
 		{
 			Ssid.SsidLength = 0; //ANY ssid
-            memcpy(Ssid.Ssid, "", 0);	    
+			memset(Ssid.Ssid, 0, NDIS_802_11_LENGTH_SSID);
 		}
 		
 		pSsid = &Ssid;
diff --git a/sources/Module/rtusb_bulk.c b/sources/Module/rtusb_bulk.c
index f06eb4e..1a26a27 100755
--- a/sources/Module/rtusb_bulk.c
+++ b/sources/Module/rtusb_bulk.c
@@ -527,7 +527,7 @@ VOID	RTUSBInitTxDesc(
 						pSrc,
 						pTxContext->BulkOutSize,
 						Func,
-						pTxContext);
+			                        pTxContext);
 		
 }
 
@@ -546,8 +546,8 @@ VOID	RTUSBInitRxDesc(
 						usb_rcvbulkpipe(pAd->pUsb_Dev, 1),
 						pRxContext->TransferBuffer,
 						BUFFER_SIZE,
-						RTUSBBulkRxComplete,
-						pRxContext);
+			    (usb_complete_t) RTUSBBulkRxComplete,
+			                        pRxContext);
 }
 
 /*
@@ -646,7 +646,7 @@ VOID	RTUSBBulkOutDataPacket(
 	
 
 	// Init Tx context descriptor
-	RTUSBInitTxDesc(pAd, pTxContext, BulkOutPipeId, RTUSBBulkOutDataPacketComplete);
+	RTUSBInitTxDesc(pAd, pTxContext, BulkOutPipeId, (usb_complete_t)RTUSBBulkOutDataPacketComplete);
 
 	
 	pTxContext->IRPPending = TRUE;
@@ -702,7 +702,7 @@ VOID	RTUSBBulkOutNullFrame(
 
 
 	// Init Tx context descriptor
-	RTUSBInitTxDesc(pAd, pNullContext, 0, RTUSBBulkOutNullFrameComplete);
+	RTUSBInitTxDesc(pAd, pNullContext, 0,(usb_complete_t) RTUSBBulkOutNullFrameComplete);
 	pNullContext->IRPPending = TRUE;
 
 	pUrb = pNullContext->pUrb;
@@ -766,7 +766,7 @@ VOID	RTUSBBulkOutRTSFrame(
 	RTUSB_CLEAR_BULK_FLAG(pAd, fRTUSB_BULK_OUT_RTS);
 
 	// Init Tx context descriptor
-	RTUSBInitTxDesc(pAd, pRTSContext, PipeID, RTUSBBulkOutRTSFrameComplete);
+	RTUSBInitTxDesc(pAd, pRTSContext, PipeID,(usb_complete_t) RTUSBBulkOutRTSFrameComplete);
 	pRTSContext->IRPPending = TRUE;
 	
 	pUrb = pRTSContext->pUrb;
@@ -827,7 +827,7 @@ VOID	RTUSBBulkOutMLMEPacket(
 
 
 	// Init Tx context descriptor
-	RTUSBInitTxDesc(pAd, pMLMEContext, 0, RTUSBBulkOutMLMEPacketComplete);
+	RTUSBInitTxDesc(pAd, pMLMEContext, 0, (usb_complete_t)RTUSBBulkOutMLMEPacketComplete);
 	pMLMEContext->IRPPending = TRUE;
 
 
@@ -879,7 +879,7 @@ VOID	RTUSBBulkOutPsPoll(
 
 
 	// Init Tx context descriptor
-	RTUSBInitTxDesc(pAd, pPsPollContext, 0, RTUSBBulkOutPsPollComplete);
+	RTUSBInitTxDesc(pAd, pPsPollContext, 0, (usb_complete_t)RTUSBBulkOutPsPollComplete);
 	pPsPollContext->IRPPending = TRUE;
 	
 	pUrb = pPsPollContext->pUrb;
diff --git a/sources/Module/rtusb_data.c b/sources/Module/rtusb_data.c
index 68700cf..d2eb1d5 100755
--- a/sources/Module/rtusb_data.c
+++ b/sources/Module/rtusb_data.c
@@ -1,44 +1,49 @@
 /*
- ***************************************************************************
- * Ralink Tech Inc.
- * 5F, No. 36 Taiyuan St.
- * Jhubei City
- * Hsinchu County 302, Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2008, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  * 
- * it under the terms of the GNU General Public License as published by  * 
- * the Free Software Foundation; either version 2 of the License, or     * 
- * (at your option) any later version.                                   * 
- *                                                                       * 
- * This program is distributed in the hope that it will be useful,       * 
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
- * GNU General Public License for more details.                          * 
- *                                                                       * 
- * You should have received a copy of the GNU General Public License     * 
- * along with this program; if not, write to the                         * 
- * Free Software Foundation, Inc.,                                       * 
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
- *                                                                       * 
- *************************************************************************
-
-	Module Name:
-	rtmp_data.c
-
-	Abstract:
-	Ralink USB driver Tx/Rx functions
-
-	Revision History:
-	Who			When			What
-	--------	----------		----------------------------------------------
+***************************************************************************
+* Ralink Tech Inc.
+* 5F, No. 36 Taiyuan St.
+* Jhubei City
+* Hsinchu County 302, Taiwan, R.O.C.
+*
+* (c) Copyright 2002-2008, Ralink Technology, Inc.
+*
+* This program is free software; you can redistribute it and/or modify  * 
+* it under the terms of the GNU General Public License as published by  * 
+* the Free Software Foundation; either version 2 of the License, or     * 
+* (at your option) any later version.                                   * 
+*                                                                       * 
+* This program is distributed in the hope that it will be useful,       * 
+* but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+* GNU General Public License for more details.                          * 
+*                                                                       * 
+* You should have received a copy of the GNU General Public License     * 
+* along with this program; if not, write to the                         * 
+* Free Software Foundation, Inc.,                                       * 
+* 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+*                                                                       * 
+*************************************************************************
+
+Module Name:
+rtmp_data.c
+
+Abstract:
+Ralink USB driver Tx/Rx functions
+
+Revision History:
+Who			When			What
+--------	----------		----------------------------------------------
 
 */
+#include <linux/ip.h>
+#include <linux/udp.h>
+#include <linux/in.h>
 
 #include "rt_config.h"
 #include <net/iw_handler.h>
 
+uint64_t rts_cts_frame_duration = 0;
+
 extern	UCHAR Phy11BGNextRateUpward[]; // defined in mlme.c
 
 UCHAR	SNAP_802_1H[] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00};
@@ -50,15 +55,15 @@ UCHAR	IPX[] = {0x81, 0x37};
 UCHAR	APPLE_TALK[] = {0x80, 0xf3};
 
 UCHAR	RateIdToPlcpSignal[12] = { 
-	 0, /* RATE_1 */	1, /* RATE_2 */ 	2, /* RATE_5_5 */	3, /* RATE_11 */	// see BBP spec
-	11, /* RATE_6 */   15, /* RATE_9 */    10, /* RATE_12 */   14, /* RATE_18 */	// see IEEE802.11a-1999 p.14
-	 9, /* RATE_24 */  13, /* RATE_36 */	8, /* RATE_48 */   12  /* RATE_54 */ }; // see IEEE802.11a-1999 p.14
+  0, /* RATE_1 */	1, /* RATE_2 */ 	2, /* RATE_5_5 */	3, /* RATE_11 */	// see BBP spec
+  11, /* RATE_6 */   15, /* RATE_9 */    10, /* RATE_12 */   14, /* RATE_18 */	// see IEEE802.11a-1999 p.14
+  9, /* RATE_24 */  13, /* RATE_36 */	8, /* RATE_48 */   12  /* RATE_54 */ }; // see IEEE802.11a-1999 p.14
 
 UCHAR	 OfdmSignalToRateId[16] = {
-	RATE_54,  RATE_54,	RATE_54,  RATE_54,	// OFDM PLCP Signal = 0,  1,  2,  3 respectively
-	RATE_54,  RATE_54,	RATE_54,  RATE_54,	// OFDM PLCP Signal = 4,  5,  6,  7 respectively
-	RATE_48,  RATE_24,	RATE_12,  RATE_6,	// OFDM PLCP Signal = 8,  9,  10, 11 respectively
-	RATE_54,  RATE_36,	RATE_18,  RATE_9,	// OFDM PLCP Signal = 12, 13, 14, 15 respectively
+  RATE_54,  RATE_54,	RATE_54,  RATE_54,	// OFDM PLCP Signal = 0,  1,  2,  3 respectively
+  RATE_54,  RATE_54,	RATE_54,  RATE_54,	// OFDM PLCP Signal = 4,  5,  6,  7 respectively
+  RATE_48,  RATE_24,	RATE_12,  RATE_6,	// OFDM PLCP Signal = 8,  9,  10, 11 respectively
+  RATE_54,  RATE_36,	RATE_18,  RATE_9,	// OFDM PLCP Signal = 12, 13, 14, 15 respectively
 };
 
 UCHAR default_cwmin[]={CW_MIN_IN_BITS, CW_MIN_IN_BITS, CW_MIN_IN_BITS-1, CW_MIN_IN_BITS-2};
@@ -70,99 +75,99 @@ UCHAR MapUserPriorityToAccessCategory[8] = {QID_AC_BE, QID_AC_BK, QID_AC_BK, QID
  
 // Macro for rx indication
 VOID REPORT_ETHERNET_FRAME_TO_LLC(
-	IN	PRTMP_ADAPTER	pAd, 
-	IN	PUCHAR			p8023hdr,
-	IN	PUCHAR			pData,
-	IN	ULONG			DataSize,
-	IN	struct net_device	*net_dev)
+				  IN	PRTMP_ADAPTER	pAd, 
+				  IN	PUCHAR			p8023hdr,
+				  IN	PUCHAR			pData,
+				  IN	ULONG			DataSize,
+				  IN	struct net_device	*net_dev)
 {
-	struct sk_buff	*pSkb;
+  struct sk_buff	*pSkb;
 
 #ifdef RTMP_EMBEDDED
-	if ((pSkb = __dev_alloc_skb(DataSize + LENGTH_802_3 + 2, GFP_DMA|GFP_ATOMIC)) != NULL)
+  if ((pSkb = __dev_alloc_skb(DataSize + LENGTH_802_3 + 2, GFP_DMA|GFP_ATOMIC)) != NULL)
 #else
-	if ((pSkb = dev_alloc_skb(DataSize + LENGTH_802_3 + 2)) != NULL)
+    if ((pSkb = dev_alloc_skb(DataSize + LENGTH_802_3 + 2)) != NULL)
 #endif
 
-	{
-		pSkb->dev = net_dev;
-		skb_reserve(pSkb, 2);	// 16 byte align the IP header
-		memcpy(skb_put(pSkb, LENGTH_802_3), p8023hdr, LENGTH_802_3);
-		memcpy(skb_put(pSkb, DataSize), pData, DataSize);
-		pSkb->protocol = eth_type_trans(pSkb, net_dev);
+      {
+	pSkb->dev = net_dev;
+	skb_reserve(pSkb, 2);	// 16 byte align the IP header
+	memcpy(skb_put(pSkb, LENGTH_802_3), p8023hdr, LENGTH_802_3);
+	memcpy(skb_put(pSkb, DataSize), pData, DataSize);
+	pSkb->protocol = eth_type_trans(pSkb, net_dev);
 		
-		netif_rx(pSkb);
+	netif_rx(pSkb);
 
-		pAd->net_dev->last_rx = jiffies;
-		pAd->stats.rx_packets++;
+	pAd->net_dev->last_rx = jiffies;
+	pAd->stats.rx_packets++;
 
-		pAd->Counters8023.GoodReceives++;
-	}
+	pAd->Counters8023.GoodReceives++;
+      }
 }
 
 NDIS_STATUS	RTMPDecryptPktBySoftware(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PUCHAR			pData,	
-	IN	PRXD_STRUC		pRxD)
+					 IN	PRTMP_ADAPTER	pAd,
+					 IN	PUCHAR			pData,	
+					 IN	PRXD_STRUC		pRxD)
 {
-	UCHAR	KeyIdx = pAd->PortCfg.DefaultKeyId;
+  UCHAR	KeyIdx = pAd->PortCfg.DefaultKeyId;
 
-	DBGPRINT(RT_DEBUG_INFO, "RTMPDecryptPktBySoftware ==>\n");	
+  DBGPRINT(RT_DEBUG_INFO, "RTMPDecryptPktBySoftware ==>\n");	
 
-	// handle WEP decryption
-	if(pAd->PortCfg.WepStatus == Ndis802_11WEPEnabled)
-	{
-		UCHAR *pPayload = (UCHAR *)pData + LENGTH_802_11;
+  // handle WEP decryption
+  if(pAd->PortCfg.WepStatus == Ndis802_11WEPEnabled)
+    {
+      UCHAR *pPayload = (UCHAR *)pData + LENGTH_802_11;
 
-		if (RTMPDecryptData(pAd, pPayload, pRxD->DataByteCnt - LENGTH_802_11) == FALSE)
-		{
-			DBGPRINT(RT_DEBUG_ERROR, "ERROR : Software decrypt WEP data fails.\n");	
-			return (NDIS_STATUS_FAILURE);
-		}
-		else
-		{
-			pRxD->DataByteCnt -= 8;  //Minus IV[4] & ICV[4]			
-			pRxD->CipherAlg = CIPHER_WEP64;
-		}
-						
-		DBGPRINT(RT_DEBUG_INFO, "RTMPDecryptData WEP data Complete \n");						
+      if (RTMPDecryptData(pAd, pPayload, pRxD->DataByteCnt - LENGTH_802_11) == FALSE)
+	{
+	  DBGPRINT(RT_DEBUG_ERROR, "ERROR : Software decrypt WEP data fails.\n");	
+	  return (NDIS_STATUS_FAILURE);
 	}
-	// handle TKIP decryption
-	else if(pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled)
-	{	
-		if (RTMPSoftDecryptTKIP(pAd, pData, pRxD->DataByteCnt, 0, &pAd->SharedKey[KeyIdx]))
-		{								
-			DBGPRINT(RT_DEBUG_INFO, "RTMPSoftDecryptTKIP Complete \n");						
-			pRxD->DataByteCnt -= 20;  //Minus 8 bytes MIC, 8 bytes IV/EIV, 4 bytes ICV
-			pRxD->CipherAlg = CIPHER_TKIP;
-		}
-		else
-		{
-			DBGPRINT(RT_DEBUG_ERROR, "ERROR : RTMPSoftDecryptTKIP Failed\n");
-			return (NDIS_STATUS_FAILURE);
-		}
+      else
+	{
+	  pRxD->DataByteCnt -= 8;  //Minus IV[4] & ICV[4]			
+	  pRxD->CipherAlg = CIPHER_WEP64;
 	}
-	// handle AES decryption
-	else if(pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)
+						
+      DBGPRINT(RT_DEBUG_INFO, "RTMPDecryptData WEP data Complete \n");						
+    }
+  // handle TKIP decryption
+  else if(pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled)
+    {	
+      if (RTMPSoftDecryptTKIP(pAd, pData, pRxD->DataByteCnt, 0, &pAd->SharedKey[KeyIdx]))
+	{								
+	  DBGPRINT(RT_DEBUG_INFO, "RTMPSoftDecryptTKIP Complete \n");						
+	  pRxD->DataByteCnt -= 20;  //Minus 8 bytes MIC, 8 bytes IV/EIV, 4 bytes ICV
+	  pRxD->CipherAlg = CIPHER_TKIP;
+	}
+      else
 	{
-		if (RTMPSoftDecryptAES(pAd, pData, pRxD->DataByteCnt, &pAd->SharedKey[KeyIdx]))
-		{							
-			DBGPRINT(RT_DEBUG_INFO, "RTMPSoftDecryptAES Complete \n");							
-			pRxD->DataByteCnt -= 16;  //8 bytes MIC, 8 bytes IV/EIV (CCMP Header)
-			pRxD->CipherAlg = CIPHER_AES;
-		}
-		else
-		{
-			DBGPRINT(RT_DEBUG_ERROR, "ERROR : RTMPSoftDecryptAES Failed\n");
-			return (NDIS_STATUS_FAILURE);
-		}
+	  DBGPRINT(RT_DEBUG_ERROR, "ERROR : RTMPSoftDecryptTKIP Failed\n");
+	  return (NDIS_STATUS_FAILURE);
+	}
+    }
+  // handle AES decryption
+  else if(pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)
+    {
+      if (RTMPSoftDecryptAES(pAd, pData, pRxD->DataByteCnt, &pAd->SharedKey[KeyIdx]))
+	{							
+	  DBGPRINT(RT_DEBUG_INFO, "RTMPSoftDecryptAES Complete \n");							
+	  pRxD->DataByteCnt -= 16;  //8 bytes MIC, 8 bytes IV/EIV (CCMP Header)
+	  pRxD->CipherAlg = CIPHER_AES;
 	}
-	else
+      else
 	{
-		return (NDIS_STATUS_FAILURE);
-	}		
+	  DBGPRINT(RT_DEBUG_ERROR, "ERROR : RTMPSoftDecryptAES Failed\n");
+	  return (NDIS_STATUS_FAILURE);
+	}
+    }
+  else
+    {
+      return (NDIS_STATUS_FAILURE);
+    }		
             		
-	return (NDIS_STATUS_SUCCESS);
+  return (NDIS_STATUS_SUCCESS);
 }
 
 // Enqueue this frame to MLME engine
@@ -170,3514 +175,3627 @@ NDIS_STATUS	RTMPDecryptPktBySoftware(
 // information from 802.11 header
 // edit by johnli, fix WPAPSK/WPA2PSK bugs for receiving EAPoL fragmentation packets
 /* 
-#define REPORT_MGMT_FRAME_TO_MLME(_pAd, _pFrame, _FrameSize, _Rssi, _PlcpSignal)		\
-{																						\
-	MlmeEnqueueForRecv(_pAd, (UCHAR)_Rssi, _FrameSize, _pFrame, (UCHAR)_PlcpSignal);   \
-}
+   #define REPORT_MGMT_FRAME_TO_MLME(_pAd, _pFrame, _FrameSize, _Rssi, _PlcpSignal)		\
+   {																						\
+   MlmeEnqueueForRecv(_pAd, (UCHAR)_Rssi, _FrameSize, _pFrame, (UCHAR)_PlcpSignal);   \
+   }
 */
-#define REPORT_MGMT_FRAME_TO_MLME(_pAd, _p80211hdr, _pFrame, _FrameSize, _Rssi, _PlcpSignal)		\
-{																						\
-	MlmeEnqueueForRecv(_pAd, (PFRAME_802_11)_p80211hdr, (UCHAR)_Rssi, _FrameSize, _pFrame, (UCHAR)_PlcpSignal);   \
-}
+#define REPORT_MGMT_FRAME_TO_MLME(_pAd, _p80211hdr, _pFrame, _FrameSize, _Rssi, _PlcpSignal) \
+  {									\
+    MlmeEnqueueForRecv(_pAd, (PFRAME_802_11)_p80211hdr, (UCHAR)_Rssi, _FrameSize, _pFrame, (UCHAR)_PlcpSignal);	\
+  }
 // end johnli
 
 // NOTE: we do have an assumption here, that Byte0 and Byte1 always reasid at the same 
 //		 scatter gather buffer
 NDIS_STATUS Sniff2BytesFromNdisBuffer(
-	IN	struct sk_buff	*pFirstSkb,
-	IN	UCHAR			DesiredOffset,
-	OUT PUCHAR			pByte0,
-	OUT PUCHAR			pByte1)
+				      IN	struct sk_buff	*pFirstSkb,
+				      IN	UCHAR			DesiredOffset,
+				      OUT PUCHAR			pByte0,
+				      OUT PUCHAR			pByte1)
 {
-	PUCHAR pBufferVA;
-	ULONG  BufferLen, AccumulateBufferLen, BufferBeginOffset;
+  PUCHAR pBufferVA;
+  ULONG  BufferLen, AccumulateBufferLen, BufferBeginOffset;
 	
-	pBufferVA = (PVOID)pFirstSkb->data;
-	BufferLen = pFirstSkb->len;
-	BufferBeginOffset	= 0;
-	AccumulateBufferLen = BufferLen;
+  pBufferVA = (PVOID)pFirstSkb->data;
+  BufferLen = pFirstSkb->len;
+  BufferBeginOffset	= 0;
+  AccumulateBufferLen = BufferLen;
+
+  *pByte0 = *(PUCHAR)(pBufferVA + DesiredOffset - BufferBeginOffset);
+  *pByte1 = *(PUCHAR)(pBufferVA + DesiredOffset - BufferBeginOffset + 1);
+  return NDIS_STATUS_SUCCESS;
+}
+
+__be16 udp_checksum(struct iphdr* iphdr, struct udphdr* udphdr, unsigned char* data){
+  __be32 sum = 0;
+  __be16 proto = 0x1100; //17 udp
+  __be16 data_length = (__be16) ntohs(udphdr->len) - sizeof(struct udphdr);
+  __be16 src[2];
+  __be16 dest[2];
+  __be16 *padded_data;
+  int padded_data_length, i;
+  
+  if(data_length % 2 != 0)
+    padded_data_length = (int) data_length / 2 + 1;
+  else
+    padded_data_length = (int) data_length / 2;
+
+  padded_data = kmalloc(padded_data_length * sizeof(__be16), GFP_ATOMIC);
+
+  if(!padded_data){
+    printk("%s %s:%u: kmalloc failed to allocate space for padded data in udp checksum. As a result checksum is not calculated.\n", __FILE__, __FUNCTION__, __LINE__);
+    return 0;
+  }
+
+  padded_data[padded_data_length - 1] = 0;
+  memcpy(padded_data,data, data_length);
+
+  src[0] = (__be16) (iphdr->saddr >> 16);
+  src[1] = (__be16) (iphdr->saddr);
+  dest[0] = (__be16) (iphdr->daddr >> 16);
+  dest[1] = (__be16) (iphdr->daddr);
+
+  data_length = (__be16) htons(data_length);
+
+
+  sum = src[0] + src[1] + dest[0] + dest[1] + proto + udphdr->len + udphdr->source + udphdr->dest + udphdr->len;
+  
+  for(i = 0; i < padded_data_length; i++)
+    sum += padded_data[i];
+ 
+  while(sum >> 16)
+    sum = (__be16) (sum & 0xFFFF) + (__be16) (sum >> 16);
+
+  kfree(padded_data);
+  
+  return (__be16) ~sum;
+}
 
-	*pByte0 = *(PUCHAR)(pBufferVA + DesiredOffset - BufferBeginOffset);
-	*pByte1 = *(PUCHAR)(pBufferVA + DesiredOffset - BufferBeginOffset + 1);
-	return NDIS_STATUS_SUCCESS;
+int64_t swap_64bit_word_byte_order(int64_t time){
+  unsigned char* bytes = (unsigned char*) &time;
+  uint32_t word;
+
+  memcpy(&word, bytes, sizeof(uint32_t));
+  word = htonl(word);
+  memcpy(bytes, &word, sizeof(uint32_t));
+  
+  memcpy(&word, bytes + sizeof(uint32_t), sizeof(uint32_t));
+  word = htonl(word);
+  memcpy(bytes + sizeof(uint32_t), &word, sizeof(uint32_t));
+  
+  return * ((int64_t *) bytes);
 }
 
 /*
-	========================================================================
+  ========================================================================
 
-	Routine	Description:
-		This routine classifies outgoing frames into several AC (Access
-		Category) and enqueue them into corresponding s/w waiting queues.
+  Routine	Description:
+  This routine classifies outgoing frames into several AC (Access
+  Category) and enqueue them into corresponding s/w waiting queues.
 		
-	Arguments:
-		pAd	Pointer	to our adapter
-		pPacket		Pointer to send packet
+  Arguments:
+  pAd	Pointer	to our adapter
+  pPacket		Pointer to send packet
 		
-	Return Value:
-		None
+  Return Value:
+  None
 	
-	Note:
+  Note:
 	
-	========================================================================
+  ========================================================================
 */
 NDIS_STATUS	RTMPSendPacket(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	struct sk_buff	*pSkb)
+			       IN	PRTMP_ADAPTER	pAd,
+			       IN	struct sk_buff	*pSkb)
 {
-	PUCHAR			pSrcBufVA;
-	UINT			AllowFragSize;
-	UCHAR			NumberOfFrag;
-	UCHAR			RTSRequired;
-	UCHAR			QueIdx, UserPriority;
-	NDIS_STATUS 	Status = NDIS_STATUS_SUCCESS;
-	PQUEUE_HEADER	pTxQueue;
-	UCHAR			PsMode;
-	unsigned long	IrqFlags;
-	
-	DBGPRINT(RT_DEBUG_INFO, "====> RTMPSendPacket\n");
-
-	// Prepare packet information structure for buffer descriptor 
-	pSrcBufVA = (PVOID)pSkb->data;
-
-	// STEP 1. Check for virtual address allocation, it might fail !!! 
-	if (pSrcBufVA == NULL)
-	{
-		// Resourece is low, system did not allocate virtual address
-		// return NDIS_STATUS_FAILURE directly to upper layer
-		return NDIS_STATUS_FAILURE;
-	}
+  PUCHAR			pSrcBufVA;
+  UINT			AllowFragSize;
+  UCHAR			NumberOfFrag;
+  UCHAR			RTSRequired;
+  UCHAR			QueIdx, UserPriority;
+  NDIS_STATUS 	Status = NDIS_STATUS_SUCCESS;
+  PQUEUE_HEADER	pTxQueue;
+  UCHAR			PsMode;
+  unsigned long	IrqFlags;
+  static ULONG OldFailLowValue = 0;
+  static ULONG OldFailHighValue = 0;
+
+  /*Fred's stuff*/
+  struct iphdr* iph;
+  struct udphdr* udph = NULL;
+  uint8_t store_duration = 0;
+  uint64_t time_to_transmit_last_packet = 0, total_time = 0;
+  /*==========*/
     
-	//
-	// Check for multicast or broadcast (First byte of DA)
-	//
-	if ((*((PUCHAR) pSrcBufVA) & 0x01) != 0)
-	{
-		// For multicast & broadcast, there is no fragment allowed
-		NumberOfFrag = 1;
-	}
-	else
-	{
-		// Check for payload allowed for each fragment 
-		AllowFragSize = (pAd->PortCfg.FragmentThreshold) - LENGTH_802_11 - LENGTH_CRC;
-
-		// Calculate fragments required		
-		NumberOfFrag = ((pSkb->len - LENGTH_802_3 + LENGTH_802_1_H) / AllowFragSize) + 1;
-		// Minus 1 if the size just match to allowable fragment size
-		if (((pSkb->len - LENGTH_802_3 + LENGTH_802_1_H) % AllowFragSize) == 0)
-		{
-			NumberOfFrag--;
-		}
-	}
-	
-	// Save fragment number to Ndis packet reserved field
-	RTMP_SET_PACKET_FRAGMENTS(pSkb, NumberOfFrag);	
+  ULONG dif1 = 0, dif2 = 0;
 	
+  DBGPRINT(RT_DEBUG_INFO, "====> RTMPSendPacket\n");
 
-	// STEP 2. Check the requirement of RTS:
-	//	   If multiple fragment required, RTS is required only for the first fragment
-	//	   if the fragment size large than RTS threshold
-	
-	if (NumberOfFrag > 1)
-		RTSRequired = (pAd->PortCfg.FragmentThreshold > pAd->PortCfg.RtsThreshold) ? 1 : 0;
-	else
-		RTSRequired = (pSkb->len > pAd->PortCfg.RtsThreshold) ? 1 : 0;
-
-    //
-	// Remove the following lines to avoid confusion. 
-	// CTS requirement will not use Flag "RTSRequired", instead moveing the 
-	// following lines to RTUSBHardTransmit(..)
-	//
-	// RTS/CTS may also be required in order to protect OFDM frame
-	//if ((pAd->PortCfg.TxRate >= RATE_FIRST_OFDM_RATE) && 
-	//	OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_BG_PROTECTION_INUSED))
-	//	RTSRequired = 1;
-
-	// Save RTS requirement to Ndis packet reserved field
-		RTMP_SET_PACKET_RTS(pSkb, RTSRequired);
-		RTMP_SET_PACKET_TXRATE(pSkb, pAd->PortCfg.TxRate);
+  // Prepare packet information structure for buffer descriptor 
+  pSrcBufVA = (PVOID)pSkb->data;
 
+  // STEP 1. Check for virtual address allocation, it might fail !!! 
+  if (pSrcBufVA == NULL)
+    {
+      // Resourece is low, system did not allocate virtual address
+      // return NDIS_STATUS_FAILURE directly to upper layer
+      return NDIS_STATUS_FAILURE;
+    }
+    
+  //
+  // Check for multicast or broadcast (First byte of DA)
+  //
+  if ((*((PUCHAR) pSrcBufVA) & 0x01) != 0)
+    {
+      // For multicast & broadcast, there is no fragment allowed
+      NumberOfFrag = 1;
+    }
+  else
+    {
+      // Check for payload allowed for each fragment 
+      AllowFragSize = (pAd->PortCfg.FragmentThreshold) - LENGTH_802_11 - LENGTH_CRC;
 
-	//
-	// STEP 3. Traffic classification. outcome = <UserPriority, QueIdx>
-	//
-	UserPriority = 0;
-	QueIdx		 = QID_AC_BE;
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED))
+      // Calculate fragments required		
+      NumberOfFrag = ((pSkb->len - LENGTH_802_3 + LENGTH_802_1_H) / AllowFragSize) + 1;
+      // Minus 1 if the size just match to allowable fragment size
+      if (((pSkb->len - LENGTH_802_3 + LENGTH_802_1_H) % AllowFragSize) == 0)
 	{
-		USHORT Protocol;
-		UCHAR  LlcSnapLen = 0, Byte0, Byte1;
-		do
-		{
-			// get Ethernet protocol field
-			Protocol = (USHORT)((pSrcBufVA[12] << 8) + pSrcBufVA[13]);
-			if (Protocol <= 1500)
-			{
-				// get Ethernet protocol field from LLC/SNAP
-				if (Sniff2BytesFromNdisBuffer(pSkb, LENGTH_802_3 + 6, &Byte0, &Byte1) != NDIS_STATUS_SUCCESS)
-					break;
+	  NumberOfFrag--;
+	}
+    }
+	
+  // Save fragment number to Ndis packet reserved field
+  RTMP_SET_PACKET_FRAGMENTS(pSkb, NumberOfFrag);	
+	
+
+  // STEP 2. Check the requirement of RTS:
+  //	   If multiple fragment required, RTS is required only for the first fragment
+  //	   if the fragment size large than RTS threshold
+	
+  if (NumberOfFrag > 1)
+    RTSRequired = (pAd->PortCfg.FragmentThreshold > pAd->PortCfg.RtsThreshold) ? 1 : 0;
+  else
+    RTSRequired = (pSkb->len > pAd->PortCfg.RtsThreshold) ? 1 : 0;
+
+  //
+  // Remove the following lines to avoid confusion. 
+  // CTS requirement will not use Flag "RTSRequired", instead moveing the 
+  // following lines to RTUSBHardTransmit(..)
+  //
+  // RTS/CTS may also be required in order to protect OFDM frame
+  //if ((pAd->PortCfg.TxRate >= RATE_FIRST_OFDM_RATE) && 
+  //	OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_BG_PROTECTION_INUSED))
+  //	RTSRequired = 1;
+
+  // Save RTS requirement to Ndis packet reserved field
+  RTMP_SET_PACKET_RTS(pSkb, RTSRequired);
+  RTMP_SET_PACKET_TXRATE(pSkb, pAd->PortCfg.TxRate);
+
+  iph = ip_hdr(pSkb);
+  if(iph->protocol == IPPROTO_UDP){
+    udph = (struct udphdr*) (pSkb->data + (iph->ihl << 2));
+    if(udph->dest == htons(57843)) //I don't like to make this hardcoded, but for now it'll have to do.
+      store_duration = 1;
+  }
+
+  if (OldFailLowValue != pAd->WlanCounters.RetryCount.vv.LowPart || OldFailHighValue != pAd->WlanCounters.RetryCount.vv.HighPart)
+    {
+      dif1 = pAd->WlanCounters.RetryCount.vv.HighPart - OldFailHighValue;
+      dif2 = pAd->WlanCounters.RetryCount.vv.LowPart - OldFailLowValue;
+      //This code is buggy. dif1 and dif2 are ULONG which should have 4 bytes not 8 as I thought.
+      /*      if ( ((int64_t) dif2) < 0 )
+       {
+         dif1 -= 1;
+         dif2 = 0xFFFFFFFFFFFFFFFF + (int64_t) dif2;
+	 }*/
+      printk ("Change in tx fail count. Last packet suffered %d retries.\n", dif2);
+    }
+  
+  OldFailLowValue = pAd->WlanCounters.RetryCount.vv.LowPart;
+  OldFailHighValue = pAd->WlanCounters.RetryCount.vv.HighPart;
+  
+  //=====================================================================================
+  /*This is how I store values in an application payload*/
+  if(store_duration){ //Store duration in packet
+    total_time = time_to_transmit_last_packet + dif2 * (time_to_transmit_last_packet + RTMPCalcDuration(pAd, RTMP_GET_PACKET_TXRATE (pSkb), pSkb->len));
+
+    //First locate the place where duration value should be stored. It should be, after the ip header, plus the udp header + 16 bytes, 
+    //that is, after 16 bytes of application payload.
+    total_time = swap_64bit_word_byte_order(total_time);
+    memcpy((((char*)iph) + (iph->ihl << 2) + sizeof(struct udphdr) + 16), &total_time, sizeof(total_time));
+
+    //Keep time to tansmit last packet. REMEMBER: This will run only once for each packet.
+    time_to_transmit_last_packet = pAd->PortCfg.Dsifs + RTMPCalcDuration(pAd, RTMP_GET_PACKET_TXRATE (pSkb), pSkb->len); // SIFS + Data
+
+    //Don't forget to recalculte udp checksum
+    udph->check = udp_checksum(iph, udph, pSkb->data + (iph->ihl << 2) + sizeof(struct udphdr));
+    //If udp checksum is 0 then we have to make it 0xFFFF, because 0 disables udp checksum.
+    if(!udph->check)
+      udph->check = 0xFFFF;
+
+    printk("RTS + CTS + DIFS + SIFS = %llu\n", rts_cts_frame_duration);
+    printk("Total estimated time for packet %u is %llu\n", *(unsigned int*) (((char*) udph) + 24) - 1, total_time);
+  }
+  //===================================================
+
+  //
+  // STEP 3. Traffic classification. outcome = <UserPriority, QueIdx>
+  //
+  UserPriority = 0;
+  QueIdx		 = QID_AC_BE;
+  if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED))
+    {
+      USHORT Protocol;
+      UCHAR  LlcSnapLen = 0, Byte0, Byte1;
+      do
+	{
+	  // get Ethernet protocol field
+	  Protocol = (USHORT)((pSrcBufVA[12] << 8) + pSrcBufVA[13]);
+	  if (Protocol <= 1500)
+	    {
+	      // get Ethernet protocol field from LLC/SNAP
+	      if (Sniff2BytesFromNdisBuffer(pSkb, LENGTH_802_3 + 6, &Byte0, &Byte1) != NDIS_STATUS_SUCCESS)
+		break;
 		
-				Protocol = (USHORT)((Byte0 << 8) + Byte1);
-				LlcSnapLen = 8;
-			}
+	      Protocol = (USHORT)((Byte0 << 8) + Byte1);
+	      LlcSnapLen = 8;
+	    }
 
-			// always AC_BE for non-IP packet
-			if (Protocol != 0x0800)
-				break;
+	  // always AC_BE for non-IP packet
+	  if (Protocol != 0x0800)
+	    break;
 
-			// get IP header
-			if (Sniff2BytesFromNdisBuffer(pSkb, LENGTH_802_3 + LlcSnapLen, &Byte0, &Byte1) != NDIS_STATUS_SUCCESS)
-				break;
+	  // get IP header
+	  if (Sniff2BytesFromNdisBuffer(pSkb, LENGTH_802_3 + LlcSnapLen, &Byte0, &Byte1) != NDIS_STATUS_SUCCESS)
+	    break;
 
-			// return AC_BE if packet is not IPv4
-			if ((Byte0 & 0xf0) != 0x40)
-				break;
+	  // return AC_BE if packet is not IPv4
+	  if ((Byte0 & 0xf0) != 0x40)
+	    break;
 
-			UserPriority = (Byte1 & 0xe0) >> 5;
-			QueIdx = MapUserPriorityToAccessCategory[UserPriority];
+	  UserPriority = (Byte1 & 0xe0) >> 5;
+	  QueIdx = MapUserPriorityToAccessCategory[UserPriority];
 
-			// TODO: have to check ACM bit. apply TSPEC if ACM is ON
-			// TODO: downgrade UP & QueIdx before passing ACM
-			if (pAd->PortCfg.APEdcaParm.bACM[QueIdx])
-			{
-				UserPriority = 0;
-				QueIdx		 = QID_AC_BE;
-			}
-		} while (FALSE);
-	}
+	  // TODO: have to check ACM bit. apply TSPEC if ACM is ON
+	  // TODO: downgrade UP & QueIdx before passing ACM
+	  if (pAd->PortCfg.APEdcaParm.bACM[QueIdx])
+	    {
+	      UserPriority = 0;
+	      QueIdx		 = QID_AC_BE;
+	    }
+	} while (FALSE);
+    }
 	
-	RTMP_SET_PACKET_UP(pSkb, UserPriority);
+  RTMP_SET_PACKET_UP(pSkb, UserPriority);
 
-	// Make sure SendTxWait queue resource won't be used by other threads
-	NdisAcquireSpinLock(&pAd->SendTxWaitQueueLock[QueIdx], IrqFlags);
+  // Make sure SendTxWait queue resource won't be used by other threads
+  NdisAcquireSpinLock(&pAd->SendTxWaitQueueLock[QueIdx], IrqFlags);
 
-	pTxQueue = &pAd->SendTxWaitQueue[QueIdx];
-	if (pTxQueue->Number > pAd->MaxTxQueueSize)
-	{
+  pTxQueue = &pAd->SendTxWaitQueue[QueIdx];
+  if (pTxQueue->Number > pAd->MaxTxQueueSize)
+    {
 #ifdef BLOCK_NET_IF
-		StopNetIfQueue(pAd, QueIdx, pSkb);
+      StopNetIfQueue(pAd, QueIdx, pSkb);
 #endif // BLOCK_NET_IF //
-		NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[QueIdx], IrqFlags);
-		return NDIS_STATUS_FAILURE;
-	}
+      NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[QueIdx], IrqFlags);
+      return NDIS_STATUS_FAILURE;
+    }
 
-	//
-	// For infrastructure mode, enqueue this frame immediately to sendwaitqueue
-	// For Ad-hoc mode, check the DA power state, then decide which queue to enqueue
-	//
-	if (INFRA_ON(pAd) )
-	{
-		// In infrastructure mode, simply enqueue the packet into Tx waiting queue.
-		DBGPRINT(RT_DEBUG_INFO, "Infrastructure -> Enqueue one frame\n");
+  //
+  // For infrastructure mode, enqueue this frame immediately to sendwaitqueue
+  // For Ad-hoc mode, check the DA power state, then decide which queue to enqueue
+  //
+  if (INFRA_ON(pAd) )
+    {
+      // In infrastructure mode, simply enqueue the packet into Tx waiting queue.
+      DBGPRINT(RT_DEBUG_INFO, "Infrastructure -> Enqueue one frame\n");
 
-		// Enqueue Ndis packet to end of Tx wait queue
-		InsertTailQueue(pTxQueue, pSkb);
-		Status = NDIS_STATUS_SUCCESS;
+      // Enqueue Ndis packet to end of Tx wait queue
+      InsertTailQueue(pTxQueue, pSkb);
+      Status = NDIS_STATUS_SUCCESS;
 #ifdef DBG
-        pAd->RalinkCounters.OneSecOsTxCount[QueIdx]++;  // TODO: for debug only. to be removed
+      pAd->RalinkCounters.OneSecOsTxCount[QueIdx]++;  // TODO: for debug only. to be removed
 #endif		
-	}
-	else
+    }
+  else
+    {
+      // In IBSS mode, power state of destination should be considered.
+      PsMode = PWR_ACTIVE;		// Faked
+      if (PsMode == PWR_ACTIVE)
 	{
-		// In IBSS mode, power state of destination should be considered.
-		PsMode = PWR_ACTIVE;		// Faked
-		if (PsMode == PWR_ACTIVE)
-		{
-			DBGPRINT(RT_DEBUG_INFO,"Ad-Hoc -> Enqueue one frame\n");
+	  DBGPRINT(RT_DEBUG_INFO,"Ad-Hoc -> Enqueue one frame\n");
 	
-			// Enqueue Ndis packet to end of Tx wait queue
-			InsertTailQueue(pTxQueue, pSkb);
-			Status = NDIS_STATUS_SUCCESS;
+	  // Enqueue Ndis packet to end of Tx wait queue
+	  InsertTailQueue(pTxQueue, pSkb);
+	  Status = NDIS_STATUS_SUCCESS;
 #ifdef DBG
-            pAd->RalinkCounters.OneSecOsTxCount[QueIdx]++;  // TODO: for debug only. to be removed
+	  pAd->RalinkCounters.OneSecOsTxCount[QueIdx]++;  // TODO: for debug only. to be removed
 #endif			
-		}
 	}
+    }
 
-	NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[QueIdx], IrqFlags);
-	DBGPRINT(RT_DEBUG_INFO, "<==== RTMPSendPacket\n");
-	return (Status);
+  NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[QueIdx], IrqFlags);
+  DBGPRINT(RT_DEBUG_INFO, "<==== RTMPSendPacket\n");
+  return (Status);
 }
 
 /*
-	========================================================================
+  ========================================================================
 
-	Routine Description:
-		SendPackets handler
+  Routine Description:
+  SendPackets handler
 
-	Arguments:
-		skb 			point to sk_buf which upper layer transmit
-		net_dev 		point to net_dev
-	Return Value:
-		None
+  Arguments:
+  skb 			point to sk_buf which upper layer transmit
+  net_dev 		point to net_dev
+  Return Value:
+  None
 
-	Note:
+  Note:
 
-	========================================================================
+  ========================================================================
 */
 INT RTMPSendPackets(
-	IN	struct sk_buff		*pSkb,
-	IN	struct net_device	*net_dev)
+		    IN	struct sk_buff		*pSkb,
+		    IN	struct net_device	*net_dev)
 {
-	PRTMP_ADAPTER	pAd = RTMP_OS_NETDEV_GET_PRIV(net_dev);
-	NDIS_STATUS 	Status = NDIS_STATUS_SUCCESS;
-	INT 			Index;
+  PRTMP_ADAPTER	pAd = RTMP_OS_NETDEV_GET_PRIV(net_dev);
+  NDIS_STATUS 	Status = NDIS_STATUS_SUCCESS;
+  INT 			Index;
 
-	DBGPRINT(RT_DEBUG_INFO, "===> RTMPSendPackets\n");
+  DBGPRINT(RT_DEBUG_INFO, "===> RTMPSendPackets\n");
 
 #ifdef RALINK_ATE
-	if (pAd->ate.Mode != ATE_STASTART)
-	{
-		RTUSBFreeSkbBuffer(pSkb);
-		return 0;
-	}
+  if (pAd->ate.Mode != ATE_STASTART)
+    {
+      RTUSBFreeSkbBuffer(pSkb);
+      return 0;
+    }
 #endif
 	 	 
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS) ||
-		RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
-	{
-		// Drop send request since hardware is in reset state
-		RTUSBFreeSkbBuffer(pSkb);
-		return 0;
-	}	  
-	// Drop packets if no associations
-	else if (!INFRA_ON(pAd) && !ADHOC_ON(pAd) )
-	{
-		RTUSBFreeSkbBuffer(pSkb);
-		return 0;
-	}
-	else
-	{
-		// Record that orignal packet source is from protocol layer,so that 
-		// later on driver knows how to release this skb buffer
-		RTMP_SET_PACKET_SOURCE(pSkb, PKTSRC_NDIS);
-		pAd->RalinkCounters.PendingNdisPacketCount ++;
-		
-			Status = RTMPSendPacket(pAd, pSkb);
-			if (Status != NDIS_STATUS_SUCCESS)
-			{
-				// Errors before enqueue stage
-				RELEASE_NDIS_PACKET(pAd, pSkb);
-				DBGPRINT(RT_DEBUG_TRACE,"<---RTUSBSendPackets not dequeue\n");
-				return 0;
-			}		
-	}
+  if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS) ||
+      RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
+    {
+      // Drop send request since hardware is in reset state
+      RTUSBFreeSkbBuffer(pSkb);
+      return 0;
+    }	  
+  // Drop packets if no associations
+  else if (!INFRA_ON(pAd) && !ADHOC_ON(pAd) )
+    {
+      RTUSBFreeSkbBuffer(pSkb);
+      return 0;
+    }
+  else
+    {
+      // Record that orignal packet source is from protocol layer,so that 
+      // later on driver knows how to release this skb buffer
+      RTMP_SET_PACKET_SOURCE(pSkb, PKTSRC_NDIS);
+      pAd->RalinkCounters.PendingNdisPacketCount ++;
+		
+      Status = RTMPSendPacket(pAd, pSkb);
+      if (Status != NDIS_STATUS_SUCCESS)
+	{
+	  // Errors before enqueue stage
+	  RELEASE_NDIS_PACKET(pAd, pSkb);
+	  DBGPRINT(RT_DEBUG_TRACE,"<---RTUSBSendPackets not dequeue\n");
+	  return 0;
+	}		
+    }
 
-	// Dequeue one frame from SendTxWait queue and process it
-	// There are two place calling dequeue for TX ring.
-	// 1. Here, right after queueing the frame.
-	// 2. At the end of TxRingTxDone service routine.
-	if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) && 
-		(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF)) &&
-		(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-		(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)))
+  // Dequeue one frame from SendTxWait queue and process it
+  // There are two place calling dequeue for TX ring.
+  // 1. Here, right after queueing the frame.
+  // 2. At the end of TxRingTxDone service routine.
+  if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) && 
+      (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF)) &&
+      (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+      (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)))
+    {
+      for (Index = 0; Index < 4; Index++)
 	{
-		for (Index = 0; Index < 4; Index++)
-		{
-			if(pAd->SendTxWaitQueue[Index].Number > 0)
-			{
-				RTMPDeQueuePacket(pAd, Index);
-			}
-		}
+	  if(pAd->SendTxWaitQueue[Index].Number > 0)
+	    {
+	      RTMPDeQueuePacket(pAd, Index);
+	    }
 	}
+    }
 
-	// Kick bulk out
-	RTUSBKickBulkOut(pAd);
+  // Kick bulk out
+  RTUSBKickBulkOut(pAd);
 
-	DBGPRINT(RT_DEBUG_INFO, "<=== RTMPSendPackets\n");
+  DBGPRINT(RT_DEBUG_INFO, "<=== RTMPSendPackets\n");
 
-	return 0;
+  return 0;
 }
 
 /*
-	========================================================================
+  ========================================================================
 
-	Routine	Description:
-		Copy frame from waiting queue into relative ring buffer and set 
-	appropriate ASIC register to kick hardware encryption before really
-	sent out to air.
+  Routine	Description:
+  Copy frame from waiting queue into relative ring buffer and set 
+  appropriate ASIC register to kick hardware encryption before really
+  sent out to air.
 		
-	Arguments:
-		pAd				Pointer	to our adapter
-		PNDIS_PACKET	Pointer to outgoing Ndis frame
-		NumberOfFrag	Number of fragment required
+  Arguments:
+  pAd				Pointer	to our adapter
+  PNDIS_PACKET	Pointer to outgoing Ndis frame
+  NumberOfFrag	Number of fragment required
 		
-	Return Value:
-		None
+  Return Value:
+  None
 
-	Note:
+  Note:
 	
-	========================================================================
+  ========================================================================
 */
 #ifdef BIG_ENDIAN	
 static inline
 #endif
 NDIS_STATUS RTUSBHardTransmit(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	struct sk_buff	*pSkb,
-	IN	UCHAR			NumberRequired,
-	IN	UCHAR			QueIdx)
+			      IN	PRTMP_ADAPTER	pAd,
+			      IN	struct sk_buff	*pSkb,
+			      IN	UCHAR			NumberRequired,
+			      IN	UCHAR			QueIdx)
 {
-	UINT			LengthQosPAD =0;
-	UINT			BytesCopied;
-	UINT			TxSize;
-	UINT			FreeMpduSize;
-	UINT			SrcRemainingBytes;
-	USHORT			Protocol;
-	UCHAR			FrameGap;
-	HEADER_802_11	Header_802_11;
-	PHEADER_802_11	pHeader80211;	
-	PUCHAR			pDest;
-//	PUCHAR			pSrc;
-	PTX_CONTEXT		pTxContext;
-	PTXD_STRUC		pTxD;
+  UINT			LengthQosPAD =0;
+  UINT			BytesCopied;
+  UINT			TxSize;
+  UINT			FreeMpduSize;
+  UINT			SrcRemainingBytes;
+  USHORT			Protocol;
+  UCHAR			FrameGap;
+  HEADER_802_11	Header_802_11;
+  PHEADER_802_11	pHeader80211;	
+  PUCHAR			pDest;
+  //	PUCHAR			pSrc;
+  PTX_CONTEXT		pTxContext;
+  PTXD_STRUC		pTxD;
 #ifdef BIG_ENDIAN				
-	PTXD_STRUC		pDestTxD;
-	TXD_STRUC		TxD;
+  PTXD_STRUC		pDestTxD;
+  TXD_STRUC		TxD;
 #endif
-//	PURB			pUrb;
-	BOOLEAN			StartOfFrame;
-	BOOLEAN			bEAPOLFrame;
-	ULONG			Iv16;
-	ULONG			Iv32;
-	BOOLEAN			MICFrag;
-//	PCIPHER_KEY		pWpaKey = NULL;
-	NDIS_802_11_WEP_STATUS	EncryptType = Ndis802_11EncryptionDisabled;
-	ULONG			TransferBufferLength;
-	USHORT			AckDuration = 0;
-	USHORT			EncryptionOverhead = 0;
-	UCHAR			CipherAlg;
-	BOOLEAN			bAckRequired;
-	UCHAR			RetryMode = SHORT_RETRY;
-	UCHAR			UserPriority;
-	UCHAR			MpduRequired, RtsRequired;
-	UCHAR			TxRate;		
-	PCIPHER_KEY		pKey = NULL ;
-	PUCHAR			pSrcBufVA = NULL;
-	ULONG			SrcBufLen;
-	PUCHAR			pExtraLlcSnapEncap = NULL; // NULL: no extra LLC/SNAP is required
-	UCHAR			KeyIdx, KeyLength = 0;
-	UCHAR			KeyTable = SHARED_KEY_TABLE;
-	PUCHAR			pWirelessPacket;
-	ULONG			NextMpduSize;
-	BOOLEAN			bRTS_CTSFrame = FALSE;
-	unsigned long   IrqFlags; //BensonLiu modify
-
-	DBGPRINT(RT_DEBUG_INFO, "====> RTUSBHardTransmit\n");
-
-    if ((pAd->PortCfg.bIEEE80211H == 1) && (pAd->PortCfg.RadarDetect.RDMode != RD_NORMAL_MODE))
-    {
-        DBGPRINT(RT_DEBUG_INFO,"RTUSBHardTransmit --> radar detect not in normal mode !!!\n");
-        return (NDIS_STATUS_FAILURE);
-    }
-
-	TxRate		 = RTMP_GET_PACKET_TXRATE(pSkb);
-	MpduRequired = RTMP_GET_PACKET_FRAGMENTS(pSkb);
-	RtsRequired  = RTMP_GET_PACKET_RTS(pSkb);
-	UserPriority = RTMP_GET_PACKET_UP(pSkb);
-
-	
-	//
-	// Prepare packet information structure which will be query for buffer descriptor
-	//
-	pSrcBufVA = (PVOID)pSkb->data;
-	SrcBufLen = pSkb->len;
-
-	// Check for virtual address allocation, it might fail !!!
-	if (pSrcBufVA == NULL)
-	{
-		DBGPRINT_RAW(RT_DEBUG_TRACE, "pSrcBufVA == NULL\n");
-		return(NDIS_STATUS_RESOURCES);
-	}
-	if (SrcBufLen < 14)
-	{
-		DBGPRINT_RAW(RT_DEBUG_ERROR, "RTUSBHardTransmit --> Skb buffer error !!!\n");
-		return (NDIS_STATUS_FAILURE);
-	}
+  //	PURB			pUrb;
+  BOOLEAN			StartOfFrame;
+  BOOLEAN			bEAPOLFrame;
+  ULONG			Iv16;
+  ULONG			Iv32;
+  BOOLEAN			MICFrag;
+  //	PCIPHER_KEY		pWpaKey = NULL;
+  NDIS_802_11_WEP_STATUS	EncryptType = Ndis802_11EncryptionDisabled;
+  ULONG			TransferBufferLength;
+  USHORT			AckDuration = 0;
+  USHORT			EncryptionOverhead = 0;
+  UCHAR			CipherAlg;
+  BOOLEAN			bAckRequired;
+  UCHAR			RetryMode = SHORT_RETRY;
+  UCHAR			UserPriority;
+  UCHAR			MpduRequired, RtsRequired;
+  UCHAR			TxRate;		
+  PCIPHER_KEY		pKey = NULL ;
+  PUCHAR			pSrcBufVA = NULL;
+  ULONG			SrcBufLen;
+  PUCHAR			pExtraLlcSnapEncap = NULL; // NULL: no extra LLC/SNAP is required
+  UCHAR			KeyIdx, KeyLength = 0;
+  UCHAR			KeyTable = SHARED_KEY_TABLE;
+  PUCHAR			pWirelessPacket;
+  ULONG			NextMpduSize;
+  BOOLEAN			bRTS_CTSFrame = FALSE;
+  unsigned long   IrqFlags; //BensonLiu modify
+
+  DBGPRINT(RT_DEBUG_INFO, "====> RTUSBHardTransmit\n");
+
+  if ((pAd->PortCfg.bIEEE80211H == 1) && (pAd->PortCfg.RadarDetect.RDMode != RD_NORMAL_MODE))
+    {
+      DBGPRINT(RT_DEBUG_INFO,"RTUSBHardTransmit --> radar detect not in normal mode !!!\n");
+      return (NDIS_STATUS_FAILURE);
+    }
+
+  TxRate		 = RTMP_GET_PACKET_TXRATE(pSkb);
+  MpduRequired = RTMP_GET_PACKET_FRAGMENTS(pSkb);
+  RtsRequired  = RTMP_GET_PACKET_RTS(pSkb);
+  UserPriority = RTMP_GET_PACKET_UP(pSkb);
 
-	//
-	// If DHCP datagram or ARP datagram , we need to send it as Low rates.
-	//
-	if (pAd->PortCfg.Channel <= 14)
-	{
-		//
-		// Case 802.11 b/g
-		// basic channel means that we can use CCKM's low rate as RATE_1.
-		//		
-		if ((TxRate != RATE_1) && RTMPCheckDHCPFrame(pAd, pSkb))
-			TxRate = RATE_1;
-	}
-	else
-	{
-		//
-		// Case 802.11a
-		// We must used OFDM's low rate as RATE_6, note RATE_1 is not allow
-		// Only OFDM support on Channel > 14
-		//
-		if ((TxRate != RATE_6) && RTMPCheckDHCPFrame(pAd, pSkb))
-			TxRate = RATE_6;
-	}
 	
-	// ------------------------------------------
-	// STEP 0.1 Add 802.1x protocol check.
-	// ------------------------------------------
-	// For non-WPA network, 802.1x message should not encrypt even privacy is on.
-	if (NdisEqualMemory(EAPOL, pSrcBufVA + 12, 2))
-	{
-		bEAPOLFrame = TRUE;
-		if (pAd->PortCfg.MicErrCnt >= 2)
-			pAd->PortCfg.MicErrCnt++;
-	}
-	else
-		bEAPOLFrame = FALSE;
+  //
+  // Prepare packet information structure which will be query for buffer descriptor
+  //
+  pSrcBufVA = (PVOID)pSkb->data;
+  SrcBufLen = pSkb->len;
 
-	//
-	// WPA 802.1x secured port control - drop all non-802.1x frame before port secured
-	//
-	{
-		if (((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA)	 || 
-			 (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
-			 (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2)	 ||
-			 (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+  // Check for virtual address allocation, it might fail !!!
+  if (pSrcBufVA == NULL)
+    {
+      DBGPRINT_RAW(RT_DEBUG_TRACE, "pSrcBufVA == NULL\n");
+      return(NDIS_STATUS_RESOURCES);
+    }
+  if (SrcBufLen < 14)
+    {
+      DBGPRINT_RAW(RT_DEBUG_ERROR, "RTUSBHardTransmit --> Skb buffer error !!!\n");
+      return (NDIS_STATUS_FAILURE);
+    }
+
+  //
+  // If DHCP datagram or ARP datagram , we need to send it as Low rates.
+  //
+  if (pAd->PortCfg.Channel <= 14)
+    {
+      //
+      // Case 802.11 b/g
+      // basic channel means that we can use CCKM's low rate as RATE_1.
+      //		
+      if ((TxRate != RATE_1) && RTMPCheckDHCPFrame(pAd, pSkb))
+	TxRate = RATE_1;
+    }
+  else
+    {
+      //
+      // Case 802.11a
+      // We must used OFDM's low rate as RATE_6, note RATE_1 is not allow
+      // Only OFDM support on Channel > 14
+      //
+      if ((TxRate != RATE_6) && RTMPCheckDHCPFrame(pAd, pSkb))
+	TxRate = RATE_6;
+    }
+	
+  // ------------------------------------------
+  // STEP 0.1 Add 802.1x protocol check.
+  // ------------------------------------------
+  // For non-WPA network, 802.1x message should not encrypt even privacy is on.
+  if (NdisEqualMemory(EAPOL, pSrcBufVA + 12, 2))
+    {
+      bEAPOLFrame = TRUE;
+      if (pAd->PortCfg.MicErrCnt >= 2)
+	pAd->PortCfg.MicErrCnt++;
+    }
+  else
+    bEAPOLFrame = FALSE;
+
+  //
+  // WPA 802.1x secured port control - drop all non-802.1x frame before port secured
+  //
+  {
+    if (((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA)	 || 
+	 (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
+	 (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2)	 ||
+	 (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
 #if defined(RALINK_WPA_SUPPLICANT_SUPPORT) || defined(NATIVE_WPA_SUPPLICANT_SUPPORT)
-			  || (pAd->PortCfg.IEEE8021X == TRUE)		
+	 || (pAd->PortCfg.IEEE8021X == TRUE)		
 #endif 		         
-    	     ) &&
-			((pAd->PortCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED) || (pAd->PortCfg.MicErrCnt >= 2)) &&
-			(bEAPOLFrame == FALSE))
-		{
-			DBGPRINT_RAW(RT_DEBUG_INFO, "RTUSBHardTransmit --> Drop packet before port secured !!!\n");
-			return (NDIS_STATUS_FAILURE);
-		}
-	}
+	 ) &&
+	((pAd->PortCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED) || (pAd->PortCfg.MicErrCnt >= 2)) &&
+	(bEAPOLFrame == FALSE))
+      {
+	DBGPRINT_RAW(RT_DEBUG_INFO, "RTUSBHardTransmit --> Drop packet before port secured !!!\n");
+	return (NDIS_STATUS_FAILURE);
+      }
+  }
 
 
 
-	if (*pSrcBufVA & 0x01) // Multicast or Broadcast
-	{
-			bAckRequired = FALSE;
-			INC_COUNTER64(pAd->WlanCounters.MulticastTransmittedFrameCount);
-			EncryptType = pAd->PortCfg.GroupCipher; // Cipher for Multicast or Broadcast
-	}
-	else
-	{
-			bAckRequired = TRUE;
-			EncryptType = pAd->PortCfg.PairCipher; // Cipher for Unicast
-	}
+  if (*pSrcBufVA & 0x01) // Multicast or Broadcast
+    {
+      bAckRequired = FALSE;
+      INC_COUNTER64(pAd->WlanCounters.MulticastTransmittedFrameCount);
+      EncryptType = pAd->PortCfg.GroupCipher; // Cipher for Multicast or Broadcast
+    }
+  else
+    {
+      bAckRequired = TRUE;
+      EncryptType = pAd->PortCfg.PairCipher; // Cipher for Unicast
+    }
 
-	// 1. traditional TX burst
-	if (pAd->PortCfg.bEnableTxBurst && (pAd->Sequence & 0x7))
-		FrameGap = IFS_SIFS;  
-	// 2. frame belonging to AC that has non-zero TXOP
-	else if (pAd->PortCfg.APEdcaParm.bValid && pAd->PortCfg.APEdcaParm.Txop[QueIdx])
-		FrameGap = IFS_SIFS;
-	// 3. otherwise, always BACKOFF before transmission
-	else
-		FrameGap = IFS_BACKOFF;		// Default frame gap mode
+  // 1. traditional TX burst
+  if (pAd->PortCfg.bEnableTxBurst && (pAd->Sequence & 0x7))
+    FrameGap = IFS_SIFS;  
+  // 2. frame belonging to AC that has non-zero TXOP
+  else if (pAd->PortCfg.APEdcaParm.bValid && pAd->PortCfg.APEdcaParm.Txop[QueIdx])
+    FrameGap = IFS_SIFS;
+  // 3. otherwise, always BACKOFF before transmission
+  else
+    FrameGap = IFS_BACKOFF;		// Default frame gap mode
 
-	Protocol = *(pSrcBufVA + 12) * 256 + *(pSrcBufVA + 13);
-	// if orginal Ethernet frame contains no LLC/SNAP, then an extra LLC/SNAP encap is required 
+  Protocol = *(pSrcBufVA + 12) * 256 + *(pSrcBufVA + 13);
+  // if orginal Ethernet frame contains no LLC/SNAP, then an extra LLC/SNAP encap is required 
 
-	if (Protocol > 1500)
+  if (Protocol > 1500)
+    {
+      pExtraLlcSnapEncap = SNAP_802_1H;
+      if (NdisEqualMemory(IPX, pSrcBufVA + 12, 2) || 
+	  NdisEqualMemory(APPLE_TALK, pSrcBufVA + 12, 2))
 	{
-		pExtraLlcSnapEncap = SNAP_802_1H;
-		if (NdisEqualMemory(IPX, pSrcBufVA + 12, 2) || 
-			NdisEqualMemory(APPLE_TALK, pSrcBufVA + 12, 2))
-		{
-			pExtraLlcSnapEncap = SNAP_BRIDGE_TUNNEL;
-		}
+	  pExtraLlcSnapEncap = SNAP_BRIDGE_TUNNEL;
 	}
-	else
-		pExtraLlcSnapEncap = NULL;
+    }
+  else
+    pExtraLlcSnapEncap = NULL;
 
 
-    // Update software power save state
-	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
-	pAd->PortCfg.Psm = PWR_ACTIVE;
+  // Update software power save state
+  OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
+  pAd->PortCfg.Psm = PWR_ACTIVE;
 	
-	// -----------------------------------------------------------------
-	// STEP 2. MAKE A COMMON 802.11 HEADER SHARED BY ENTIRE FRAGMENT BURST.
-	// -----------------------------------------------------------------
+  // -----------------------------------------------------------------
+  // STEP 2. MAKE A COMMON 802.11 HEADER SHARED BY ENTIRE FRAGMENT BURST.
+  // -----------------------------------------------------------------
 
-	pAd->Sequence = ((pAd->Sequence) + 1) & (MAX_SEQ_NUMBER);
-	MAKE_802_11_HEADER(pAd, Header_802_11, pSrcBufVA, pAd->Sequence);
+  pAd->Sequence = ((pAd->Sequence) + 1) & (MAX_SEQ_NUMBER);
+  MAKE_802_11_HEADER(pAd, Header_802_11, pSrcBufVA, pAd->Sequence);
 
 
-	// --------------------------------------------------------
-	// STEP 3. FIND ENCRYPT KEY AND DECIDE CIPHER ALGORITHM
-	//		Find the WPA key, either Group or Pairwise Key
-	//		LEAP + TKIP also use WPA key.
-	// --------------------------------------------------------
-	// Decide WEP bit and cipher suite to be used. Same cipher suite should be used for whole fragment burst
-	// In Cisco CCX 2.0 Leap Authentication
-	//		   WepStatus is Ndis802_11Encryption1Enabled but the key will use PairwiseKey
-	//		   Instead of the SharedKey, SharedKey Length may be Zero.
-	KeyIdx = 0xff;
-	KeyTable = SHARED_KEY_TABLE;
+  // --------------------------------------------------------
+  // STEP 3. FIND ENCRYPT KEY AND DECIDE CIPHER ALGORITHM
+  //		Find the WPA key, either Group or Pairwise Key
+  //		LEAP + TKIP also use WPA key.
+  // --------------------------------------------------------
+  // Decide WEP bit and cipher suite to be used. Same cipher suite should be used for whole fragment burst
+  // In Cisco CCX 2.0 Leap Authentication
+  //		   WepStatus is Ndis802_11Encryption1Enabled but the key will use PairwiseKey
+  //		   Instead of the SharedKey, SharedKey Length may be Zero.
+  KeyIdx = 0xff;
+  KeyTable = SHARED_KEY_TABLE;
 
-	if (bEAPOLFrame)
-	{
-        ASSERT(pAd->SharedKey[0].CipherAlg <= CIPHER_CKIP128);
-        if ((pAd->SharedKey[0].CipherAlg) &&
-            (pAd->SharedKey[0].KeyLen)	&& 			
-            ((pAd->PortCfg.PortSecured == WPA_802_1X_PORT_PASS_4_WAY) || 
-			 (pAd->PortCfg.PortSecured == WPA_802_1X_PORT_SECURED)))
+  if (bEAPOLFrame)
+    {
+      ASSERT(pAd->SharedKey[0].CipherAlg <= CIPHER_CKIP128);
+      if ((pAd->SharedKey[0].CipherAlg) &&
+	  (pAd->SharedKey[0].KeyLen)	&& 			
+	  ((pAd->PortCfg.PortSecured == WPA_802_1X_PORT_PASS_4_WAY) || 
+	   (pAd->PortCfg.PortSecured == WPA_802_1X_PORT_SECURED)))
         {
-            CipherAlg = pAd->SharedKey[0].CipherAlg;
-            KeyIdx = 0;
-			KeyLength = pAd->SharedKey[KeyIdx].KeyLen;
+	  CipherAlg = pAd->SharedKey[0].CipherAlg;
+	  KeyIdx = 0;
+	  KeyLength = pAd->SharedKey[KeyIdx].KeyLen;
         }
     }
-	else if (EncryptType == Ndis802_11Encryption1Enabled)
-	{
-		// standard WEP64 or WEP128
-		KeyIdx = pAd->PortCfg.DefaultKeyId;
-		KeyLength = pAd->SharedKey[KeyIdx].KeyLen;	
-	}
-	else if ((EncryptType == Ndis802_11Encryption2Enabled) ||
-			 (EncryptType == Ndis802_11Encryption3Enabled))
-	{
-		if (Header_802_11.Addr1[0] & 0x01) // multicast
-			KeyIdx = pAd->PortCfg.DefaultKeyId;
-		else if (pAd->SharedKey[0].KeyLen)
-			KeyIdx = 0;
-		else
-			KeyIdx = pAd->PortCfg.DefaultKeyId;
-
-		KeyLength = pAd->SharedKey[KeyIdx].KeyLen;
-	}
+  else if (EncryptType == Ndis802_11Encryption1Enabled)
+    {
+      // standard WEP64 or WEP128
+      KeyIdx = pAd->PortCfg.DefaultKeyId;
+      KeyLength = pAd->SharedKey[KeyIdx].KeyLen;	
+    }
+  else if ((EncryptType == Ndis802_11Encryption2Enabled) ||
+	   (EncryptType == Ndis802_11Encryption3Enabled))
+    {
+      if (Header_802_11.Addr1[0] & 0x01) // multicast
+	KeyIdx = pAd->PortCfg.DefaultKeyId;
+      else if (pAd->SharedKey[0].KeyLen)
+	KeyIdx = 0;
+      else
+	KeyIdx = pAd->PortCfg.DefaultKeyId;
+
+      KeyLength = pAd->SharedKey[KeyIdx].KeyLen;
+    }
 
-	if (KeyIdx == 0xff)
-		CipherAlg = CIPHER_NONE;
-	else if ((EncryptType == Ndis802_11EncryptionDisabled) || (KeyLength == 0))
-		CipherAlg = CIPHER_NONE;
-	else
-	{
-		Header_802_11.FC.Wep = 1;
+  if (KeyIdx == 0xff)
+    CipherAlg = CIPHER_NONE;
+  else if ((EncryptType == Ndis802_11EncryptionDisabled) || (KeyLength == 0))
+    CipherAlg = CIPHER_NONE;
+  else
+    {
+      Header_802_11.FC.Wep = 1;
 
-		CipherAlg = pAd->SharedKey[KeyIdx].CipherAlg;
-		pKey = &pAd->SharedKey[KeyIdx];
+      CipherAlg = pAd->SharedKey[KeyIdx].CipherAlg;
+      pKey = &pAd->SharedKey[KeyIdx];
 	
-	}
+    }
 
 
-	DBGPRINT(RT_DEBUG_INFO,"RTUSBHardTransmit(bEAP=%d) - %s key#%d, KeyLen=%d\n", 
-		bEAPOLFrame, CipherName[CipherAlg], KeyIdx, pAd->SharedKey[KeyIdx].KeyLen);
+  DBGPRINT(RT_DEBUG_INFO,"RTUSBHardTransmit(bEAP=%d) - %s key#%d, KeyLen=%d\n", 
+	   bEAPOLFrame, CipherName[CipherAlg], KeyIdx, pAd->SharedKey[KeyIdx].KeyLen);
 
 
-	// STEP 3.1 if TKIP is used and fragmentation is required. Driver has to
-	//			append TKIP MIC at tail of the scatter buffer (This must be the
-	//			ONLY scatter buffer in the skb buffer). 
-	//			MAC ASIC will only perform IV/EIV/ICV insertion but no TKIP MIC
-	if ((MpduRequired > 1) && (CipherAlg == CIPHER_TKIP))
-	{
-		pSkb->len += 8;
-		CipherAlg = CIPHER_TKIP_NO_MIC;	
-	}
+  // STEP 3.1 if TKIP is used and fragmentation is required. Driver has to
+  //			append TKIP MIC at tail of the scatter buffer (This must be the
+  //			ONLY scatter buffer in the skb buffer). 
+  //			MAC ASIC will only perform IV/EIV/ICV insertion but no TKIP MIC
+  if ((MpduRequired > 1) && (CipherAlg == CIPHER_TKIP))
+    {
+      pSkb->len += 8;
+      CipherAlg = CIPHER_TKIP_NO_MIC;	
+    }
 
-	// ----------------------------------------------------------------
-	// STEP 4. Make RTS frame or CTS-to-self frame if required
-	// ----------------------------------------------------------------
-
-	//
-	// calcuate the overhead bytes that encryption algorithm may add. This
-	// affects the calculate of "duration" field
-	//
-	if ((CipherAlg == CIPHER_WEP64) || (CipherAlg == CIPHER_WEP128)) 
-		EncryptionOverhead = 8; //WEP: IV[4] + ICV[4];
-	else if (CipherAlg == CIPHER_TKIP_NO_MIC)
-		EncryptionOverhead = 12;//TKIP: IV[4] + EIV[4] + ICV[4], MIC will be added to TotalPacketLength
-	else if (CipherAlg == CIPHER_TKIP)
-		EncryptionOverhead = 20;//TKIP: IV[4] + EIV[4] + ICV[4] + MIC[8]
-	else if (CipherAlg == CIPHER_AES)
-		EncryptionOverhead = 16;	// AES: IV[4] + EIV[4] + MIC[8]
-	else
-		EncryptionOverhead = 0;
-
-	// decide how much time an ACK/CTS frame will consume in the air
-	AckDuration = RTMPCalcDuration(pAd, pAd->PortCfg.ExpectedACKRate[TxRate], 14);
-
-	// If fragment required, MPDU size is maximum fragment size
-	// Else, MPDU size should be frame with 802.11 header & CRC
-	if (MpduRequired > 1)
-		NextMpduSize = pAd->PortCfg.FragmentThreshold;
-	else
-	{
-		NextMpduSize = pSkb->len + LENGTH_802_11 + LENGTH_CRC - LENGTH_802_3;
-		if (pExtraLlcSnapEncap)
-			NextMpduSize += LENGTH_802_1_H;
-	}
+  // ----------------------------------------------------------------
+  // STEP 4. Make RTS frame or CTS-to-self frame if required
+  // ----------------------------------------------------------------
+
+  //
+  // calcuate the overhead bytes that encryption algorithm may add. This
+  // affects the calculate of "duration" field
+  //
+  if ((CipherAlg == CIPHER_WEP64) || (CipherAlg == CIPHER_WEP128)) 
+    EncryptionOverhead = 8; //WEP: IV[4] + ICV[4];
+  else if (CipherAlg == CIPHER_TKIP_NO_MIC)
+    EncryptionOverhead = 12;//TKIP: IV[4] + EIV[4] + ICV[4], MIC will be added to TotalPacketLength
+  else if (CipherAlg == CIPHER_TKIP)
+    EncryptionOverhead = 20;//TKIP: IV[4] + EIV[4] + ICV[4] + MIC[8]
+  else if (CipherAlg == CIPHER_AES)
+    EncryptionOverhead = 16;	// AES: IV[4] + EIV[4] + MIC[8]
+  else
+    EncryptionOverhead = 0;
+
+  // decide how much time an ACK/CTS frame will consume in the air
+  AckDuration = RTMPCalcDuration(pAd, pAd->PortCfg.ExpectedACKRate[TxRate], 14);
+
+  // If fragment required, MPDU size is maximum fragment size
+  // Else, MPDU size should be frame with 802.11 header & CRC
+  if (MpduRequired > 1)
+    NextMpduSize = pAd->PortCfg.FragmentThreshold;
+  else
+    {
+      NextMpduSize = pSkb->len + LENGTH_802_11 + LENGTH_CRC - LENGTH_802_3;
+      if (pExtraLlcSnapEncap)
+	NextMpduSize += LENGTH_802_1_H;
+    }
 
-	if (RtsRequired || OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_RTS_PROTECTION_ENABLE))
-	{
-		RTMPSendRTSCTSFrame(pAd, 
-							Header_802_11.Addr1, 
-							NextMpduSize + EncryptionOverhead, 
-							TxRate,
-							pAd->PortCfg.RtsRate, 
-							AckDuration,
-							QueIdx,
-							FrameGap,
-							SUBTYPE_RTS);
-		
-		// RTS/CTS-protected frame should use LONG_RETRY (=4) and SIFS
-		RetryMode = LONG_RETRY;
-		FrameGap = IFS_SIFS;
-		bRTS_CTSFrame = TRUE;
-		
-		if (RtsRequired)
-			NumberRequired--;
-	}
-	else if ((pAd->PortCfg.TxRate >= RATE_FIRST_OFDM_RATE) && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_BG_PROTECTION_INUSED))
-	{
-		RTMPSendRTSCTSFrame(pAd, 
-							Header_802_11.Addr1, 
-							NextMpduSize + EncryptionOverhead, 
-							TxRate,
-							pAd->PortCfg.RtsRate, 
-							AckDuration,
-							QueIdx,
-							FrameGap,
-							SUBTYPE_CTS);
-		
-		// RTS/CTS-protected frame should use LONG_RETRY (=4) and SIFS
-		RetryMode = LONG_RETRY;
-		FrameGap = IFS_SIFS;
-		bRTS_CTSFrame = TRUE;
-	}
+  if (RtsRequired || OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_RTS_PROTECTION_ENABLE))
+    {
+      RTMPSendRTSCTSFrame(pAd, 
+			  Header_802_11.Addr1, 
+			  NextMpduSize + EncryptionOverhead, 
+			  TxRate,
+			  pAd->PortCfg.RtsRate, 
+			  AckDuration,
+			  QueIdx,
+			  FrameGap,
+			  SUBTYPE_RTS);
+		
+      // RTS/CTS-protected frame should use LONG_RETRY (=4) and SIFS
+      RetryMode = LONG_RETRY;
+      FrameGap = IFS_SIFS;
+      bRTS_CTSFrame = TRUE;
+		
+      if (RtsRequired)
+	NumberRequired--;
+    }
+  else if ((pAd->PortCfg.TxRate >= RATE_FIRST_OFDM_RATE) && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_BG_PROTECTION_INUSED))
+    {
+      RTMPSendRTSCTSFrame(pAd, 
+			  Header_802_11.Addr1, 
+			  NextMpduSize + EncryptionOverhead, 
+			  TxRate,
+			  pAd->PortCfg.RtsRate, 
+			  AckDuration,
+			  QueIdx,
+			  FrameGap,
+			  SUBTYPE_CTS);
+		
+      // RTS/CTS-protected frame should use LONG_RETRY (=4) and SIFS
+      RetryMode = LONG_RETRY;
+      FrameGap = IFS_SIFS;
+      bRTS_CTSFrame = TRUE;
+    }
 
-	// --------------------------------------------------------
-	// STEP 5. START MAKING MPDU(s)
-	//		Start Copy Ndis Packet into Ring buffer.
-	//		For frame required more than one ring buffer (fragment), all ring buffers
-	//		have to be filled before kicking start tx bit.
-	//		Make sure TX ring resource won't be used by other threads
-	// --------------------------------------------------------
-	SrcRemainingBytes = pSkb->len - LENGTH_802_3;
-	SrcBufLen		 -= LENGTH_802_3;  // skip 802.3 header
-
-	StartOfFrame = TRUE;
-	MICFrag = FALSE;	// Flag to indicate MIC shall spread into two MPDUs
-
-	NdisAcquireSpinLock(&pAd->TxRingLock, IrqFlags);//BensonLiu modify
-	
-	// Start Copy Ndis Packet into Ring buffer.
-	// For frame required more than one ring buffer (fragment), all ring buffers
-	// have to be filled before kicking start tx bit.
-	do
-	{
-		//
-		// STEP 5.1 Get the Tx Ring descriptor & Dma Buffer address
-		//
-		pTxContext	= &pAd->TxContext[QueIdx][pAd->NextTxIndex[QueIdx]];
+  // --------------------------------------------------------
+  // STEP 5. START MAKING MPDU(s)
+  //		Start Copy Ndis Packet into Ring buffer.
+  //		For frame required more than one ring buffer (fragment), all ring buffers
+  //		have to be filled before kicking start tx bit.
+  //		Make sure TX ring resource won't be used by other threads
+  // --------------------------------------------------------
+  SrcRemainingBytes = pSkb->len - LENGTH_802_3;
+  SrcBufLen		 -= LENGTH_802_3;  // skip 802.3 header
+
+  StartOfFrame = TRUE;
+  MICFrag = FALSE;	// Flag to indicate MIC shall spread into two MPDUs
+
+  NdisAcquireSpinLock(&pAd->TxRingLock, IrqFlags);//BensonLiu modify
+	
+  // Start Copy Ndis Packet into Ring buffer.
+  // For frame required more than one ring buffer (fragment), all ring buffers
+  // have to be filled before kicking start tx bit.
+  do
+    {
+      //
+      // STEP 5.1 Get the Tx Ring descriptor & Dma Buffer address
+      //
+      pTxContext	= &pAd->TxContext[QueIdx][pAd->NextTxIndex[QueIdx]];
+		
+      if ((pTxContext->bWaitingBulkOut == TRUE) || (pTxContext->InUse == TRUE) ||
+	  (pAd->TxRingTotalNumber[QueIdx] >= TX_RING_SIZE))
+	{
+	  DBGPRINT_ERR("RTUSBHardTransmit: TX RING full\n");
+	  pAd->RalinkCounters.TxRingErrCount++;
+	  NdisReleaseSpinLock(&pAd->TxRingLock, IrqFlags);//BensonLiu modify
+	  return (NDIS_STATUS_RESOURCES);
+	}		
+      pTxContext->InUse	= TRUE;		
 		
-		if ((pTxContext->bWaitingBulkOut == TRUE) || (pTxContext->InUse == TRUE) ||
-			(pAd->TxRingTotalNumber[QueIdx] >= TX_RING_SIZE))
-		{
-			DBGPRINT_ERR("RTUSBHardTransmit: TX RING full\n");
-			pAd->RalinkCounters.TxRingErrCount++;
-			NdisReleaseSpinLock(&pAd->TxRingLock, IrqFlags);//BensonLiu modify
-			return (NDIS_STATUS_RESOURCES);
-		}		
-		pTxContext->InUse	= TRUE;		
-		
-		// Increase & maintain Tx Ring Index
-		pAd->NextTxIndex[QueIdx]++;
-		if (pAd->NextTxIndex[QueIdx] >= TX_RING_SIZE)
-		{
-			pAd->NextTxIndex[QueIdx] = 0;
-		}
+      // Increase & maintain Tx Ring Index
+      pAd->NextTxIndex[QueIdx]++;
+      if (pAd->NextTxIndex[QueIdx] >= TX_RING_SIZE)
+	{
+	  pAd->NextTxIndex[QueIdx] = 0;
+	}
 
 #ifndef BIG_ENDIAN
-		pTxD  = (PTXD_STRUC) &pTxContext->TransferBuffer->TxDesc;
+      pTxD  = (PTXD_STRUC) &pTxContext->TransferBuffer->TxDesc;
 #else
-		pDestTxD = (PTXD_STRUC) &pTxContext->TransferBuffer->TxDesc;
-		TxD = *pDestTxD;
-		pTxD = &TxD;
-		RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+      pDestTxD = (PTXD_STRUC) &pTxContext->TransferBuffer->TxDesc;
+      TxD = *pDestTxD;
+      pTxD = &TxD;
+      RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
 #endif			
-		NdisZeroMemory(pTxD, sizeof(TXD_STRUC));
-		pWirelessPacket = pTxContext->TransferBuffer->u.WirelessPacket;
+      NdisZeroMemory(pTxD, sizeof(TXD_STRUC));
+      pWirelessPacket = pTxContext->TransferBuffer->u.WirelessPacket;
 
-		//
-		// STEP 5.2 PUT IVOFFSET, IV, EIV INTO TXD
-		//
+      //
+      // STEP 5.2 PUT IVOFFSET, IV, EIV INTO TXD
+      //
 	
-		pTxD->IvOffset	= LENGTH_802_11;
+      pTxD->IvOffset	= LENGTH_802_11;
 
 #if 0
-		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED))
-			pTxD->IvOffset += 2;  // add QOS CONTROL bytes
+      if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED))
+	pTxD->IvOffset += 2;  // add QOS CONTROL bytes
 #endif
 	
-		if ((CipherAlg == CIPHER_WEP64) || (CipherAlg == CIPHER_WEP128))
-		{
-			PUCHAR pTmp;
-			pTmp = (PUCHAR) &pTxD->Iv;
-			*pTmp		= RandomByte(pAd);
-			*(pTmp + 1) = RandomByte(pAd);
-			*(pTmp + 2) = RandomByte(pAd);
-			*(pTmp + 3) = (KeyIdx << 6);
-		}
-		else if ((CipherAlg == CIPHER_TKIP) || (CipherAlg == CIPHER_TKIP_NO_MIC))
-		{
-			UCHAR	kidx;			
+      if ((CipherAlg == CIPHER_WEP64) || (CipherAlg == CIPHER_WEP128))
+	{
+	  PUCHAR pTmp;
+	  pTmp = (PUCHAR) &pTxD->Iv;
+	  *pTmp		= RandomByte(pAd);
+	  *(pTmp + 1) = RandomByte(pAd);
+	  *(pTmp + 2) = RandomByte(pAd);
+	  *(pTmp + 3) = (KeyIdx << 6);
+	}
+      else if ((CipherAlg == CIPHER_TKIP) || (CipherAlg == CIPHER_TKIP_NO_MIC))
+	{
+	  UCHAR	kidx;			
 
-				kidx = KeyIdx;
+	  kidx = KeyIdx;
 					
-			RTMPInitTkipEngine(
-				pAd,
-				pKey->Key,
-				kidx,			//KeyIdx,		// This might cause problem when using peer key
-				Header_802_11.Addr2,
-				pKey->TxMic,
-				pKey->TxTsc,
-				&Iv16,
-				&Iv32);
+	  RTMPInitTkipEngine(
+			     pAd,
+			     pKey->Key,
+			     kidx,			//KeyIdx,		// This might cause problem when using peer key
+			     Header_802_11.Addr2,
+			     pKey->TxMic,
+			     pKey->TxTsc,
+			     &Iv16,
+			     &Iv32);
 			
-			NdisMoveMemory(&pTxD->Iv, &Iv16, 4);   // Copy IV
-			NdisMoveMemory(&pTxD->Eiv, &Iv32, 4);  // Copy EIV
-			INC_TX_TSC(pKey->TxTsc);			   // Increase TxTsc for next transmission
-		}
-		else if (CipherAlg == CIPHER_AES)
-		{
-			PUCHAR	pTmp;
-			UCHAR	kidx;			
+	  NdisMoveMemory(&pTxD->Iv, &Iv16, 4);   // Copy IV
+	  NdisMoveMemory(&pTxD->Eiv, &Iv32, 4);  // Copy EIV
+	  INC_TX_TSC(pKey->TxTsc);			   // Increase TxTsc for next transmission
+	}
+      else if (CipherAlg == CIPHER_AES)
+	{
+	  PUCHAR	pTmp;
+	  UCHAR	kidx;			
 
-				kidx = KeyIdx;
+	  kidx = KeyIdx;
 
-			pTmp = (PUCHAR) &Iv16;
-			*pTmp		= pKey->TxTsc[0];
-			*(pTmp + 1) = pKey->TxTsc[1];
-			*(pTmp + 2) = 0;
-			*(pTmp + 3) = (/*pAd->PortCfg.DefaultKeyId*/kidx << 6) | 0x20;
-			Iv32 = *(PULONG)(&pKey->TxTsc[2]);
+	  pTmp = (PUCHAR) &Iv16;
+	  *pTmp		= pKey->TxTsc[0];
+	  *(pTmp + 1) = pKey->TxTsc[1];
+	  *(pTmp + 2) = 0;
+	  *(pTmp + 3) = (/*pAd->PortCfg.DefaultKeyId*/kidx << 6) | 0x20;
+	  Iv32 = *(PULONG)(&pKey->TxTsc[2]);
 			
-			NdisMoveMemory(&pTxD->Iv, &Iv16, 4);	// Copy IV
-			NdisMoveMemory(&pTxD->Eiv, &Iv32, 4);	// Copy EIV
-			INC_TX_TSC(pKey->TxTsc);				// Increase TxTsc for next transmission
-		}
+	  NdisMoveMemory(&pTxD->Iv, &Iv16, 4);	// Copy IV
+	  NdisMoveMemory(&pTxD->Eiv, &Iv32, 4);	// Copy EIV
+	  INC_TX_TSC(pKey->TxTsc);				// Increase TxTsc for next transmission
+	}
 
 
 
 
 
 
-		//
-		// STEP 5.3 COPY 802.11 HEADER INTO 1ST DMA BUFFER
-		//
-		pDest = pWirelessPacket;
-		NdisMoveMemory(pDest, &Header_802_11, sizeof(Header_802_11));
-		pDest		+= sizeof(Header_802_11);
+      //
+      // STEP 5.3 COPY 802.11 HEADER INTO 1ST DMA BUFFER
+      //
+      pDest = pWirelessPacket;
+      NdisMoveMemory(pDest, &Header_802_11, sizeof(Header_802_11));
+      pDest		+= sizeof(Header_802_11);
 
-		//
-		// Fragmentation is not allowed on multicast & broadcast
-		// So, we need to used the MAX_FRAG_THRESHOLD instead of pAd->PortCfg.FragmentThreshold
-		// otherwise if pSkb->len > pAd->PortCfg.FragmentThreshold then
-		// packet will be fragment on multicast & broadcast.
-		//
-		// MpduRequired equals to 1 means this could be Aggretaion case.
-		//
-		if ((Header_802_11.Addr1[0] & 0x01) || MpduRequired == 1)
-		{
-			FreeMpduSize = MAX_FRAG_THRESHOLD - sizeof(Header_802_11) - LENGTH_CRC;
-		}
-		else
-		{
-			FreeMpduSize = pAd->PortCfg.FragmentThreshold - sizeof(Header_802_11) - LENGTH_CRC;
-		}
+      //
+      // Fragmentation is not allowed on multicast & broadcast
+      // So, we need to used the MAX_FRAG_THRESHOLD instead of pAd->PortCfg.FragmentThreshold
+      // otherwise if pSkb->len > pAd->PortCfg.FragmentThreshold then
+      // packet will be fragment on multicast & broadcast.
+      //
+      // MpduRequired equals to 1 means this could be Aggretaion case.
+      //
+      if ((Header_802_11.Addr1[0] & 0x01) || MpduRequired == 1)
+	{
+	  FreeMpduSize = MAX_FRAG_THRESHOLD - sizeof(Header_802_11) - LENGTH_CRC;
+	}
+      else
+	{
+	  FreeMpduSize = pAd->PortCfg.FragmentThreshold - sizeof(Header_802_11) - LENGTH_CRC;
+	}
 
 
-		//
-		// STEP 5.4 COPY LLC/SNAP, CKIP MIC INTO 1ST DMA BUFFER ONLY WHEN THIS 
-		//			MPDU IS THE 1ST OR ONLY FRAGMENT 
-		//
-		if (Header_802_11.Frag == 0)
+      //
+      // STEP 5.4 COPY LLC/SNAP, CKIP MIC INTO 1ST DMA BUFFER ONLY WHEN THIS 
+      //			MPDU IS THE 1ST OR ONLY FRAGMENT 
+      //
+      if (Header_802_11.Frag == 0)
+	{
+	  if (pExtraLlcSnapEncap)
+	    {
+	      if ((CipherAlg == CIPHER_TKIP_NO_MIC) && (pKey != NULL))
 		{
-			if (pExtraLlcSnapEncap)
-			{
-				if ((CipherAlg == CIPHER_TKIP_NO_MIC) && (pKey != NULL))
-				{
-					// Calculate MSDU MIC Value
-					RTMPCalculateMICValue(pAd, pSkb, pExtraLlcSnapEncap, pKey);
-				}
+		  // Calculate MSDU MIC Value
+		  RTMPCalculateMICValue(pAd, pSkb, pExtraLlcSnapEncap, pKey);
+		}
 				
-				// Insert LLC-SNAP encapsulation
-				NdisMoveMemory(pDest, pExtraLlcSnapEncap, 6);
-				pDest += 6;
-				NdisMoveMemory(pDest, pSrcBufVA + 12, 2);
-				pDest += 2;
-				pSrcBufVA += LENGTH_802_3;
-				FreeMpduSize -= LENGTH_802_1_H;
+	      // Insert LLC-SNAP encapsulation
+	      NdisMoveMemory(pDest, pExtraLlcSnapEncap, 6);
+	      pDest += 6;
+	      NdisMoveMemory(pDest, pSrcBufVA + 12, 2);
+	      pDest += 2;
+	      pSrcBufVA += LENGTH_802_3;
+	      FreeMpduSize -= LENGTH_802_1_H;
 			
-			}
-			else
-			{
-				if ((CipherAlg == CIPHER_TKIP_NO_MIC) && (pKey != NULL))
-				{
-					// Calculate MSDU MIC Value
-					RTMPCalculateMICValue(pAd, pSkb, pExtraLlcSnapEncap, pKey);
-				}
-				pSrcBufVA += LENGTH_802_3;
-			}
+	    }
+	  else
+	    {
+	      if ((CipherAlg == CIPHER_TKIP_NO_MIC) && (pKey != NULL))
+		{
+		  // Calculate MSDU MIC Value
+		  RTMPCalculateMICValue(pAd, pSkb, pExtraLlcSnapEncap, pKey);
 		}
+	      pSrcBufVA += LENGTH_802_3;
+	    }
+	}
 
 
-		// Start copying payload
-		BytesCopied = 0;
-		do
-		{
-			if (SrcBufLen >= FreeMpduSize)
-			{
-				// Copy only the free fragment size, and save the pointer
-				// of current buffer descriptor for next fragment buffer.
-				NdisMoveMemory(pDest, pSrcBufVA, FreeMpduSize);
-				BytesCopied += FreeMpduSize;
-				pSrcBufVA	+= FreeMpduSize;
-				pDest		+= FreeMpduSize;
-				SrcBufLen	-= FreeMpduSize;
-				break;
-			}
-			else
-			{
-				// Copy the rest of this buffer descriptor pointed data
-				// into ring buffer.
-				NdisMoveMemory(pDest, pSrcBufVA, SrcBufLen);
-				BytesCopied  += SrcBufLen;
-				pDest		 += SrcBufLen;
-				FreeMpduSize -= SrcBufLen;
-			}
+      // Start copying payload
+      BytesCopied = 0;
+      do
+	{
+	  if (SrcBufLen >= FreeMpduSize)
+	    {
+	      // Copy only the free fragment size, and save the pointer
+	      // of current buffer descriptor for next fragment buffer.
+	      NdisMoveMemory(pDest, pSrcBufVA, FreeMpduSize);
+	      BytesCopied += FreeMpduSize;
+	      pSrcBufVA	+= FreeMpduSize;
+	      pDest		+= FreeMpduSize;
+	      SrcBufLen	-= FreeMpduSize;
+	      break;
+	    }
+	  else
+	    {
+	      // Copy the rest of this buffer descriptor pointed data
+	      // into ring buffer.
+	      NdisMoveMemory(pDest, pSrcBufVA, SrcBufLen);
+	      BytesCopied  += SrcBufLen;
+	      pDest		 += SrcBufLen;
+	      FreeMpduSize -= SrcBufLen;
+	    }
 			
-			// No more buffer descriptor
-			// Add MIC value if needed
+	  // No more buffer descriptor
+	  // Add MIC value if needed
 
-			//if ((pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) && 
-			//	(MICFrag == FALSE) &&
-			//	(pKey != NULL))
+	  //if ((pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) && 
+	  //	(MICFrag == FALSE) &&
+	  //	(pKey != NULL))
 
-			if((CipherAlg == CIPHER_TKIP_NO_MIC) &&
-			   (MICFrag == FALSE) &&
-				(pKey != NULL))
-			{
-				// Fregment and TKIP//
-				INT i;
+	  if((CipherAlg == CIPHER_TKIP_NO_MIC) &&
+	     (MICFrag == FALSE) &&
+	     (pKey != NULL))
+	    {
+	      // Fregment and TKIP//
+	      INT i;
 
-				SrcBufLen = 8;		// Set length to MIC length
-				DBGPRINT_RAW(RT_DEBUG_INFO, "Calculated TX MIC value =");  
-				for (i = 0; i < 8; i++)
-				{
-					DBGPRINT_RAW(RT_DEBUG_INFO, "%02x:", pAd->PrivateInfo.Tx.MIC[i]);  
-				}
-					DBGPRINT_RAW(RT_DEBUG_INFO, "\n"); 
-								
-				if (FreeMpduSize >= SrcBufLen)
-				{
-					NdisMoveMemory(pDest, pAd->PrivateInfo.Tx.MIC, SrcBufLen);
-					BytesCopied  += SrcBufLen;
-					pDest		 += SrcBufLen;
-					FreeMpduSize -= SrcBufLen;
-					SrcBufLen = 0;
-				}
-				else
-				{
-					NdisMoveMemory(pDest, pAd->PrivateInfo.Tx.MIC, FreeMpduSize);
-					BytesCopied  += FreeMpduSize;
-					pSrcBufVA	  = pAd->PrivateInfo.Tx.MIC + FreeMpduSize;
-					pDest		 += FreeMpduSize;
-					SrcBufLen	 -= FreeMpduSize;
-					MICFrag 	  = TRUE;
-				}						
-			}
-		}	while (FALSE); // End of copying payload   
-				
-		// Real packet size, No 802.1H header for fragments except the first one.
-		if ((StartOfFrame == TRUE) && (pExtraLlcSnapEncap != NULL))
-		{
-			TxSize = BytesCopied + LENGTH_802_11 + LENGTH_802_1_H + LengthQosPAD;
-		}
-		else
+	      SrcBufLen = 8;		// Set length to MIC length
+	      DBGPRINT_RAW(RT_DEBUG_INFO, "Calculated TX MIC value =");  
+	      for (i = 0; i < 8; i++)
 		{
-			TxSize = BytesCopied + LENGTH_802_11 + LengthQosPAD;
+		  DBGPRINT_RAW(RT_DEBUG_INFO, "%02x:", pAd->PrivateInfo.Tx.MIC[i]);  
 		}
+	      DBGPRINT_RAW(RT_DEBUG_INFO, "\n"); 
+								
+	      if (FreeMpduSize >= SrcBufLen)
+		{
+		  NdisMoveMemory(pDest, pAd->PrivateInfo.Tx.MIC, SrcBufLen);
+		  BytesCopied  += SrcBufLen;
+		  pDest		 += SrcBufLen;
+		  FreeMpduSize -= SrcBufLen;
+		  SrcBufLen = 0;
+		}
+	      else
+		{
+		  NdisMoveMemory(pDest, pAd->PrivateInfo.Tx.MIC, FreeMpduSize);
+		  BytesCopied  += FreeMpduSize;
+		  pSrcBufVA	  = pAd->PrivateInfo.Tx.MIC + FreeMpduSize;
+		  pDest		 += FreeMpduSize;
+		  SrcBufLen	 -= FreeMpduSize;
+		  MICFrag 	  = TRUE;
+		}						
+	    }
+	}	while (FALSE); // End of copying payload   
+				
+      // Real packet size, No 802.1H header for fragments except the first one.
+      if ((StartOfFrame == TRUE) && (pExtraLlcSnapEncap != NULL))
+	{
+	  TxSize = BytesCopied + LENGTH_802_11 + LENGTH_802_1_H + LengthQosPAD;
+	}
+      else
+	{
+	  TxSize = BytesCopied + LENGTH_802_11 + LengthQosPAD;
+	}
 
-		SrcRemainingBytes -=  BytesCopied;
+      SrcRemainingBytes -=  BytesCopied;
 
 	
-		//
-		// STEP 5.6 MODIFY MORE_FRAGMENT BIT & DURATION FIELD. WRITE TXD
-		//
-		pHeader80211 = (PHEADER_802_11)pWirelessPacket;
-		if (SrcRemainingBytes > 0) // more fragment is required
-		{
-			 ULONG NextMpduSize;
-
-			 pHeader80211->FC.MoreFrag = 1;
-			 NextMpduSize = min((ULONG)SrcRemainingBytes, (ULONG)pAd->PortCfg.FragmentThreshold);
-
-			 if (NextMpduSize < pAd->PortCfg.FragmentThreshold)
-			 {
-				// In this case, we need to include LENGTH_802_11 and LENGTH_CRC for calculating Duration.
-				pHeader80211->Duration = (3 * pAd->PortCfg.Dsifs) + 
-									(2 * AckDuration) + 
-									RTMPCalcDuration(pAd, TxRate, NextMpduSize + EncryptionOverhead + LENGTH_802_11 + LENGTH_CRC);
-			 }
-			 else
-			 {
-				pHeader80211->Duration = (3 * pAd->PortCfg.Dsifs) + 
-								(2 * AckDuration) + 
-								RTMPCalcDuration(pAd, TxRate, NextMpduSize + EncryptionOverhead);
-			 }
+      //
+      // STEP 5.6 MODIFY MORE_FRAGMENT BIT & DURATION FIELD. WRITE TXD
+      //
+      pHeader80211 = (PHEADER_802_11)pWirelessPacket;
+      if (SrcRemainingBytes > 0) // more fragment is required
+	{
+	  ULONG NextMpduSize;
+
+	  pHeader80211->FC.MoreFrag = 1;
+	  NextMpduSize = min((ULONG)SrcRemainingBytes, (ULONG)pAd->PortCfg.FragmentThreshold);
+
+	  if (NextMpduSize < pAd->PortCfg.FragmentThreshold)
+	    {
+	      // In this case, we need to include LENGTH_802_11 and LENGTH_CRC for calculating Duration.
+	      pHeader80211->Duration = (3 * pAd->PortCfg.Dsifs) + 
+		(2 * AckDuration) + 
+		RTMPCalcDuration(pAd, TxRate, NextMpduSize + EncryptionOverhead + LENGTH_802_11 + LENGTH_CRC);
+	    }
+	  else
+	    {
+	      pHeader80211->Duration = (3 * pAd->PortCfg.Dsifs) + 
+		(2 * AckDuration) + 
+		RTMPCalcDuration(pAd, TxRate, NextMpduSize + EncryptionOverhead);
+	    }
 			 
 #ifdef BIG_ENDIAN
-			RTMPFrameEndianChange(pAd, (PUCHAR)pHeader80211, DIR_WRITE, FALSE);
-			RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
-			*pDestTxD = TxD;
-			pTxD = pDestTxD;
+	  RTMPFrameEndianChange(pAd, (PUCHAR)pHeader80211, DIR_WRITE, FALSE);
+	  RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+	  *pDestTxD = TxD;
+	  pTxD = pDestTxD;
 #endif
-			RTUSBWriteTxDescriptor(pAd, pTxD, CipherAlg, KeyTable/*0*/, KeyIdx, bAckRequired, TRUE, FALSE, 
-					RetryMode, FrameGap, TxRate, TxSize, QueIdx, 0, bRTS_CTSFrame);
+	  RTUSBWriteTxDescriptor(pAd, pTxD, CipherAlg, KeyTable/*0*/, KeyIdx, bAckRequired, TRUE, FALSE, 
+				 RetryMode, FrameGap, TxRate, TxSize, QueIdx, 0, bRTS_CTSFrame);
 
-			FrameGap = IFS_SIFS;	 // use SIFS for all subsequent fragments
-			Header_802_11.Frag ++;	 // increase Frag #
-		}
-		else
-		{
-			pHeader80211->FC.MoreFrag = 0;
-			if (pHeader80211->Addr1[0] & 0x01) // multicast/broadcast
-				pHeader80211->Duration = 0;
-			else
-				pHeader80211->Duration = pAd->PortCfg.Dsifs + AckDuration;
-
-			if ((bEAPOLFrame) && (TxRate > RATE_6))
-				TxRate = RATE_6;
+	  FrameGap = IFS_SIFS;	 // use SIFS for all subsequent fragments
+	  Header_802_11.Frag ++;	 // increase Frag #
+	}
+      else
+	{
+	  pHeader80211->FC.MoreFrag = 0;
+	  if (pHeader80211->Addr1[0] & 0x01) // multicast/broadcast
+	    pHeader80211->Duration = 0;
+	  else
+	    pHeader80211->Duration = pAd->PortCfg.Dsifs + AckDuration;
+
+	  if ((bEAPOLFrame) && (TxRate > RATE_6))
+	    TxRate = RATE_6;
 				
 #ifdef BIG_ENDIAN
-			RTMPFrameEndianChange(pAd, (PUCHAR)pHeader80211, DIR_WRITE, FALSE);
-			RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
-			*pDestTxD = TxD;
-			pTxD = pDestTxD;
+	  RTMPFrameEndianChange(pAd, (PUCHAR)pHeader80211, DIR_WRITE, FALSE);
+	  RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+	  *pDestTxD = TxD;
+	  pTxD = pDestTxD;
 #endif
-			RTUSBWriteTxDescriptor(pAd, pTxD, CipherAlg, KeyTable/*0*/, KeyIdx, bAckRequired, FALSE, FALSE, 
-					RetryMode, FrameGap, TxRate, TxSize, QueIdx, 0, bRTS_CTSFrame);
+	  RTUSBWriteTxDescriptor(pAd, pTxD, CipherAlg, KeyTable/*0*/, KeyIdx, bAckRequired, FALSE, FALSE, 
+				 RetryMode, FrameGap, TxRate, TxSize, QueIdx, 0, bRTS_CTSFrame);
 
-			if (pAd->SendTxWaitQueue[QueIdx].Number > 1)
-				pTxD->Burst = 1;
+	  if (pAd->SendTxWaitQueue[QueIdx].Number > 1)
+	    pTxD->Burst = 1;
 
-		}
+	}
 
-		TransferBufferLength = TxSize + sizeof(TXD_STRUC);
+      TransferBufferLength = TxSize + sizeof(TXD_STRUC);
 
-		if ((TransferBufferLength % 4) == 1)	
-			TransferBufferLength  += 3;
-		else if ((TransferBufferLength % 4) == 2)	
-			TransferBufferLength  += 2;
-		else if ((TransferBufferLength % 4) == 3)	
-			TransferBufferLength  += 1;
+      if ((TransferBufferLength % 4) == 1)	
+	TransferBufferLength  += 3;
+      else if ((TransferBufferLength % 4) == 2)	
+	TransferBufferLength  += 2;
+      else if ((TransferBufferLength % 4) == 3)	
+	TransferBufferLength  += 1;
 
 		
-		if ((TransferBufferLength % pAd->BulkOutMaxPacketSize) == 0)
-			TransferBufferLength += 4;
+      if ((TransferBufferLength % pAd->BulkOutMaxPacketSize) == 0)
+	TransferBufferLength += 4;
 
-		pTxContext->BulkOutSize = TransferBufferLength;
-		pTxContext->bWaitingBulkOut = TRUE;
-		RTUSB_SET_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_NORMAL << QueIdx));
+      pTxContext->BulkOutSize = TransferBufferLength;
+      pTxContext->bWaitingBulkOut = TRUE;
+      RTUSB_SET_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_NORMAL << QueIdx));
 		
-		// Set frame gap for the rest of fragment burst.
-		// It won't matter if there is only one fragment (single fragment frame).
-		StartOfFrame = FALSE;
-		NumberRequired--;
-		if (NumberRequired == 0)
-		{
-			pTxContext->LastOne = TRUE;
-		}
-		else
-		{
-			pTxContext->LastOne = FALSE;
-		}
+      // Set frame gap for the rest of fragment burst.
+      // It won't matter if there is only one fragment (single fragment frame).
+      StartOfFrame = FALSE;
+      NumberRequired--;
+      if (NumberRequired == 0)
+	{
+	  pTxContext->LastOne = TRUE;
+	}
+      else
+	{
+	  pTxContext->LastOne = FALSE;
+	}
 		
-		pAd->TxRingTotalNumber[QueIdx]++;	// sync. to TxCount
-		atomic_inc(&pAd->TxCount);
+      pAd->TxRingTotalNumber[QueIdx]++;	// sync. to TxCount
+      atomic_inc(&pAd->TxCount);
 		
-	}	while (NumberRequired > 0);
+    }	while (NumberRequired > 0);
 
-	NdisReleaseSpinLock(&pAd->TxRingLock, IrqFlags);//BensonLiu modify
+  NdisReleaseSpinLock(&pAd->TxRingLock, IrqFlags);//BensonLiu modify
 
-	//	
-	// Check if MIC error twice within 60 seconds and send EAPOL MIC error to TX queue
-	// then we enqueue a message for disasociating with the current AP
-	//
+  //	
+  // Check if MIC error twice within 60 seconds and send EAPOL MIC error to TX queue
+  // then we enqueue a message for disasociating with the current AP
+  //
  
-	// Check for EAPOL frame sent after MIC countermeasures
-	if (pAd->PortCfg.MicErrCnt >= 3)
-	{
-		MLME_DISASSOC_REQ_STRUCT	DisassocReq;
-
-		// disassoc from current AP first
-              printk("<0>MLME - disassociate with current AP after sending second continuous EAPOL frame\n");
-		DBGPRINT(RT_DEBUG_TRACE, "MLME - disassociate with current AP after sending second continuous EAPOL frame\n");
-		DisassocParmFill(pAd, &DisassocReq, pAd->PortCfg.Bssid, REASON_MIC_FAILURE);
-		MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ, 
-					sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
-
-		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
-		pAd->PortCfg.bBlockAssoc = TRUE;
-		printk("<0>bBlockAssoc = %d\n", pAd->PortCfg.bBlockAssoc);
-	}
+  // Check for EAPOL frame sent after MIC countermeasures
+  if (pAd->PortCfg.MicErrCnt >= 3)
+    {
+      MLME_DISASSOC_REQ_STRUCT	DisassocReq;
+
+      // disassoc from current AP first
+      printk("<0>MLME - disassociate with current AP after sending second continuous EAPOL frame\n");
+      DBGPRINT(RT_DEBUG_TRACE, "MLME - disassociate with current AP after sending second continuous EAPOL frame\n");
+      DisassocParmFill(pAd, &DisassocReq, pAd->PortCfg.Bssid, REASON_MIC_FAILURE);
+      MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ, 
+		  sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
+
+      pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
+      pAd->PortCfg.bBlockAssoc = TRUE;
+      printk("<0>bBlockAssoc = %d\n", pAd->PortCfg.bBlockAssoc);
+    }
 
 
-	// release the skb buffer
-	RELEASE_NDIS_PACKET(pAd, pSkb);
-	DBGPRINT(RT_DEBUG_INFO, "<==== RTUSBHardTransmit\n");
-	return (NDIS_STATUS_SUCCESS);
+  // release the skb buffer
+  RELEASE_NDIS_PACKET(pAd, pSkb);
+  DBGPRINT(RT_DEBUG_INFO, "<==== RTUSBHardTransmit\n");
+  return (NDIS_STATUS_SUCCESS);
 }
 
 /*
-	========================================================================
+  ========================================================================
 
-	Routine	Description:
-		Copy frame from waiting queue into relative ring buffer and set 
-	appropriate ASIC register to kick hardware transmit function
+  Routine	Description:
+  Copy frame from waiting queue into relative ring buffer and set 
+  appropriate ASIC register to kick hardware transmit function
 	
-	Arguments:
-		pAd			Pointer	to our adapter
-		pBuffer		Pointer to	memory of outgoing frame
-		Length		Size of outgoing management frame
+  Arguments:
+  pAd			Pointer	to our adapter
+  pBuffer		Pointer to	memory of outgoing frame
+  Length		Size of outgoing management frame
 		
-	Return Value:
-		NDIS_STATUS_FAILURE
-		NDIS_STATUS_PENDING
-		NDIS_STATUS_SUCCESS
+  Return Value:
+  NDIS_STATUS_FAILURE
+  NDIS_STATUS_PENDING
+  NDIS_STATUS_SUCCESS
 
-	Note:
+  Note:
 	
-	========================================================================
+  ========================================================================
 */
 VOID	RTUSBMlmeHardTransmit(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PMGMT_STRUC		pMgmt)
+			      IN	PRTMP_ADAPTER	pAd,
+			      IN	PMGMT_STRUC		pMgmt)
 {
-	PTX_CONTEXT		pMLMEContext;
-	PTXD_STRUC		pTxD;
+  PTX_CONTEXT		pMLMEContext;
+  PTXD_STRUC		pTxD;
 #ifdef BIG_ENDIAN
-	PTXD_STRUC		pDestTxD;
-	TXD_STRUC		TxD;
+  PTXD_STRUC		pDestTxD;
+  TXD_STRUC		TxD;
 #endif
-	PUCHAR			pDest;	
-	PHEADER_802_11	pHeader_802_11;
-	BOOLEAN 		AckRequired, InsertTimestamp;
-	ULONG			TransferBufferLength;
-	PVOID			pBuffer = pMgmt->pBuffer;
-	ULONG			Length = pMgmt->Length;
-	UCHAR			QueIdx;
-	UCHAR			MlmeRate;
+  PUCHAR			pDest;	
+  PHEADER_802_11	pHeader_802_11;
+  BOOLEAN 		AckRequired, InsertTimestamp;
+  ULONG			TransferBufferLength;
+  PVOID			pBuffer = pMgmt->pBuffer;
+  ULONG			Length = pMgmt->Length;
+  UCHAR			QueIdx;
+  UCHAR			MlmeRate;
 	
-	DBGPRINT_RAW(RT_DEBUG_INFO, "--->MlmeHardTransmit\n");
+  DBGPRINT_RAW(RT_DEBUG_INFO, "--->MlmeHardTransmit\n");
 
-	//pAd->PrioRingTxCnt++;
+  //pAd->PrioRingTxCnt++;
 
-	pMLMEContext = &pAd->MLMEContext[pAd->NextMLMEIndex];
-	pMLMEContext->InUse = TRUE;
+  pMLMEContext = &pAd->MLMEContext[pAd->NextMLMEIndex];
+  pMLMEContext->InUse = TRUE;
 
-	// Increase & maintain Tx Ring Index
-	pAd->NextMLMEIndex++;
-	if (pAd->NextMLMEIndex >= PRIO_RING_SIZE)
-	{
-		pAd->NextMLMEIndex = 0;
-	}
+  // Increase & maintain Tx Ring Index
+  pAd->NextMLMEIndex++;
+  if (pAd->NextMLMEIndex >= PRIO_RING_SIZE)
+    {
+      pAd->NextMLMEIndex = 0;
+    }
 
-	pDest = pMLMEContext->TransferBuffer->u.WirelessPacket;			   
+  pDest = pMLMEContext->TransferBuffer->u.WirelessPacket;			   
 	
 #ifndef BIG_ENDIAN
-	pTxD = (PTXD_STRUC)(pMLMEContext->TransferBuffer);
+  pTxD = (PTXD_STRUC)(pMLMEContext->TransferBuffer);
 #else
-	pDestTxD  = (PTXD_STRUC)(pMLMEContext->TransferBuffer);
-	TxD = *pDestTxD;
-	pTxD = &TxD;
-	RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+  pDestTxD  = (PTXD_STRUC)(pMLMEContext->TransferBuffer);
+  TxD = *pDestTxD;
+  pTxD = &TxD;
+  RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
 #endif
-	NdisZeroMemory(pTxD, sizeof(TXD_STRUC));
+  NdisZeroMemory(pTxD, sizeof(TXD_STRUC));
 
-	pHeader_802_11 = (PHEADER_802_11) pBuffer;
+  pHeader_802_11 = (PHEADER_802_11) pBuffer;
     
-	// Verify Mlme rate for a / g bands.
-    if (pHeader_802_11->Addr1[0] & 0x01)
-	{
-		MlmeRate = pAd->PortCfg.BasicMlmeRate;
-	}
-	else
-	{
-		MlmeRate = pAd->PortCfg.MlmeRate;
-	}
+  // Verify Mlme rate for a / g bands.
+  if (pHeader_802_11->Addr1[0] & 0x01)
+    {
+      MlmeRate = pAd->PortCfg.BasicMlmeRate;
+    }
+  else
+    {
+      MlmeRate = pAd->PortCfg.MlmeRate;
+    }
 
-	if ((pAd->LatchRfRegs.Channel > 14) && (MlmeRate < RATE_6)) // 11A band
-		MlmeRate = RATE_6;
+  if ((pAd->LatchRfRegs.Channel > 14) && (MlmeRate < RATE_6)) // 11A band
+    MlmeRate = RATE_6;
 
-	DBGPRINT(RT_DEBUG_TRACE, "<---MlmeRate %d	Channel %d\n",MlmeRate, pAd->LatchRfRegs.Channel );
+  DBGPRINT(RT_DEBUG_TRACE, "<---MlmeRate %d	Channel %d\n",MlmeRate, pAd->LatchRfRegs.Channel );
 	
 
 
-    // Before radar detection done, mgmt frame can not be sent but probe req
-	// Because we need to use probe req to trigger driver to send probe req in passive scan
-	if ((pHeader_802_11->FC.SubType != SUBTYPE_PROBE_REQ) && (pAd->PortCfg.bIEEE80211H == 1) && (pAd->PortCfg.RadarDetect.RDMode != RD_NORMAL_MODE))
-	{
-		DBGPRINT(RT_DEBUG_ERROR, "RTUSBMlmeHardTransmit --> radar detect not in normal mode !!!\n");
-		return;
-	}
+  // Before radar detection done, mgmt frame can not be sent but probe req
+  // Because we need to use probe req to trigger driver to send probe req in passive scan
+  if ((pHeader_802_11->FC.SubType != SUBTYPE_PROBE_REQ) && (pAd->PortCfg.bIEEE80211H == 1) && (pAd->PortCfg.RadarDetect.RDMode != RD_NORMAL_MODE))
+    {
+      DBGPRINT(RT_DEBUG_ERROR, "RTUSBMlmeHardTransmit --> radar detect not in normal mode !!!\n");
+      return;
+    }
 
 
-	if (pHeader_802_11->FC.PwrMgmt != PWR_SAVE)
-	{
-		pHeader_802_11->FC.PwrMgmt = (pAd->PortCfg.Psm == PWR_SAVE);
-	}
+  if (pHeader_802_11->FC.PwrMgmt != PWR_SAVE)
+    {
+      pHeader_802_11->FC.PwrMgmt = (pAd->PortCfg.Psm == PWR_SAVE);
+    }
 	
-	InsertTimestamp = FALSE;
-	if (pHeader_802_11->FC.Type == BTYPE_CNTL) // must be PS-POLL
+  InsertTimestamp = FALSE;
+  if (pHeader_802_11->FC.Type == BTYPE_CNTL) // must be PS-POLL
+    {
+      AckRequired = FALSE;
+    }
+  else // BTYPE_MGMT or BMGMT_DATA(must be NULL frame)
+    {
+      pAd->Sequence		= ((pAd->Sequence) + 1) & (MAX_SEQ_NUMBER);
+      pHeader_802_11->Sequence = pAd->Sequence;
+
+      if (pHeader_802_11->Addr1[0] & 0x01) // MULTICAST, BROADCAST
 	{
-		AckRequired = FALSE;
+	  INC_COUNTER64(pAd->WlanCounters.MulticastTransmittedFrameCount);
+	  AckRequired = FALSE;
+	  pHeader_802_11->Duration = 0;
 	}
-	else // BTYPE_MGMT or BMGMT_DATA(must be NULL frame)
+      else
 	{
-		pAd->Sequence		= ((pAd->Sequence) + 1) & (MAX_SEQ_NUMBER);
-		pHeader_802_11->Sequence = pAd->Sequence;
-
-		if (pHeader_802_11->Addr1[0] & 0x01) // MULTICAST, BROADCAST
-		{
-			INC_COUNTER64(pAd->WlanCounters.MulticastTransmittedFrameCount);
-			AckRequired = FALSE;
-			pHeader_802_11->Duration = 0;
-		}
-		else
-		{
-			AckRequired = TRUE;
-			pHeader_802_11->Duration = RTMPCalcDuration(pAd, MlmeRate, 14);
-			if (pHeader_802_11->FC.SubType == SUBTYPE_PROBE_RSP)
-			{
-				InsertTimestamp = TRUE;
-			}
-		}
+	  AckRequired = TRUE;
+	  pHeader_802_11->Duration = RTMPCalcDuration(pAd, MlmeRate, 14);
+	  if (pHeader_802_11->FC.SubType == SUBTYPE_PROBE_RSP)
+	    {
+	      InsertTimestamp = TRUE;
+	    }
 	}
+    }
 
 #ifdef BIG_ENDIAN
-	RTMPFrameEndianChange(pAd, (PUCHAR)pBuffer, DIR_WRITE, FALSE);
+  RTMPFrameEndianChange(pAd, (PUCHAR)pBuffer, DIR_WRITE, FALSE);
 #endif
 
-	NdisMoveMemory(pDest, pBuffer, Length);
+  NdisMoveMemory(pDest, pBuffer, Length);
 
-	// Initialize Priority Descriptor
-	// For inter-frame gap, the number is for this frame and next frame
-	// For MLME rate, we will fix as 2Mb to match other vendor's implement
+  // Initialize Priority Descriptor
+  // For inter-frame gap, the number is for this frame and next frame
+  // For MLME rate, we will fix as 2Mb to match other vendor's implement
 	
-	QueIdx = QID_AC_BE;
+  QueIdx = QID_AC_BE;
 
 #ifdef BIG_ENDIAN
-	RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
-	*pDestTxD = TxD;
-	pTxD = pDestTxD;
+  RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+  *pDestTxD = TxD;
+  pTxD = pDestTxD;
 #endif
-	RTUSBWriteTxDescriptor(pAd, pTxD, CIPHER_NONE, 0,0, AckRequired, FALSE, FALSE, SHORT_RETRY,
-			IFS_BACKOFF, MlmeRate, /*Length+4*/ Length, QueIdx, PID_MGMT_FRAME, FALSE);
+  RTUSBWriteTxDescriptor(pAd, pTxD, CIPHER_NONE, 0,0, AckRequired, FALSE, FALSE, SHORT_RETRY,
+			 IFS_BACKOFF, MlmeRate, /*Length+4*/ Length, QueIdx, PID_MGMT_FRAME, FALSE);
 
 
 	
 #ifdef DBG
-	{
+  {
 #if 0
-		UINT i;
-		PUCHAR ptr = (PUCHAR)pDestTxD;
-
-		DBGPRINT(RT_DEBUG_TRACE, "pAd->NextMLMEIndex = %d *pDestTxD :\n", pAd->NextMLMEIndex);
-		DBGPRINT(RT_DEBUG_TRACE, "ptr = %d\n",ptr);
-		for (i=0;i<64; i+=16)
-		{
-			DBGPRINT_RAW(RT_DEBUG_TRACE,"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x - %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
-				*ptr,*(ptr+1),*(ptr+2),*(ptr+3),*(ptr+4),*(ptr+5),*(ptr+6),*(ptr+7),
-				*(ptr+8),*(ptr+9),*(ptr+10),*(ptr+11),*(ptr+12),*(ptr+13),*(ptr+14),*(ptr+15));
-			ptr += 16;
+    UINT i;
+    PUCHAR ptr = (PUCHAR)pDestTxD;
+
+    DBGPRINT(RT_DEBUG_TRACE, "pAd->NextMLMEIndex = %d *pDestTxD :\n", pAd->NextMLMEIndex);
+    DBGPRINT(RT_DEBUG_TRACE, "ptr = %d\n",ptr);
+    for (i=0;i<64; i+=16)
+      {
+	DBGPRINT_RAW(RT_DEBUG_TRACE,"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x - %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
+		     *ptr,*(ptr+1),*(ptr+2),*(ptr+3),*(ptr+4),*(ptr+5),*(ptr+6),*(ptr+7),
+		     *(ptr+8),*(ptr+9),*(ptr+10),*(ptr+11),*(ptr+12),*(ptr+13),*(ptr+14),*(ptr+15));
+	ptr += 16;
 			
-		}
+      }
 #endif
-	}
+  }
 #endif
 
 
 
-	// Build our URB for USBD
-	TransferBufferLength = sizeof(TXD_STRUC) + Length;
-	if ((TransferBufferLength % 2) == 1)
-		TransferBufferLength++;
+  // Build our URB for USBD
+  TransferBufferLength = sizeof(TXD_STRUC) + Length;
+  if ((TransferBufferLength % 2) == 1)
+    TransferBufferLength++;
 
 	
-	if ((TransferBufferLength % pAd->BulkOutMaxPacketSize) == 0)
-		TransferBufferLength += 2;
+  if ((TransferBufferLength % pAd->BulkOutMaxPacketSize) == 0)
+    TransferBufferLength += 2;
 	
-	pMLMEContext->BulkOutSize = TransferBufferLength;
-	pMLMEContext->bWaitingBulkOut = TRUE;
-	RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_MLME);
-	pAd->PrioRingTxCnt++;//2007/12/24:WY fixed queeue full bug
-	//DBGPRINT(RT_DEBUG_INFO, "<---MlmeHardTransmit\n");
+  pMLMEContext->BulkOutSize = TransferBufferLength;
+  pMLMEContext->bWaitingBulkOut = TRUE;
+  RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_MLME);
+  pAd->PrioRingTxCnt++;//2007/12/24:WY fixed queeue full bug
+  //DBGPRINT(RT_DEBUG_INFO, "<---MlmeHardTransmit\n");
 }
 
 /*
-	========================================================================
+  ========================================================================
 
-	Routine	Description:
-		This subroutine will scan through releative ring descriptor to find
-		out avaliable free ring descriptor and compare with request size.
+  Routine	Description:
+  This subroutine will scan through releative ring descriptor to find
+  out avaliable free ring descriptor and compare with request size.
 		
-	Arguments:
-		pAd			Pointer	to our adapter
-		RingType	Selected Ring
+  Arguments:
+  pAd			Pointer	to our adapter
+  RingType	Selected Ring
 		
-	Return Value:
-		NDIS_STATUS_FAILURE		Not enough free descriptor
-		NDIS_STATUS_SUCCESS		Enough free descriptor
+  Return Value:
+  NDIS_STATUS_FAILURE		Not enough free descriptor
+  NDIS_STATUS_SUCCESS		Enough free descriptor
 
-	Note:
+  Note:
 	
-	========================================================================
+  ========================================================================
 */
 NDIS_STATUS	RTUSBFreeDescriptorRequest(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			RingType,
-	IN	UCHAR			BulkOutPipeId,
-	IN	UCHAR			NumberRequired)
+					   IN	PRTMP_ADAPTER	pAd,
+					   IN	UCHAR			RingType,
+					   IN	UCHAR			BulkOutPipeId,
+					   IN	UCHAR			NumberRequired)
 {
-	UCHAR			FreeNumber = 0;
-	UINT			Index;
-	NDIS_STATUS		Status = NDIS_STATUS_FAILURE;
+  UCHAR			FreeNumber = 0;
+  UINT			Index;
+  NDIS_STATUS		Status = NDIS_STATUS_FAILURE;
 
-	switch (RingType)
+  switch (RingType)
+    {
+    case TX_RING:
+      Index = (pAd->NextTxIndex[BulkOutPipeId] + 1) % TX_RING_SIZE;
+      do
 	{
-		case TX_RING:
-			Index = (pAd->NextTxIndex[BulkOutPipeId] + 1) % TX_RING_SIZE;
-			do
-			{
-				PTX_CONTEXT	pTxD  = &pAd->TxContext[BulkOutPipeId][Index];
+	  PTX_CONTEXT	pTxD  = &pAd->TxContext[BulkOutPipeId][Index];
 				
-				// While Owner bit is NIC, obviously ASIC still need it.
-				// If valid bit is TRUE, indicate that TxDone has not process yet
-				// We should not use it until TxDone finish cleanup job
-				if (pTxD->InUse == FALSE)
-				{
-					// This one is free
-					FreeNumber++;
-				}
-				else
-				{
-					break;
-				}					
-				Index = (Index + 1) % TX_RING_SIZE;
-			}	while (FreeNumber < NumberRequired);	// Quit here ! Free number is enough !
+	  // While Owner bit is NIC, obviously ASIC still need it.
+	  // If valid bit is TRUE, indicate that TxDone has not process yet
+	  // We should not use it until TxDone finish cleanup job
+	  if (pTxD->InUse == FALSE)
+	    {
+	      // This one is free
+	      FreeNumber++;
+	    }
+	  else
+	    {
+	      break;
+	    }					
+	  Index = (Index + 1) % TX_RING_SIZE;
+	}	while (FreeNumber < NumberRequired);	// Quit here ! Free number is enough !
 			
-			if (FreeNumber >= NumberRequired)
-			{
-				Status = NDIS_STATUS_SUCCESS;
-			}
+      if (FreeNumber >= NumberRequired)
+	{
+	  Status = NDIS_STATUS_SUCCESS;
+	}
 			
-			break;
+      break;
 			
-		case PRIO_RING:
-			Index = pAd->NextMLMEIndex;
-			do
-			{
-				PTX_CONTEXT	pTxD  = &pAd->MLMEContext[Index];
+    case PRIO_RING:
+      Index = pAd->NextMLMEIndex;
+      do
+	{
+	  PTX_CONTEXT	pTxD  = &pAd->MLMEContext[Index];
 				
-				// While Owner bit is NIC, obviously ASIC still need it.
-				// If valid bit is TRUE, indicate that TxDone has not process yet
-				// We should not use it until TxDone finish cleanup job
-				if (pTxD->InUse == FALSE)
-				{
-					// This one is free
-					FreeNumber++;
-				}
-				else
-				{
-					break;
-				}
+	  // While Owner bit is NIC, obviously ASIC still need it.
+	  // If valid bit is TRUE, indicate that TxDone has not process yet
+	  // We should not use it until TxDone finish cleanup job
+	  if (pTxD->InUse == FALSE)
+	    {
+	      // This one is free
+	      FreeNumber++;
+	    }
+	  else
+	    {
+	      break;
+	    }
 					
-				Index = (Index + 1) % PRIO_RING_SIZE;				
-			}	while (FreeNumber < NumberRequired);	// Quit here ! Free number is enough !
+	  Index = (Index + 1) % PRIO_RING_SIZE;				
+	}	while (FreeNumber < NumberRequired);	// Quit here ! Free number is enough !
 
-			if (FreeNumber >= NumberRequired)
-			{
-				Status = NDIS_STATUS_SUCCESS;
-			}
-			break;
+      if (FreeNumber >= NumberRequired)
+	{
+	  Status = NDIS_STATUS_SUCCESS;
+	}
+      break;
 
-		default:
-			DBGPRINT_RAW(RT_DEBUG_ERROR, "--->RTUSBFreeDescriptorRequest() -----!! \n");
+    default:
+      DBGPRINT_RAW(RT_DEBUG_ERROR, "--->RTUSBFreeDescriptorRequest() -----!! \n");
 			
-			break;
-	}
+      break;
+    }
 	
-	return (Status);
+  return (Status);
 }
 
 /*
-	========================================================================
+  ========================================================================
 	
-	Routine Description:
+  Routine Description:
 
-	Arguments:
+  Arguments:
 
-	Return Value:
+  Return Value:
 	
-	Note:
+  Note:
 	
-	========================================================================
+  ========================================================================
 */
 VOID	RTUSBRejectPendingPackets(
-	IN	PRTMP_ADAPTER	pAd)
+				  IN	PRTMP_ADAPTER	pAd)
 {		
-	UCHAR			Index;
-	PQUEUE_HEADER	pQueue;
-	struct sk_buff	*skb;
-	unsigned long	IrqFlags;
+  UCHAR			Index;
+  PQUEUE_HEADER	pQueue;
+  struct sk_buff	*skb;
+  unsigned long	IrqFlags;
 	
-	DBGPRINT_RAW(RT_DEBUG_TRACE, "--->RejectPendingPackets\n");
+  DBGPRINT_RAW(RT_DEBUG_TRACE, "--->RejectPendingPackets\n");
 
-	for (Index = 0; Index < 4; Index++)
-	{
-		NdisAcquireSpinLock(&pAd->SendTxWaitQueueLock[Index], IrqFlags);
-		while (pAd->SendTxWaitQueue[Index].Head != NULL)
-		{		
-			pQueue = (PQUEUE_HEADER) &(pAd->SendTxWaitQueue[Index]);
+  for (Index = 0; Index < 4; Index++)
+    {
+      NdisAcquireSpinLock(&pAd->SendTxWaitQueueLock[Index], IrqFlags);
+      while (pAd->SendTxWaitQueue[Index].Head != NULL)
+	{		
+	  pQueue = (PQUEUE_HEADER) &(pAd->SendTxWaitQueue[Index]);
 
-			skb = (struct sk_buff *)RemoveHeadQueue(pQueue);
-			RTUSBFreeSkbBuffer(skb);
-		}
-		NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[Index], IrqFlags);
+	  skb = (struct sk_buff *)RemoveHeadQueue(pQueue);
+	  RTUSBFreeSkbBuffer(skb);
 	}
+      NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[Index], IrqFlags);
+    }
 	
-	DBGPRINT_RAW(RT_DEBUG_TRACE, "<---RejectPendingPackets\n");
+  DBGPRINT_RAW(RT_DEBUG_TRACE, "<---RejectPendingPackets\n");
 }
 
 /*
-	========================================================================
-	
-	Routine	Description:
-		Calculates the duration which is required to transmit out frames 
-	with given size and specified rate.
-		
-	Arguments:
-		pTxD		Pointer to transmit descriptor
-		Ack			Setting for Ack requirement bit
-		Fragment	Setting for Fragment bit
-		RetryMode	Setting for retry mode
-		Ifs			Setting for IFS gap
-		Rate		Setting for transmit rate
-		Service		Setting for service
-		Length		Frame length
-		TxPreamble	Short or Long preamble when using CCK rates
-		QueIdx - 0-3, according to 802.11e/d4.4 June/2003
-		
-	Return Value:
-		None
-		
-	========================================================================
+  ========================================================================
+	
+  Routine	Description:
+  Calculates the duration which is required to transmit out frames 
+  with given size and specified rate.
+		
+  Arguments:
+  pTxD		Pointer to transmit descriptor
+  Ack			Setting for Ack requirement bit
+  Fragment	Setting for Fragment bit
+  RetryMode	Setting for retry mode
+  Ifs			Setting for IFS gap
+  Rate		Setting for transmit rate
+  Service		Setting for service
+  Length		Frame length
+  TxPreamble	Short or Long preamble when using CCK rates
+  QueIdx - 0-3, according to 802.11e/d4.4 June/2003
+		
+  Return Value:
+  None
+		
+  ========================================================================
 */
 VOID	RTUSBWriteTxDescriptor(
-	IN	PRTMP_ADAPTER pAd,
-	IN	PTXD_STRUC	pSourceTxD,
-	IN	UCHAR		CipherAlg,
-	IN	UCHAR		KeyTable,
-	IN	UCHAR		KeyIdx,
-	IN	BOOLEAN		Ack,
-	IN	BOOLEAN		Fragment,
-	IN	BOOLEAN 	InsTimestamp,
-	IN	UCHAR		RetryMode,
-	IN	UCHAR		Ifs,
-	IN	UINT		Rate,
-	IN	ULONG		Length,
-	IN	UCHAR		QueIdx,
-	IN	UCHAR		PID,
-	IN	BOOLEAN		bAfterRTSCTS)
+			       IN	PRTMP_ADAPTER pAd,
+			       IN	PTXD_STRUC	pSourceTxD,
+			       IN	UCHAR		CipherAlg,
+			       IN	UCHAR		KeyTable,
+			       IN	UCHAR		KeyIdx,
+			       IN	BOOLEAN		Ack,
+			       IN	BOOLEAN		Fragment,
+			       IN	BOOLEAN 	InsTimestamp,
+			       IN	UCHAR		RetryMode,
+			       IN	UCHAR		Ifs,
+			       IN	UINT		Rate,
+			       IN	ULONG		Length,
+			       IN	UCHAR		QueIdx,
+			       IN	UCHAR		PID,
+			       IN	BOOLEAN		bAfterRTSCTS)
 {
-	UINT	Residual;
+  UINT	Residual;
 
-	PTXD_STRUC		pTxD;
+  PTXD_STRUC		pTxD;
 	
 #ifndef BIG_ENDIAN
-	pTxD = pSourceTxD;
+  pTxD = pSourceTxD;
 #else
-	TXD_STRUC		TxD;
+  TXD_STRUC		TxD;
 	
-	TxD = *pSourceTxD;
-	pTxD = &TxD;
-	RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+  TxD = *pSourceTxD;
+  pTxD = &TxD;
+  RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
 #endif
 
 
-	pTxD->HostQId	  = QueIdx;
-	pTxD->MoreFrag	  = Fragment;
-	pTxD->ACK		  = Ack;
-	pTxD->Timestamp   = InsTimestamp;
-	pTxD->RetryMd	  = RetryMode;
-	pTxD->Ofdm		  = (Rate < RATE_FIRST_OFDM_RATE)? 0:1;
-	pTxD->IFS		  = Ifs;
-	pTxD->PktId 	  = PID;
-	pTxD->Drop		  = 1;	 // 1:valid, 0:drop
-	pTxD->HwSeq 	  = 1;	  // (QueIdx == QID_MGMT)? 1:0; 
-	pTxD->BbpTxPower  = DEFAULT_BBP_TX_POWER; // TODO: to be modified
-	pTxD->DataByteCnt = Length;
-	
-	RTMPCckBbpTuning(pAd, Rate);
-	
-	// fill encryption related information, if required
-	pTxD->CipherAlg   = CipherAlg;
-	if (CipherAlg != CIPHER_NONE)
-	{
-		pTxD->KeyTable	  = KeyTable;
-		pTxD->KeyIndex	  = KeyIdx;
-		pTxD->TkipMic	  = 1;
-	}
+  pTxD->HostQId	  = QueIdx;
+  pTxD->MoreFrag	  = Fragment;
+  pTxD->ACK		  = Ack;
+  pTxD->Timestamp   = InsTimestamp;
+  pTxD->RetryMd	  = RetryMode;
+  pTxD->Ofdm		  = (Rate < RATE_FIRST_OFDM_RATE)? 0:1;
+  pTxD->IFS		  = Ifs;
+  pTxD->PktId 	  = PID;
+  pTxD->Drop		  = 1;	 // 1:valid, 0:drop
+  pTxD->HwSeq 	  = 1;	  // (QueIdx == QID_MGMT)? 1:0; 
+  pTxD->BbpTxPower  = DEFAULT_BBP_TX_POWER; // TODO: to be modified
+  pTxD->DataByteCnt = Length;
+	
+  RTMPCckBbpTuning(pAd, Rate);
+	
+  // fill encryption related information, if required
+  pTxD->CipherAlg   = CipherAlg;
+  if (CipherAlg != CIPHER_NONE)
+    {
+      pTxD->KeyTable	  = KeyTable;
+      pTxD->KeyIndex	  = KeyIdx;
+      pTxD->TkipMic	  = 1;
+    }
 
-	// In TKIP+fragmentation. TKIP MIC is already appended by driver. MAC needs not generate MIC
-	if (CipherAlg == CIPHER_TKIP_NO_MIC)
-	{
-		pTxD->CipherAlg   = CIPHER_TKIP;
-		pTxD->TkipMic	  = 0;	 // tell MAC need not insert TKIP MIC
-	}
+  // In TKIP+fragmentation. TKIP MIC is already appended by driver. MAC needs not generate MIC
+  if (CipherAlg == CIPHER_TKIP_NO_MIC)
+    {
+      pTxD->CipherAlg   = CIPHER_TKIP;
+      pTxD->TkipMic	  = 0;	 // tell MAC need not insert TKIP MIC
+    }
 
 	
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED))
-	{	 
-		if ((pAd->PortCfg.APEdcaParm.bValid) && (QueIdx <= QID_AC_VO))
-		{
-			pTxD->Cwmin = pAd->PortCfg.APEdcaParm.Cwmin[QueIdx];
-			pTxD->Cwmax = pAd->PortCfg.APEdcaParm.Cwmax[QueIdx];
-			pTxD->Aifsn = pAd->PortCfg.APEdcaParm.Aifsn[QueIdx];
-		}
-		else
-		{
-			DBGPRINT(RT_DEBUG_ERROR," WMM in used but EDCA not valid ERROR !!\n)");
-		}
+  if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED))
+    {	 
+      if ((pAd->PortCfg.APEdcaParm.bValid) && (QueIdx <= QID_AC_VO))
+	{
+	  pTxD->Cwmin = pAd->PortCfg.APEdcaParm.Cwmin[QueIdx];
+	  pTxD->Cwmax = pAd->PortCfg.APEdcaParm.Cwmax[QueIdx];
+	  pTxD->Aifsn = pAd->PortCfg.APEdcaParm.Aifsn[QueIdx];
 	}
-	else
-	{   
-        if (bAfterRTSCTS)
+      else
+	{
+	  DBGPRINT(RT_DEBUG_ERROR," WMM in used but EDCA not valid ERROR !!\n)");
+	}
+    }
+  else
+    {   
+      if (bAfterRTSCTS)
         {
-            // After RTS/CTS frame, data frame should use SIFS time.
-            // To patch this code, add the following code.
-            // Recommended by Jerry 2005/07/25 for WiFi testing with Proxim AP
-            pTxD->Cwmin = 0;
-            pTxD->Cwmax = 0;
-            pTxD->Aifsn = 1;
-            pTxD->IFS = IFS_BACKOFF;
+	  // After RTS/CTS frame, data frame should use SIFS time.
+	  // To patch this code, add the following code.
+	  // Recommended by Jerry 2005/07/25 for WiFi testing with Proxim AP
+	  pTxD->Cwmin = 0;
+	  pTxD->Cwmax = 0;
+	  pTxD->Aifsn = 1;
+	  pTxD->IFS = IFS_BACKOFF;
         }   
-        else
+      else
         {
-            pTxD->Cwmin = CW_MIN_IN_BITS;
-            pTxD->Cwmax = CW_MAX_IN_BITS;
-            pTxD->Aifsn = 2;
-	    }
+	  pTxD->Cwmin = CW_MIN_IN_BITS;
+	  pTxD->Cwmax = CW_MAX_IN_BITS;
+	  pTxD->Aifsn = 2;
 	}
+    }
 
-	// fill up PLCP SIGNAL field
-	pTxD->PlcpSignal = RateIdToPlcpSignal[Rate];
-	if (((Rate == RATE_2) || (Rate == RATE_5_5) || (Rate == RATE_11)) && 
-		(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED)))
-	{
-		pTxD->PlcpSignal |= 0x0008;
-	}
+  // fill up PLCP SIGNAL field
+  pTxD->PlcpSignal = RateIdToPlcpSignal[Rate];
+  if (((Rate == RATE_2) || (Rate == RATE_5_5) || (Rate == RATE_11)) && 
+      (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED)))
+    {
+      pTxD->PlcpSignal |= 0x0008;
+    }
 
-	// fill up PLCP SERVICE field, not used for OFDM rates
-	pTxD->PlcpService = 4; // Service;
+  // fill up PLCP SERVICE field, not used for OFDM rates
+  pTxD->PlcpService = 4; // Service;
 
-	// file up PLCP LENGTH_LOW and LENGTH_HIGH fields
-	Length += LENGTH_CRC;	// CRC length
-	switch (CipherAlg) 
-	{
-		case CIPHER_WEP64:		 Length += 8;	 break;  // IV + ICV
-		case CIPHER_WEP128: 	 Length += 8;	 break;  // IV + ICV
-		case CIPHER_TKIP:		 Length += 20;	 break;  // IV + EIV + MIC + ICV
-		case CIPHER_AES:		 Length += 16;	 break;  // IV + EIV + MIC
-		case CIPHER_CKIP64: 	 Length += 8;	 break;  // IV + CMIC + ICV, but CMIC already inserted by driver
-		case CIPHER_CKIP128:	 Length += 8;	 break;  // IV + CMIC + ICV, but CMIC already inserted by driver
-		case CIPHER_TKIP_NO_MIC: Length += 12;	 break;  // IV + EIV + ICV
-		default:								 break;
-	}
+  // file up PLCP LENGTH_LOW and LENGTH_HIGH fields
+  Length += LENGTH_CRC;	// CRC length
+  switch (CipherAlg) 
+    {
+    case CIPHER_WEP64:		 Length += 8;	 break;  // IV + ICV
+    case CIPHER_WEP128: 	 Length += 8;	 break;  // IV + ICV
+    case CIPHER_TKIP:		 Length += 20;	 break;  // IV + EIV + MIC + ICV
+    case CIPHER_AES:		 Length += 16;	 break;  // IV + EIV + MIC
+    case CIPHER_CKIP64: 	 Length += 8;	 break;  // IV + CMIC + ICV, but CMIC already inserted by driver
+    case CIPHER_CKIP128:	 Length += 8;	 break;  // IV + CMIC + ICV, but CMIC already inserted by driver
+    case CIPHER_TKIP_NO_MIC: Length += 12;	 break;  // IV + EIV + ICV
+    default:								 break;
+    }
  
-	if (Rate < RATE_FIRST_OFDM_RATE)	// 11b - RATE_1, RATE_2, RATE_5_5, RATE_11
+  if (Rate < RATE_FIRST_OFDM_RATE)	// 11b - RATE_1, RATE_2, RATE_5_5, RATE_11
+    {
+      if ((Rate == RATE_1) || ( Rate == RATE_2))
 	{
-		if ((Rate == RATE_1) || ( Rate == RATE_2))
-		{
-			Length = Length * 8 / (Rate + 1);
-		}
-		else
-		{
-			Residual = ((Length * 16) % (11 * (1 + Rate - RATE_5_5)));
-			Length = Length * 16 / (11 * (1 + Rate - RATE_5_5));
-			if (Residual != 0)
-			{
-				Length++;
-			}
-			if ((Residual <= (3 * (1 + Rate - RATE_5_5))) && (Residual != 0))
-			{
-				if (Rate == RATE_11)			// Only 11Mbps require length extension bit
-					pTxD->PlcpService |= 0x80; // 11b's PLCP Length extension bit
-			}
-		}
-
-		pTxD->PlcpLengthHigh = Length >> 8; // 256;
-		pTxD->PlcpLengthLow = Length % 256;
+	  Length = Length * 8 / (Rate + 1);
 	}
-	else	// OFDM - RATE_6, RATE_9, RATE_12, RATE_18, RATE_24, RATE_36, RATE_48, RATE_54
+      else
 	{
-		pTxD->PlcpLengthHigh = Length >> 6; // 64;	// high 6-bit of total byte count
-		pTxD->PlcpLengthLow = Length % 64;	 // low 6-bit of total byte count
+	  Residual = ((Length * 16) % (11 * (1 + Rate - RATE_5_5)));
+	  Length = Length * 16 / (11 * (1 + Rate - RATE_5_5));
+	  if (Residual != 0)
+	    {
+	      Length++;
+	    }
+	  if ((Residual <= (3 * (1 + Rate - RATE_5_5))) && (Residual != 0))
+	    {
+	      if (Rate == RATE_11)			// Only 11Mbps require length extension bit
+		pTxD->PlcpService |= 0x80; // 11b's PLCP Length extension bit
+	    }
 	}
+
+      pTxD->PlcpLengthHigh = Length >> 8; // 256;
+      pTxD->PlcpLengthLow = Length % 256;
+    }
+  else	// OFDM - RATE_6, RATE_9, RATE_12, RATE_18, RATE_24, RATE_36, RATE_48, RATE_54
+    {
+      pTxD->PlcpLengthHigh = Length >> 6; // 64;	// high 6-bit of total byte count
+      pTxD->PlcpLengthLow = Length % 64;	 // low 6-bit of total byte count
+    }
 	
-	pTxD->Burst  = Fragment;
-	pTxD->Burst2 = pTxD->Burst;
+  pTxD->Burst  = Fragment;
+  pTxD->Burst2 = pTxD->Burst;
 
 #ifdef BIG_ENDIAN
-	RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
-	WriteBackToDescriptor((PUCHAR)pSourceTxD, (PUCHAR)pTxD, FALSE, TYPE_TXD);
+  RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+  WriteBackToDescriptor((PUCHAR)pSourceTxD, (PUCHAR)pTxD, FALSE, TYPE_TXD);
 #endif
 }
 
 /*
-	========================================================================
+  ========================================================================
 
-	Routine	Description:
-		To do the enqueue operation and extract the first item of waiting 
-		list. If a number of available shared memory segments could meet 
-		the request of extracted item, the extracted item will be fragmented
-		into shared memory segments.
+  Routine	Description:
+  To do the enqueue operation and extract the first item of waiting 
+  list. If a number of available shared memory segments could meet 
+  the request of extracted item, the extracted item will be fragmented
+  into shared memory segments.
 		
-	Arguments:
-		pAd			Pointer	to our adapter
-		pQueue		Pointer to Waiting Queue
+  Arguments:
+  pAd			Pointer	to our adapter
+  pQueue		Pointer to Waiting Queue
 		
-	Return Value:
-		None
+  Return Value:
+  None
 
-	Note:
+  Note:
 	
-	========================================================================
+  ========================================================================
 */
 VOID	RTMPDeQueuePacket(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			BulkOutPipeId)
+			  IN	PRTMP_ADAPTER	pAd,
+			  IN	UCHAR			BulkOutPipeId)
 {
-	struct sk_buff	*pSkb;
-	UCHAR			FragmentRequired;
-	NDIS_STATUS		Status;
-	UCHAR			Count = 0;
-	PQUEUE_HEADER	pQueue;
-	UCHAR			QueIdx;
-	unsigned long	IrqFlags;
-	
-	NdisAcquireSpinLock(&pAd->DeQueueLock[BulkOutPipeId], IrqFlags);
-	if (pAd->DeQueueRunning[BulkOutPipeId])
-	{
-		NdisReleaseSpinLock(&pAd->DeQueueLock[BulkOutPipeId], IrqFlags);
-		return;
-	}
-	else
-	{
-		pAd->DeQueueRunning[BulkOutPipeId] = TRUE;
-		NdisReleaseSpinLock(&pAd->DeQueueLock[BulkOutPipeId], IrqFlags);
-	}
+  struct sk_buff	*pSkb;
+  UCHAR			FragmentRequired;
+  NDIS_STATUS		Status;
+  UCHAR			Count = 0;
+  PQUEUE_HEADER	pQueue;
+  UCHAR			QueIdx;
+  unsigned long	IrqFlags;
+	
+  NdisAcquireSpinLock(&pAd->DeQueueLock[BulkOutPipeId], IrqFlags);
+  if (pAd->DeQueueRunning[BulkOutPipeId])
+    {
+      NdisReleaseSpinLock(&pAd->DeQueueLock[BulkOutPipeId], IrqFlags);
+      return;
+    }
+  else
+    {
+      pAd->DeQueueRunning[BulkOutPipeId] = TRUE;
+      NdisReleaseSpinLock(&pAd->DeQueueLock[BulkOutPipeId], IrqFlags);
+    }
 
-	QueIdx = BulkOutPipeId;
+  QueIdx = BulkOutPipeId;
 	
-	if (pAd->TxRingTotalNumber[BulkOutPipeId])
-		DBGPRINT(RT_DEBUG_INFO,"--RTMPDeQueuePacket %d TxRingTotalNumber= %d !!--\n", BulkOutPipeId, (INT)pAd->TxRingTotalNumber[BulkOutPipeId]);
+  if (pAd->TxRingTotalNumber[BulkOutPipeId])
+    DBGPRINT(RT_DEBUG_INFO,"--RTMPDeQueuePacket %d TxRingTotalNumber= %d !!--\n", BulkOutPipeId, (INT)pAd->TxRingTotalNumber[BulkOutPipeId]);
 		
-	// Make sure SendTxWait queue resource won't be used by other threads 
-	NdisAcquireSpinLock(&pAd->SendTxWaitQueueLock[BulkOutPipeId], IrqFlags);
+  // Make sure SendTxWait queue resource won't be used by other threads 
+  NdisAcquireSpinLock(&pAd->SendTxWaitQueueLock[BulkOutPipeId], IrqFlags);
 
-	// Select Queue
-	pQueue = &pAd->SendTxWaitQueue[BulkOutPipeId];
+  // Select Queue
+  pQueue = &pAd->SendTxWaitQueue[BulkOutPipeId];
 		
-	// Check queue before dequeue
-	while ((pQueue->Head != NULL) && (Count < MAX_TX_PROCESS))
-	{		
-		// Reset is in progress, stop immediately
-		if ( RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS) ||
-			 RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS) ||
-			 RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
-		{
-			DBGPRINT(RT_DEBUG_ERROR,"--RTMPDeQueuePacket %d reset-in-progress !!--\n", BulkOutPipeId);
-			break;
-		}
+  // Check queue before dequeue
+  while ((pQueue->Head != NULL) && (Count < MAX_TX_PROCESS))
+    {		
+      // Reset is in progress, stop immediately
+      if ( RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS) ||
+	   RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS) ||
+	   RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
+	{
+	  DBGPRINT(RT_DEBUG_ERROR,"--RTMPDeQueuePacket %d reset-in-progress !!--\n", BulkOutPipeId);
+	  break;
+	}
 			
-		// Dequeue the first entry from head of queue list
-		pSkb = (struct sk_buff*)RemoveHeadQueue(pQueue);
+      // Dequeue the first entry from head of queue list
+      pSkb = (struct sk_buff*)RemoveHeadQueue(pQueue);
 
-		// RTS or CTS-to-self for B/G protection mode has been set already.
-		// There is no need to re-do it here. 
-		// Total fragment required = number of fragment + RST if required
-		FragmentRequired = RTMP_GET_PACKET_FRAGMENTS(pSkb) + RTMP_GET_PACKET_RTS(pSkb);
+      // RTS or CTS-to-self for B/G protection mode has been set already.
+      // There is no need to re-do it here. 
+      // Total fragment required = number of fragment + RST if required
+      FragmentRequired = RTMP_GET_PACKET_FRAGMENTS(pSkb) + RTMP_GET_PACKET_RTS(pSkb);
 		
-		if ((RTUSBFreeDescriptorRequest(pAd, TX_RING, BulkOutPipeId, FragmentRequired) == NDIS_STATUS_SUCCESS)) 
-		{
-			// Avaliable ring descriptors are enough for this frame
-			// Call hard transmit
-			// Nitro mode / Normal mode selection
-			NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[BulkOutPipeId], IrqFlags);
+      if ((RTUSBFreeDescriptorRequest(pAd, TX_RING, BulkOutPipeId, FragmentRequired) == NDIS_STATUS_SUCCESS)) 
+	{
+	  // Avaliable ring descriptors are enough for this frame
+	  // Call hard transmit
+	  // Nitro mode / Normal mode selection
+	  NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[BulkOutPipeId], IrqFlags);
 			
-			Status = RTUSBHardTransmit(pAd, pSkb, FragmentRequired, QueIdx);
+	  Status = RTUSBHardTransmit(pAd, pSkb, FragmentRequired, QueIdx);
 
-			// Acquire the resource again, snice we may need to process it in this while-loop.
-			NdisAcquireSpinLock(&pAd->SendTxWaitQueueLock[BulkOutPipeId], IrqFlags);
+	  // Acquire the resource again, snice we may need to process it in this while-loop.
+	  NdisAcquireSpinLock(&pAd->SendTxWaitQueueLock[BulkOutPipeId], IrqFlags);
 			
-			if (Status == NDIS_STATUS_FAILURE)
-			{
-				// Packet failed due to various Ndis Packet error
-				RTUSBFreeSkbBuffer(pSkb);
-				break;
-			}
-			else if (Status == NDIS_STATUS_RESOURCES)
-			{
-				// Not enough free tx ring, it might happen due to free descriptor inquery might be not correct
-				// It also might change to NDIS_STATUS_FAILURE to simply drop the frame
-				// Put the frame back into head of queue
-				InsertHeadQueue(pQueue, pSkb);
-				break;
-			}			
-			Count++;
-		}
-		else
-		{
-			DBGPRINT(RT_DEBUG_INFO,"--RTMPDeQueuePacket %d queue full !! TxRingTotalNumber= %d !! FragmentRequired=%d !!\n", BulkOutPipeId, (INT)pAd->TxRingTotalNumber[BulkOutPipeId], FragmentRequired);
-			InsertHeadQueue(pQueue, pSkb);
-		    pAd->PrivateInfo.TxRingFullCnt++;
+	  if (Status == NDIS_STATUS_FAILURE)
+	    {
+	      // Packet failed due to various Ndis Packet error
+	      RTUSBFreeSkbBuffer(pSkb);
+	      break;
+	    }
+	  else if (Status == NDIS_STATUS_RESOURCES)
+	    {
+	      // Not enough free tx ring, it might happen due to free descriptor inquery might be not correct
+	      // It also might change to NDIS_STATUS_FAILURE to simply drop the frame
+	      // Put the frame back into head of queue
+	      InsertHeadQueue(pQueue, pSkb);
+	      break;
+	    }			
+	  Count++;
+	}
+      else
+	{
+	  DBGPRINT(RT_DEBUG_INFO,"--RTMPDeQueuePacket %d queue full !! TxRingTotalNumber= %d !! FragmentRequired=%d !!\n", BulkOutPipeId, (INT)pAd->TxRingTotalNumber[BulkOutPipeId], FragmentRequired);
+	  InsertHeadQueue(pQueue, pSkb);
+	  pAd->PrivateInfo.TxRingFullCnt++;
 
-			break;
-		}
+	  break;
 	}
+    }
 
-	// Release TxSwQueue0 resources
-	NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[BulkOutPipeId],  IrqFlags);
+  // Release TxSwQueue0 resources
+  NdisReleaseSpinLock(&pAd->SendTxWaitQueueLock[BulkOutPipeId],  IrqFlags);
 
 #ifdef BLOCK_NET_IF
-	if ((pAd->blockQueueTab[QueIdx].SwTxQueueBlockFlag == TRUE)
-		&& (pAd->TxSwQueue[QueIdx].Number < 1))
-	{
-		releaseNetIf(&pAd->blockQueueTab[QueIdx]);
-	}
+  if ((pAd->blockQueueTab[QueIdx].SwTxQueueBlockFlag == TRUE)
+      && (pAd->TxSwQueue[QueIdx].Number < 1))
+    {
+      releaseNetIf(&pAd->blockQueueTab[QueIdx]);
+    }
 #endif // BLOCK_NET_IF //
 
-	NdisAcquireSpinLock(&pAd->DeQueueLock[BulkOutPipeId],  IrqFlags);
-	pAd->DeQueueRunning[BulkOutPipeId] = FALSE;
-	NdisReleaseSpinLock(&pAd->DeQueueLock[BulkOutPipeId],  IrqFlags);
+  NdisAcquireSpinLock(&pAd->DeQueueLock[BulkOutPipeId],  IrqFlags);
+  pAd->DeQueueRunning[BulkOutPipeId] = FALSE;
+  NdisReleaseSpinLock(&pAd->DeQueueLock[BulkOutPipeId],  IrqFlags);
 	
 }
 
 /*
-	========================================================================
-	 Description:
-		This is the completion routine for the USB_RxPacket which submits
-		a URB to USBD for a transmission. 
-	========================================================================
+  ========================================================================
+  Description:
+  This is the completion routine for the USB_RxPacket which submits
+  a URB to USBD for a transmission. 
+  ========================================================================
 */
 VOID	RTUSBRxPacket(
-	IN	 unsigned long data)
+		      IN	 unsigned long data)
 {
-	purbb_t 			pUrb = (purbb_t)data;
-	PRTMP_ADAPTER		pAd;
-	PRX_CONTEXT 		pRxContext;
-	PRXD_STRUC			pRxD;
+  purbb_t 			pUrb = (purbb_t)data;
+  PRTMP_ADAPTER		pAd;
+  PRX_CONTEXT 		pRxContext;
+  PRXD_STRUC			pRxD;
 #ifdef BIG_ENDIAN
-	PRXD_STRUC			pDestRxD;
-	RXD_STRUC			RxD;
+  PRXD_STRUC			pDestRxD;
+  RXD_STRUC			RxD;
 #endif
-	PHEADER_802_11		pHeader;
-	PUCHAR				pData;
-	PUCHAR				pDA, pSA;
-	NDIS_STATUS			Status;
-	USHORT				DataSize, Msdu2Size;
-	UCHAR				Header802_3[14];
-	PCIPHER_KEY 		pWpaKey;
-//	  struct sk_buff	  *pSkb;
-	BOOLEAN				EAPOLFrame;
-	struct net_device			*net_dev;
-
-	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBRxPacket\n");
-	
-	pRxContext = (PRX_CONTEXT)pUrb->context;
-	pAd = pRxContext->pAd;
-	net_dev = pAd->net_dev;
-
-	if( RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST) )
-		return;
-
-	do
+  PHEADER_802_11		pHeader;
+  PUCHAR				pData;
+  PUCHAR				pDA, pSA;
+  NDIS_STATUS			Status;
+  USHORT				DataSize, Msdu2Size;
+  UCHAR				Header802_3[14];
+  PCIPHER_KEY 		pWpaKey;
+  //	  struct sk_buff	  *pSkb;
+  BOOLEAN				EAPOLFrame;
+  struct net_device			*net_dev;
+
+  int success;
+  PUCHAR pRemovedLLCSNAP;
+  int idx;
+  BOOLEAN CheckPktSanity;
+  USHORT Payload1Size, Payload2Size;
+  PUCHAR pData2;
+
+  DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBRxPacket\n");
+	
+  pRxContext = (PRX_CONTEXT)pUrb->context;
+  pAd = pRxContext->pAd;
+  net_dev = pAd->net_dev;
+
+  if( RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST) )
+    return;
+
+  do
+    {
+      DBGPRINT_RAW(RT_DEBUG_INFO, "BulkIn actual length(%d)\n", pRxContext->pUrb->actual_length);
+      if (pRxContext->pUrb->actual_length >= sizeof(RXD_STRUC)+ LENGTH_802_11)
 	{
-		DBGPRINT_RAW(RT_DEBUG_INFO, "BulkIn actual length(%d)\n", pRxContext->pUrb->actual_length);
-		if (pRxContext->pUrb->actual_length >= sizeof(RXD_STRUC)+ LENGTH_802_11)
-		{
-		pData = pRxContext->TransferBuffer;
+	  pData = pRxContext->TransferBuffer;
 #ifndef BIG_ENDIAN
-		pRxD = (PRXD_STRUC) pData;
+	  pRxD = (PRXD_STRUC) pData;
 #else
-		pDestRxD = (PRXD_STRUC) pData;
-		RxD = *pDestRxD;
-		pRxD = &RxD;
-		RTMPDescriptorEndianChange((PUCHAR)pRxD, TYPE_RXD);
+	  pDestRxD = (PRXD_STRUC) pData;
+	  RxD = *pDestRxD;
+	  pRxD = &RxD;
+	  RTMPDescriptorEndianChange((PUCHAR)pRxD, TYPE_RXD);
 #endif
 		
-		// Cast to 802.11 header for flags checking
-		pHeader	= (PHEADER_802_11) (pData + sizeof(RXD_STRUC) );
+	  // Cast to 802.11 header for flags checking
+	  pHeader	= (PHEADER_802_11) (pData + sizeof(RXD_STRUC) );
 		
 #ifdef BIG_ENDIAN
-		RTMPFrameEndianChange(pAd, (PUCHAR)pHeader, DIR_READ, FALSE);
+	  RTMPFrameEndianChange(pAd, (PUCHAR)pHeader, DIR_READ, FALSE);
 #endif
-		if (pRxD->DataByteCnt < 4)
-			Status = NDIS_STATUS_FAILURE;
-		else
-		{
-			// Increase Total receive byte counter after real data received no mater any error or not
-			pAd->RalinkCounters.ReceivedByteCount += (pRxD->DataByteCnt - 4);
-			pAd->RalinkCounters.RxCount ++;
+	  if (pRxD->DataByteCnt < 4)
+	    Status = NDIS_STATUS_FAILURE;
+	  else
+	    {
+	      // Increase Total receive byte counter after real data received no mater any error or not
+	      pAd->RalinkCounters.ReceivedByteCount += (pRxD->DataByteCnt - 4);
+	      pAd->RalinkCounters.RxCount ++;
 		
-			// Check for all RxD errors
-			Status = RTMPCheckRxDescriptor(pAd, pHeader, pRxD);
+	      // Check for all RxD errors
+	      Status = RTMPCheckRxDescriptor(pAd, pHeader, pRxD);
 		
-		}
-		if (Status == NDIS_STATUS_SUCCESS)
-		{
-			// Apply packet filtering rule based on microsoft requirements.
-			Status = RTMPApplyPacketFilter(pAd, pRxD, pHeader);
-		}	
+	    }
+	  if (Status == NDIS_STATUS_SUCCESS)
+	    {
+	      // Apply packet filtering rule based on microsoft requirements.
+	      Status = RTMPApplyPacketFilter(pAd, pRxD, pHeader);
+	    }	
 
-		// Add receive counters
-		if (Status == NDIS_STATUS_SUCCESS)
-		{
-			// Increase 802.11 counters & general receive counters
-			INC_COUNTER64(pAd->WlanCounters.ReceivedFragmentCount);
-		}
-		else
-		{
-			// Increase general counters
-			pAd->Counters.RxErrors++;
-		}
+	  // Add receive counters
+	  if (Status == NDIS_STATUS_SUCCESS)
+	    {
+	      // Increase 802.11 counters & general receive counters
+	      INC_COUNTER64(pAd->WlanCounters.ReceivedFragmentCount);
+	    }
+	  else
+	    {
+	      // Increase general counters
+	      pAd->Counters.RxErrors++;
+	    }
 		
 #ifdef RALINK_ATE
-		    if((!pRxD->U2M) && pAd->ate.Mode != ATE_STASTART)
-		    {
-	            CHAR RealRssi;
-	                    
-	            RealRssi = ConvertToRssi(pAd, (UCHAR)pRxD->PlcpRssi, RSSI_NO_1);
-	            pAd->PortCfg.LastRssi  = RealRssi + pAd->BbpRssiToDbmDelta;
-	            pAd->PortCfg.AvgRssiX8  = (pAd->PortCfg.AvgRssiX8 - pAd->PortCfg.AvgRssi) + pAd->PortCfg.LastRssi;
-	            pAd->PortCfg.AvgRssi = pAd->PortCfg.AvgRssiX8 >> 3;
-// for smart antenna
-//	            if ((pAd->RfIcType == RFIC_5325) || (pAd->RfIcType == RFIC_2529))
-//                {
-//                    pAd->PortCfg.LastRssi2  = ConvertToRssi(pAd, (UCHAR)pRxD->PlcpSignal, RSSI_NO_2) + pAd->BbpRssiToDbmDelta;
-//                }
-		    }
+	  CHAR RealRssi;
+	  if((!pRxD->U2M) && pAd->ate.Mode != ATE_STASTART)
+	    {	                    
+	      RealRssi = ConvertToRssi(pAd, (UCHAR)pRxD->PlcpRssi, RSSI_NO_1);
+	      pAd->PortCfg.LastRssi  = RealRssi + pAd->BbpRssiToDbmDelta;
+	      pAd->PortCfg.AvgRssiX8  = (pAd->PortCfg.AvgRssiX8 - pAd->PortCfg.AvgRssi) + pAd->PortCfg.LastRssi;
+	      pAd->PortCfg.AvgRssi = pAd->PortCfg.AvgRssiX8 >> 3;
+	      // for smart antenna
+	      //	            if ((pAd->RfIcType == RFIC_5325) || (pAd->RfIcType == RFIC_2529))
+	      //                {
+	      //                    pAd->PortCfg.LastRssi2  = ConvertToRssi(pAd, (UCHAR)pRxD->PlcpSignal, RSSI_NO_2) + pAd->BbpRssiToDbmDelta;
+	      //                }
+	    }
 #endif	// RALINK_ATE
 		
-		// Check for retry bit, if this bit is on, search the cache with SA & sequence
-		// as index, if matched, discard this frame, otherwise, update cache
-		// This check only apply to unicast data & management frames
-		if ((pRxD->U2M) && (Status == NDIS_STATUS_SUCCESS) && (pHeader->FC.Type != BTYPE_CNTL))
+	  // Check for retry bit, if this bit is on, search the cache with SA & sequence
+	  // as index, if matched, discard this frame, otherwise, update cache
+	  // This check only apply to unicast data & management frames
+	  if ((pRxD->U2M) && (Status == NDIS_STATUS_SUCCESS) && (pHeader->FC.Type != BTYPE_CNTL))
+	    {
+	      if (pHeader->FC.Retry)
 		{
-			if (pHeader->FC.Retry)
-			{
-				if (RTMPSearchTupleCache(pAd, pHeader) == TRUE)
-				{
-					// Found retry frame in tuple cache, Discard this frame / fragment
-					// Increase 802.11 counters
-					INC_COUNTER64(pAd->WlanCounters.FrameDuplicateCount);
-					DBGPRINT_RAW(RT_DEBUG_INFO, "duplicate frame %d\n", pHeader->Sequence);
-					Status = NDIS_STATUS_FAILURE;
-				}
-				else
-				{
-					RTMPUpdateTupleCache(pAd, pHeader);
-				}
-			}
-			else	// Update Tuple Cache
-			{
-				RTMPUpdateTupleCache(pAd, pHeader);
-			}
+		  if (RTMPSearchTupleCache(pAd, pHeader) == TRUE)
+		    {
+		      // Found retry frame in tuple cache, Discard this frame / fragment
+		      // Increase 802.11 counters
+		      INC_COUNTER64(pAd->WlanCounters.FrameDuplicateCount);
+		      DBGPRINT_RAW(RT_DEBUG_INFO, "duplicate frame %d\n", pHeader->Sequence);
+		      Status = NDIS_STATUS_FAILURE;
+		    }
+		  else
+		    {
+		      RTMPUpdateTupleCache(pAd, pHeader);
+		    }
 		}
+	      else	// Update Tuple Cache
+		{
+		  RTMPUpdateTupleCache(pAd, pHeader);
+		}
+	    }
 		
-		if ((pRxD->U2M)	|| ((pHeader->FC.SubType == SUBTYPE_BEACON) && (MAC_ADDR_EQUAL(&pAd->PortCfg.Bssid, &pHeader->Addr2))))
+	  if ((pRxD->U2M)	|| ((pHeader->FC.SubType == SUBTYPE_BEACON) && (MAC_ADDR_EQUAL(&pAd->PortCfg.Bssid, &pHeader->Addr2))))
+	    {
+	      if ((pAd->Antenna.field.NumOfAntenna == 2) && (pAd->Antenna.field.TxDefaultAntenna == 0) && (pAd->Antenna.field.RxDefaultAntenna == 0))
 		{
-			if ((pAd->Antenna.field.NumOfAntenna == 2) && (pAd->Antenna.field.TxDefaultAntenna == 0) && (pAd->Antenna.field.RxDefaultAntenna == 0))
-			{
-				COLLECT_RX_ANTENNA_AVERAGE_RSSI(pAd, ConvertToRssi(pAd, (UCHAR)pRxD->PlcpRssi, RSSI_NO_1), 0); //Note: RSSI2 not used on RT73
-				pAd->PortCfg.NumOfAvgRssiSample ++;
-			}
+		  COLLECT_RX_ANTENNA_AVERAGE_RSSI(pAd, ConvertToRssi(pAd, (UCHAR)pRxD->PlcpRssi, RSSI_NO_1), 0); //Note: RSSI2 not used on RT73
+		  pAd->PortCfg.NumOfAvgRssiSample ++;
 		}
+	    }
 
-		//
-		// Do RxD release operation	for	all	failure	frames
-		//
-		if (Status == NDIS_STATUS_SUCCESS)
+	  //
+	  // Do RxD release operation	for	all	failure	frames
+	  //
+	  if (Status == NDIS_STATUS_SUCCESS)
+	    {
+	      do				
 		{
-			do				
-			{
 			
-				if (VIRTUAL_IF_NUM(pAd)==0)
-					break;
+		  if (VIRTUAL_IF_NUM(pAd)==0)
+		    break;
 
-				// pData : Pointer skip	the RxD Descriptior and the first 24 bytes,	802.11 HEADER
-				pData += LENGTH_802_11 + sizeof(RXD_STRUC);
-				DataSize = (USHORT) pRxD->DataByteCnt - LENGTH_802_11;
-
-				//
-				// CASE I. receive a DATA frame
-				//				
-				if (pHeader->FC.Type == BTYPE_DATA)
-				{
-					// before LINK UP, all DATA frames are rejected
-					if ( !OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED) )
-					{
-						DBGPRINT(RT_DEBUG_INFO,"RxDone- drop DATA frame before LINK UP(len=%d)\n",pRxD->DataByteCnt);
-						break;
-					}					
-                    pAd->BulkInDataOneSecCount++;
-
-
-					// remove the 2 extra QOS CNTL bytes
-					if (pHeader->FC.SubType & 0x08)
-					{
-						pData += 2;
-						DataSize -= 2;
-					}
-
-					// remove the 2 extra AGGREGATION bytes
-					Msdu2Size = 0;
-					if (pHeader->FC.Order)
-					{
-						Msdu2Size = *pData + (*(pData+1) << 8);
-						if ((Msdu2Size <= 1536) && (Msdu2Size < DataSize))
-						{
-							pData += 2;
-							DataSize -= 2;
-						}
-						else
-							Msdu2Size = 0;
-					}
+		  // pData : Pointer skip	the RxD Descriptior and the first 24 bytes,	802.11 HEADER
+		  pData += LENGTH_802_11 + sizeof(RXD_STRUC);
+		  DataSize = (USHORT) pRxD->DataByteCnt - LENGTH_802_11;
 
-					// Drop not my BSS frame
-					//
-					// Not drop EAPOL frame, since this have happen on the first time that we link up
-					// And need some more time to set BSSID to asic
-					// So pRxD->MyBss may be 0
-					//				
-			        if (RTMPEqualMemory(EAPOL, pData + 6, 2))
-						EAPOLFrame = TRUE;
-					else
-						EAPOLFrame = FALSE;
-
-					if ((pRxD->MyBss == 0) && (EAPOLFrame != TRUE))
-						break; // give up this frame
-
-					// Drop NULL (+CF-POLL) (+CF-ACK) data frame
-					if ((pHeader->FC.SubType & 0x04) == 0x04)
-					{
-						DBGPRINT(RT_DEBUG_TRACE,"RxDone- drop NULL frame(subtype=%d)\n",pHeader->FC.SubType);
-						break;
-					}
+		  //
+		  // CASE I. receive a DATA frame
+		  //				
+		  if (pHeader->FC.Type == BTYPE_DATA)
+		    {
+		      // before LINK UP, all DATA frames are rejected
+		      if ( !OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED) )
+			{
+			  DBGPRINT(RT_DEBUG_INFO,"RxDone- drop DATA frame before LINK UP(len=%d)\n",pRxD->DataByteCnt);
+			  break;
+			}					
+		      pAd->BulkInDataOneSecCount++;
 
 
-					// prepare 802.3 header: DA=addr1; SA=addr3 in INFRA mode, DA=addr2 in ADHOC mode
-					pDA = pHeader->Addr1; 
-					if (INFRA_ON(pAd))
-						pSA	= pHeader->Addr3;
-					else
-						pSA	= pHeader->Addr2;
+		      // remove the 2 extra QOS CNTL bytes
+		      if (pHeader->FC.SubType & 0x08)
+			{
+			  pData += 2;
+			  DataSize -= 2;
+			}
 
-					if (pHeader->FC.Wep) // frame received in encrypted format
-					{
-						if (pRxD->CipherAlg == CIPHER_NONE) // unsupported cipher suite
-						{
-							break; // give up this frame
-						}
-						else if (pAd->SharedKey[pRxD->KeyIndex].KeyLen == 0)
-						{
-							break; // give up this frame since the keylen is invalid.
-						}				
-					}
-					else
-					{	// frame received in clear text
-						// encryption in-use but receive a non-EAPOL clear text frame, drop it
-							if (((pAd->PortCfg.WepStatus == Ndis802_11Encryption1Enabled) ||
-								(pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) ||
-								(pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)) &&
-								(pAd->PortCfg.PrivacyFilter == Ndis802_11PrivFilter8021xWEP) &&
-								(!NdisEqualMemory(EAPOL_LLC_SNAP, pData, LENGTH_802_1_H)))
-							{
-								break; // give up this frame
-							}				
-					}
+		      // remove the 2 extra AGGREGATION bytes
+		      Msdu2Size = 0;
+		      if (pHeader->FC.Order)
+			{
+			  Msdu2Size = *pData + (*(pData+1) << 8);
+			  if ((Msdu2Size <= 1536) && (Msdu2Size < DataSize))
+			    {
+			      pData += 2;
+			      DataSize -= 2;
+			    }
+			  else
+			    Msdu2Size = 0;
+			}
 
-					// 
-					// Case I.1  Process Broadcast & Multicast data frame
-					//
-					if (pRxD->Bcast || pRxD->Mcast)
-					{
-						PUCHAR pRemovedLLCSNAP;
-						INC_COUNTER64(pAd->WlanCounters.MulticastReceivedFrameCount);
+		      // Drop not my BSS frame
+		      //
+		      // Not drop EAPOL frame, since this have happen on the first time that we link up
+		      // And need some more time to set BSSID to asic
+		      // So pRxD->MyBss may be 0
+		      //				
+		      if (RTMPEqualMemory(EAPOL, pData + 6, 2))
+			EAPOLFrame = TRUE;
+		      else
+			EAPOLFrame = FALSE;
+
+		      if ((pRxD->MyBss == 0) && (EAPOLFrame != TRUE))
+			break; // give up this frame
+
+		      // Drop NULL (+CF-POLL) (+CF-ACK) data frame
+		      if ((pHeader->FC.SubType & 0x04) == 0x04)
+			{
+			  DBGPRINT(RT_DEBUG_TRACE,"RxDone- drop NULL frame(subtype=%d)\n",pHeader->FC.SubType);
+			  break;
+			}
 
-						// Drop Mcast/Bcast frame with fragment bit on
-						if (pHeader->FC.MoreFrag)
-						{
-							break; // give up this frame
-						}
 
-						// Filter out Bcast frame which AP relayed for us
-						if (pHeader->FC.FrDs && MAC_ADDR_EQUAL(pHeader->Addr3, pAd->CurrentAddress))
-						{
-							break; // give up this frame
-						}
+		      // prepare 802.3 header: DA=addr1; SA=addr3 in INFRA mode, DA=addr2 in ADHOC mode
+		      pDA = pHeader->Addr1; 
+		      if (INFRA_ON(pAd))
+			pSA	= pHeader->Addr3;
+		      else
+			pSA	= pHeader->Addr2;
 
-						// build 802.3 header and decide if remove the 8-byte LLC/SNAP encapsulation
-						CONVERT_TO_802_3(Header802_3, pDA, pSA, pData, DataSize, pRemovedLLCSNAP);
-						REPORT_ETHERNET_FRAME_TO_LLC(pAd,Header802_3, pData, DataSize, net_dev);
-						DBGPRINT(RT_DEBUG_TRACE, "!!! report BCAST DATA to LLC (len=%d) !!!\n", DataSize);
-					}
-					//
-					// Case I.2  Process unicast-to-me DATA frame
-					//
-					else if	(pRxD->U2M)
-					{
-						RECORD_LATEST_RX_DATA_RATE(pAd, pRxD);
-//#ifdef RALINK_WPA_SUPPLICANT_SUPPORT
-                    if (pAd->PortCfg.WPA_Supplicant == TRUE) 
+		      if (pHeader->FC.Wep) // frame received in encrypted format
+			{
+			  if (pRxD->CipherAlg == CIPHER_NONE) // unsupported cipher suite
+			    {
+			      break; // give up this frame
+			    }
+			  else if (pAd->SharedKey[pRxD->KeyIndex].KeyLen == 0)
+			    {
+			      break; // give up this frame since the keylen is invalid.
+			    }				
+			}
+		      else
+			{	// frame received in clear text
+			  // encryption in-use but receive a non-EAPOL clear text frame, drop it
+			  if (((pAd->PortCfg.WepStatus == Ndis802_11Encryption1Enabled) ||
+			       (pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) ||
+			       (pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)) &&
+			      (pAd->PortCfg.PrivacyFilter == Ndis802_11PrivFilter8021xWEP) &&
+			      (!NdisEqualMemory(EAPOL_LLC_SNAP, pData, LENGTH_802_1_H)))
+			    {
+			      break; // give up this frame
+			    }				
+			}
+
+		      // 
+		      // Case I.1  Process Broadcast & Multicast data frame
+		      //
+		      if (pRxD->Bcast || pRxD->Mcast)
+			{
+			  INC_COUNTER64(pAd->WlanCounters.MulticastReceivedFrameCount);
+
+			  // Drop Mcast/Bcast frame with fragment bit on
+			  if (pHeader->FC.MoreFrag)
+			    {
+			      break; // give up this frame
+			    }
+
+			  // Filter out Bcast frame which AP relayed for us
+			  if (pHeader->FC.FrDs && MAC_ADDR_EQUAL(pHeader->Addr3, pAd->CurrentAddress))
+			    {
+			      break; // give up this frame
+			    }
+
+			  // build 802.3 header and decide if remove the 8-byte LLC/SNAP encapsulation
+			  CONVERT_TO_802_3(Header802_3, pDA, pSA, pData, DataSize, pRemovedLLCSNAP);
+			  REPORT_ETHERNET_FRAME_TO_LLC(pAd,Header802_3, pData, DataSize, net_dev);
+			  DBGPRINT(RT_DEBUG_TRACE, "!!! report BCAST DATA to LLC (len=%d) !!!\n", DataSize);
+			}
+		      //
+		      // Case I.2  Process unicast-to-me DATA frame
+		      //
+		      else if	(pRxD->U2M)
+			{
+			  RECORD_LATEST_RX_DATA_RATE(pAd, pRxD);
+			  //#ifdef RALINK_WPA_SUPPLICANT_SUPPORT
+			  if (pAd->PortCfg.WPA_Supplicant == TRUE) 
+			    {
+			      // All EAPoL frames have to pass to upper layer (ex. WPA_SUPPLICANT daemon)
+			      // TBD : process fragmented EAPol frames
+			      //2007/12/21:Carella add to fix fragmentation bugs in 802.1x(start)
+			      if (pHeader->Frag == 0)
+				{		// First or Only fragment
+				  if (pHeader->FC.MoreFrag == FALSE)
+				    {		// One & The only fragment
+				      if(NdisEqualMemory(EAPOL_LLC_SNAP, pData, LENGTH_802_1_H))
 					{
-						// All EAPoL frames have to pass to upper layer (ex. WPA_SUPPLICANT daemon)
-						// TBD : process fragmented EAPol frames
-						//2007/12/21:Carella add to fix fragmentation bugs in 802.1x(start)
-						if (pHeader->Frag == 0)
-						{		// First or Only fragment
-								if (pHeader->FC.MoreFrag == FALSE)
-								{		// One & The only fragment
-									if(NdisEqualMemory(EAPOL_LLC_SNAP, pData, LENGTH_802_1_H))
-									{
-										PUCHAR pRemovedLLCSNAP;
-										int		success = 0;
+					  success = 0;
 						
-										// In 802.1x mode, if the received frame is EAP-SUCCESS packet, turn on the PortSecured variable
-										if ( pAd->PortCfg.IEEE8021X == TRUE 
-										    && (EAP_CODE_SUCCESS == RTMPCheckWPAframeForEapCode(pAd, pData, DataSize, LENGTH_802_1_H)))
-										{
-											DBGPRINT_RAW(RT_DEBUG_TRACE, "Receive EAP-SUCCESS Packet\n");
-											pAd->PortCfg.PortSecured = WPA_802_1X_PORT_SECURED;	
-		
-											success = 1;
-										}
+					  // In 802.1x mode, if the received frame is EAP-SUCCESS packet, turn on the PortSecured variable
+					  if ( pAd->PortCfg.IEEE8021X == TRUE 
+					       && (EAP_CODE_SUCCESS == RTMPCheckWPAframeForEapCode(pAd, pData, DataSize, LENGTH_802_1_H)))
+					    {
+					      DBGPRINT_RAW(RT_DEBUG_TRACE, "Receive EAP-SUCCESS Packet\n");
+					      pAd->PortCfg.PortSecured = WPA_802_1X_PORT_SECURED;	
+		
+					      success = 1;
+					    }
 									
-										// build 802.3 header and decide if remove the 8-byte LLC/SNAP encapsulation
-										CONVERT_TO_802_3(Header802_3, pDA, pSA, pData, DataSize, pRemovedLLCSNAP);
-	                    							REPORT_ETHERNET_FRAME_TO_LLC(pAd, Header802_3, pData, DataSize, net_dev);
-										DBGPRINT_RAW(RT_DEBUG_TRACE, "!!! report EAPoL DATA to LLC (len=%d) !!!\n", DataSize);
+					  // build 802.3 header and decide if remove the 8-byte LLC/SNAP encapsulation
+					  CONVERT_TO_802_3(Header802_3, pDA, pSA, pData, DataSize, pRemovedLLCSNAP);
+					  REPORT_ETHERNET_FRAME_TO_LLC(pAd, Header802_3, pData, DataSize, net_dev);
+					  DBGPRINT_RAW(RT_DEBUG_TRACE, "!!! report EAPoL DATA to LLC (len=%d) !!!\n", DataSize);
 							
-										if(success)
-										{
-											// For static wep mode, need to set wep key to Asic again
-											if(pAd->PortCfg.IEEE8021x_required_keys == 0)
-											{
-											 	int idx;
-												idx = pAd->PortCfg.DefaultKeyId;
-									
-												DBGPRINT_RAW(RT_DEBUG_TRACE, "Set WEP key to Asic again =>\n");
-												if(pAd->PortCfg.DesireSharedKey[idx].KeyLen != 0)
-												{
-													pAd->SharedKey[idx].KeyLen = pAd->PortCfg.DesireSharedKey[idx].KeyLen;
-													NdisMoveMemory(pAd->SharedKey[idx].Key, pAd->PortCfg.DesireSharedKey[idx].Key, pAd->SharedKey[idx].KeyLen);
-													pAd->SharedKey[idx].CipherAlg = pAd->PortCfg.DesireSharedKey[idx].CipherAlg;
-													AsicAddSharedKeyEntry(pAd, 0, (UCHAR)idx, pAd->SharedKey[idx].CipherAlg, pAd->SharedKey[idx].Key, NULL, NULL); 
-												}
-											}														
-										}																																				
-										break;	//After reporting to LLC, must break
-									}
-								}//End of One & The only fragment
-								else
-								{		// First fragment - record the 802.3 header and frame body							
-										if (NdisEqualMemory(EAPOL_LLC_SNAP, pData, LENGTH_802_1_H))
-										{
-											NdisMoveMemory(&pAd->FragFrame.Buffer[LENGTH_802_3], pData, DataSize);
-											NdisMoveMemory(pAd->FragFrame.Header802_3, Header802_3, LENGTH_802_3);
-											pAd->FragFrame.RxSize	 = DataSize;
-											pAd->FragFrame.Sequence = pHeader->Sequence;
-											pAd->FragFrame.LastFrag = pHeader->Frag;		// Should be 0
-											break;
-										}
-								}
-						}//End of First or Only fragment
-						else
+					  if(success)
+					    {
+					      // For static wep mode, need to set wep key to Asic again
+					      if(pAd->PortCfg.IEEE8021x_required_keys == 0)
 						{
-											// Middle & End of fragment burst fragments	
-											// No LLC-SNAP header in except the first fragment frame
-											// Here only handle the EAPOL middle or final fragment
-							if (RTMPEqualMemory(SNAP_802_1H, (PUCHAR)&pAd->FragFrame.Buffer[LENGTH_802_3], 6))
-							{
-								if ((pHeader->Sequence != pAd->FragFrame.Sequence) ||(pHeader->Frag != (pAd->FragFrame.LastFrag + 1)))
-								{		// Fragment is not the same sequence or out of fragment number order
-										// Clear Fragment frame contents			
-										NdisZeroMemory(&pAd->FragFrame, sizeof(FRAGMENT_FRAME));
-										break; // give up this frame
-								}
-								else if ((pAd->FragFrame.RxSize + DataSize) > MAX_FRAME_SIZE)
-								{		// Fragment frame is too large, it exeeds the maximum frame size.
-										// Clear Fragment frame contents
-										NdisZeroMemory(&pAd->FragFrame, sizeof(FRAGMENT_FRAME));
-										break; // give up this frame
-								}
-
-								// concatenate this fragment into the re-assembly buffer
-								NdisMoveMemory(&pAd->FragFrame.Buffer[LENGTH_802_3 + pAd->FragFrame.RxSize], pData, DataSize);
-								pAd->FragFrame.RxSize	+= DataSize;
-								pAd->FragFrame.LastFrag = pHeader->Frag;		// Update fragment number
+						  idx = pAd->PortCfg.DefaultKeyId;
+									
+						  DBGPRINT_RAW(RT_DEBUG_TRACE, "Set WEP key to Asic again =>\n");
+						  if(pAd->PortCfg.DesireSharedKey[idx].KeyLen != 0)
+						    {
+						      pAd->SharedKey[idx].KeyLen = pAd->PortCfg.DesireSharedKey[idx].KeyLen;
+						      NdisMoveMemory(pAd->SharedKey[idx].Key, pAd->PortCfg.DesireSharedKey[idx].Key, pAd->SharedKey[idx].KeyLen);
+						      pAd->SharedKey[idx].CipherAlg = pAd->PortCfg.DesireSharedKey[idx].CipherAlg;
+						      AsicAddSharedKeyEntry(pAd, 0, (UCHAR)idx, pAd->SharedKey[idx].CipherAlg, pAd->SharedKey[idx].Key, NULL, NULL); 
+						    }
+						}														
+					    }																																				
+					  break;	//After reporting to LLC, must break
+					}
+				    }//End of One & The only fragment
+				  else
+				    {		// First fragment - record the 802.3 header and frame body							
+				      if (NdisEqualMemory(EAPOL_LLC_SNAP, pData, LENGTH_802_1_H))
+					{
+					  NdisMoveMemory(&pAd->FragFrame.Buffer[LENGTH_802_3], pData, DataSize);
+					  NdisMoveMemory(pAd->FragFrame.Header802_3, Header802_3, LENGTH_802_3);
+					  pAd->FragFrame.RxSize	 = DataSize;
+					  pAd->FragFrame.Sequence = pHeader->Sequence;
+					  pAd->FragFrame.LastFrag = pHeader->Frag;		// Should be 0
+					  break;
+					}
+				    }
+				}//End of First or Only fragment
+			      else
+				{
+				  // Middle & End of fragment burst fragments	
+				  // No LLC-SNAP header in except the first fragment frame
+				  // Here only handle the EAPOL middle or final fragment
+				  if (RTMPEqualMemory(SNAP_802_1H, (PUCHAR)&pAd->FragFrame.Buffer[LENGTH_802_3], 6))
+				    {
+				      if ((pHeader->Sequence != pAd->FragFrame.Sequence) ||(pHeader->Frag != (pAd->FragFrame.LastFrag + 1)))
+					{		// Fragment is not the same sequence or out of fragment number order
+					  // Clear Fragment frame contents			
+					  NdisZeroMemory(&pAd->FragFrame, sizeof(FRAGMENT_FRAME));
+					  break; // give up this frame
+					}
+				      else if ((pAd->FragFrame.RxSize + DataSize) > MAX_FRAME_SIZE)
+					{		// Fragment frame is too large, it exeeds the maximum frame size.
+					  // Clear Fragment frame contents
+					  NdisZeroMemory(&pAd->FragFrame, sizeof(FRAGMENT_FRAME));
+					  break; // give up this frame
+					}
+
+				      // concatenate this fragment into the re-assembly buffer
+				      NdisMoveMemory(&pAd->FragFrame.Buffer[LENGTH_802_3 + pAd->FragFrame.RxSize], pData, DataSize);
+				      pAd->FragFrame.RxSize	+= DataSize;
+				      pAd->FragFrame.LastFrag = pHeader->Frag;		// Update fragment number
 							     
-								int		success = 0;
-								// Last fragment
-								if (pHeader->FC.MoreFrag == FALSE)
-								{
-							   		BOOLEAN CheckPktSanity = TRUE;
-							   		if(pAd->FragFrame.RxSize < (LENGTH_802_1_H + LENGTH_EAPOL_H))
-									{
-										CheckPktSanity = FALSE;
-										DBGPRINT(RT_DEBUG_ERROR, "Total pkts size is too small.\n");
-									}
-					            			else if (!RTMPEqualMemory(SNAP_802_1H, (PUCHAR)&pAd->FragFrame.Buffer[LENGTH_802_3], 6))
-					            			{
-						                			CheckPktSanity = FALSE;	
-							            				DBGPRINT(RT_DEBUG_ERROR, "Can't find SNAP_802_1H parameter.\n");
-					       	    			}
-					            			else if (!RTMPEqualMemory(EAPOL, (PUCHAR)&pAd->FragFrame.Buffer[LENGTH_802_3 + 6], 2))
-									{
-					                				CheckPktSanity = FALSE;	
-					                				DBGPRINT(RT_DEBUG_ERROR, "Can't find EAPOL parameter.\n");	
-						        		}
-					       	    			else if(pAd->FragFrame.Buffer[LENGTH_802_3 + 9] > EAPOLASFAlert)
-							                {
-					                				CheckPktSanity = FALSE;	
-					                				DBGPRINT(RT_DEBUG_ERROR, "Unknown EAP type(%d).\n",pAd->FragFrame.Buffer[LENGTH_802_3+9]);
-									}
-
-					            				if(CheckPktSanity == FALSE)
-					            				{
-					               					NdisZeroMemory(&pAd->FragFrame, sizeof(FRAGMENT_FRAME));
-											break;
-										}
-										if ( pAd->PortCfg.IEEE8021X == TRUE )
-										{
-											DBGPRINT_RAW(RT_DEBUG_TRACE, "Receive EAP-SUCCESS Packet\n");
-											pAd->PortCfg.PortSecured = WPA_802_1X_PORT_SECURED;	
-											success = 1;
-										}
-	                                        
-				            					PUCHAR pRemovedLLCSNAP;
-				            					pData = &pAd->FragFrame.Buffer[LENGTH_802_3];
-				            					CONVERT_TO_802_3(pAd->FragFrame.Header802_3, pDA, pSA, pData, pAd->FragFrame.RxSize, pRemovedLLCSNAP);
-                            							REPORT_ETHERNET_FRAME_TO_LLC(pAd, pAd->FragFrame.Header802_3, pData, pAd->FragFrame.RxSize, net_dev);
+				      success = 0;
+				      // Last fragment
+				      if (pHeader->FC.MoreFrag == FALSE)
+					{
+					  CheckPktSanity = TRUE;
+					  if(pAd->FragFrame.RxSize < (LENGTH_802_1_H + LENGTH_EAPOL_H))
+					    {
+					      CheckPktSanity = FALSE;
+					      DBGPRINT(RT_DEBUG_ERROR, "Total pkts size is too small.\n");
+					    }
+					  else if (!RTMPEqualMemory(SNAP_802_1H, (PUCHAR)&pAd->FragFrame.Buffer[LENGTH_802_3], 6))
+					    {
+					      CheckPktSanity = FALSE;	
+					      DBGPRINT(RT_DEBUG_ERROR, "Can't find SNAP_802_1H parameter.\n");
+					    }
+					  else if (!RTMPEqualMemory(EAPOL, (PUCHAR)&pAd->FragFrame.Buffer[LENGTH_802_3 + 6], 2))
+					    {
+					      CheckPktSanity = FALSE;	
+					      DBGPRINT(RT_DEBUG_ERROR, "Can't find EAPOL parameter.\n");	
+					    }
+					  else if(pAd->FragFrame.Buffer[LENGTH_802_3 + 9] > EAPOLASFAlert)
+					    {
+					      CheckPktSanity = FALSE;	
+					      DBGPRINT(RT_DEBUG_ERROR, "Unknown EAP type(%d).\n",pAd->FragFrame.Buffer[LENGTH_802_3+9]);
+					    }
+
+					  if(CheckPktSanity == FALSE)
+					    {
+					      NdisZeroMemory(&pAd->FragFrame, sizeof(FRAGMENT_FRAME));
+					      break;
+					    }
+					  if ( pAd->PortCfg.IEEE8021X == TRUE )
+					    {
+					      DBGPRINT_RAW(RT_DEBUG_TRACE, "Receive EAP-SUCCESS Packet\n");
+					      pAd->PortCfg.PortSecured = WPA_802_1X_PORT_SECURED;	
+					      success = 1;
+					    }
+
+					  pData = &pAd->FragFrame.Buffer[LENGTH_802_3];
+					  CONVERT_TO_802_3(pAd->FragFrame.Header802_3, pDA, pSA, pData, pAd->FragFrame.RxSize, pRemovedLLCSNAP);
+					  REPORT_ETHERNET_FRAME_TO_LLC(pAd, pAd->FragFrame.Header802_3, pData, pAd->FragFrame.RxSize, net_dev);
 	                                        
-														if(success)
-														{
-																// For static wep mode, need to set wep key to Asic again
-																if(pAd->PortCfg.IEEE8021x_required_keys == 0)
-																{
-													 					int idx;
-				              			                        
-																		idx = pAd->PortCfg.DefaultKeyId;
-																		DBGPRINT_RAW(RT_DEBUG_TRACE, "Set WEP key to Asic again =>\n");
+					  if(success)
+					    {
+					      // For static wep mode, need to set wep key to Asic again
+					      if(pAd->PortCfg.IEEE8021x_required_keys == 0)
+						{
+						  idx = pAd->PortCfg.DefaultKeyId;
+						  DBGPRINT_RAW(RT_DEBUG_TRACE, "Set WEP key to Asic again =>\n");
 				
-																		if(pAd->PortCfg.DesireSharedKey[idx].KeyLen != 0)
-																		{
-																				pAd->SharedKey[idx].KeyLen = pAd->PortCfg.DesireSharedKey[idx].KeyLen;
-																				NdisMoveMemory(pAd->SharedKey[idx].Key, pAd->PortCfg.DesireSharedKey[idx].Key, pAd->SharedKey[idx].KeyLen);
-																				pAd->SharedKey[idx].CipherAlg = pAd->PortCfg.DesireSharedKey[idx].CipherAlg;
-																				AsicAddSharedKeyEntry(pAd, 0, (UCHAR)idx, pAd->SharedKey[idx].CipherAlg, pAd->SharedKey[idx].Key, NULL, NULL);
-																		}														
-																}																																				
-														}
+						  if(pAd->PortCfg.DesireSharedKey[idx].KeyLen != 0)
+						    {
+						      pAd->SharedKey[idx].KeyLen = pAd->PortCfg.DesireSharedKey[idx].KeyLen;
+						      NdisMoveMemory(pAd->SharedKey[idx].Key, pAd->PortCfg.DesireSharedKey[idx].Key, pAd->SharedKey[idx].KeyLen);
+						      pAd->SharedKey[idx].CipherAlg = pAd->PortCfg.DesireSharedKey[idx].CipherAlg;
+						      AsicAddSharedKeyEntry(pAd, 0, (UCHAR)idx, pAd->SharedKey[idx].CipherAlg, pAd->SharedKey[idx].Key, NULL, NULL);
+						    }														
+						}																																				
+					    }
 							
-										// Clear Fragment frame contents
-										NdisZeroMemory(&pAd->FragFrame, sizeof(FRAGMENT_FRAME));
-									}//-- End of the Last fragment --//
-									break;	//Middle or Final fragment has been handled ok , so break out
-								}
-							}//-- End Middle & End of fragment burst fragments	--//
-					}//-- End of WPA_Supplicant == TRUE --//
-					else 
-					{
-//#else	
-						// Special DATA frame that has to pass to MLME
-						//	 1. EAPOL handshaking frames when driver supplicant enabled, pass to MLME for special process
-						if ((pHeader->Frag == 0) && (pHeader->FC.MoreFrag == FALSE))  // add by johnli, fix WPAPSK/WPA2PSK bugs for receiving EAPoL fragmentation packets						{
-						{
-							if (NdisEqualMemory(EAPOL_LLC_SNAP, pData, LENGTH_802_1_H) && (pAd->PortCfg.WpaState != SS_NOTUSE))
-							{
-								// edit by johnli, fix WPAPSK/WPA2PSK bugs for receiving EAPoL fragmentation packets
-/*
-								DataSize += LENGTH_802_11;
-								REPORT_MGMT_FRAME_TO_MLME(pAd, pHeader, DataSize, pRxD->PlcpRssi, pRxD->PlcpSignal);
-*/
-								REPORT_MGMT_FRAME_TO_MLME(pAd, pHeader, pData, DataSize, pRxD->PlcpRssi, pRxD->PlcpSignal);
-								// end johnli
-								DBGPRINT_RAW(RT_DEBUG_TRACE, "!!! report EAPOL/AIRONET DATA to MLME (len=%d) !!!\n", DataSize);
-								break;	// end of processing this frame
-							}
-						}
-//#endif
-					}	
-					//2007/12/21:Carella add to fix fragmentation bugs in 802.1x(End)
-					if (pHeader->Frag == 0) 	// First or Only fragment
-						{
-							PUCHAR pRemovedLLCSNAP;
-							CONVERT_TO_802_3(Header802_3, pDA, pSA, pData, DataSize, pRemovedLLCSNAP);
-							pAd->FragFrame.Flags &= 0xFFFFFFFE;
-
-							// Firt Fragment & LLC/SNAP been removed. Keep the removed LLC/SNAP for later on
-							// TKIP MIC verification.
-							if (pHeader->FC.MoreFrag && pRemovedLLCSNAP)
-							{			
-								NdisMoveMemory(pAd->FragFrame.Header802_11, pHeader, LENGTH_802_11);  // add by johnli, fix WPAPSK/WPA2PSK bugs for receiving EAPoL fragmentation packets
-								NdisMoveMemory(pAd->FragFrame.Header_LLC, pRemovedLLCSNAP, LENGTH_802_1_H);
-								pAd->FragFrame.Flags |= 0x01;								
-							}
-
-							// One & The only fragment
-							if (pHeader->FC.MoreFrag == FALSE)
-							{					
-								if ((pHeader->FC.Order == 1)  && (Msdu2Size > 0)) // this is an aggregation
-								{
-									USHORT Payload1Size, Payload2Size;
-									PUCHAR pData2;
-
-									pAd->RalinkCounters.OneSecRxAggregationCount ++;
-									Payload1Size = DataSize - Msdu2Size;
-									Payload2Size = Msdu2Size - LENGTH_802_3;
-
-									REPORT_ETHERNET_FRAME_TO_LLC(pAd, Header802_3, pData, Payload1Size, net_dev);
-									DBGPRINT(RT_DEBUG_INFO, "!!! report segregated MSDU1 to LLC (len=%d, proto=%02x:%02x) %02x:%02x:%02x:%02x-%02x:%02x:%02x:%02x\n",
-															LENGTH_802_3+Payload1Size, Header802_3[12], Header802_3[13],
-															*pData, *(pData+1),*(pData+2),*(pData+3),*(pData+4),*(pData+5),*(pData+6),*(pData+7));									
-
-									pData2 = pData + Payload1Size + LENGTH_802_3;
-									REPORT_ETHERNET_FRAME_TO_LLC(pAd, pData + Payload1Size, pData2, Payload2Size, net_dev);
-									DBGPRINT_RAW(RT_DEBUG_INFO, "!!! report segregated MSDU2 to LLC (len=%d, proto=%02x:%02x) %02x:%02x:%02x:%02x-%02x:%02x:%02x:%02x\n",
-															LENGTH_802_3+Payload2Size, *(pData2 -2), *(pData2 - 1),
-															*pData2, *(pData2+1),*(pData2+2),*(pData2+3),*(pData2+4),*(pData2+5),*(pData2+6),*(pData2+7));									
-								}
-								else
-								{
-									REPORT_ETHERNET_FRAME_TO_LLC(pAd, Header802_3, pData, DataSize, net_dev);
-									DBGPRINT_RAW(RT_DEBUG_INFO, "!!! report DATA (no frag) to LLC (len=%d, proto=%02x:%02x) %02x:%02x:%02x:%02x-%02x:%02x:%02x:%02x\n",
-															DataSize, Header802_3[12], Header802_3[13],
-															*pData, *(pData+1),*(pData+2),*(pData+3),*(pData+4),*(pData+5),*(pData+6),*(pData+7));
-								}
-							}
-							// First fragment - record the 802.3 header and frame body
-							else
-							{
-								NdisMoveMemory(&pAd->FragFrame.Buffer[LENGTH_802_3], pData, DataSize);
-								NdisMoveMemory(pAd->FragFrame.Header802_3, Header802_3, LENGTH_802_3);
-								pAd->FragFrame.RxSize	 = DataSize;
-								pAd->FragFrame.Sequence = pHeader->Sequence;
-								pAd->FragFrame.LastFrag = pHeader->Frag;		// Should be 0
-							}
-						} //First or Only fragment
-						// Middle & End of fragment burst fragments
-						else
-						{
-							// No LLC-SNAP header in except the first fragment frame
-							if ((pHeader->Sequence != pAd->FragFrame.Sequence) ||
-								(pHeader->Frag != (pAd->FragFrame.LastFrag + 1)))
-							{
-								// Fragment is not the same sequence or out of fragment number order
-								// Clear Fragment frame contents
-								NdisZeroMemory(&pAd->FragFrame, sizeof(FRAGMENT_FRAME));
-								break;
-							}
-							else if ((pAd->FragFrame.RxSize + DataSize) > MAX_FRAME_SIZE)
-							{
-								// Fragment frame is too large, it exeeds the maximum frame size.
-								// Clear Fragment frame contents
-								NdisZeroMemory(&pAd->FragFrame, sizeof(FRAGMENT_FRAME));
-								break; // give up this frame
-							}
+					  // Clear Fragment frame contents
+					  NdisZeroMemory(&pAd->FragFrame, sizeof(FRAGMENT_FRAME));
+					}//-- End of the Last fragment --//
+				      break;	//Middle or Final fragment has been handled ok , so break out
+				    }
+				}//-- End Middle & End of fragment burst fragments	--//
+			    }//-- End of WPA_Supplicant == TRUE --//
+			  else 
+			    {
+			      //#else	
+			      // Special DATA frame that has to pass to MLME
+			      //	 1. EAPOL handshaking frames when driver supplicant enabled, pass to MLME for special process
+			      if ((pHeader->Frag == 0) && (pHeader->FC.MoreFrag == FALSE))  // add by johnli, fix WPAPSK/WPA2PSK bugs for receiving EAPoL fragmentation packets						{
+				{
+				  if (NdisEqualMemory(EAPOL_LLC_SNAP, pData, LENGTH_802_1_H) && (pAd->PortCfg.WpaState != SS_NOTUSE))
+				    {
+				      // edit by johnli, fix WPAPSK/WPA2PSK bugs for receiving EAPoL fragmentation packets
+				      /*
+					DataSize += LENGTH_802_11;
+					REPORT_MGMT_FRAME_TO_MLME(pAd, pHeader, DataSize, pRxD->PlcpRssi, pRxD->PlcpSignal);
+				      */
+				      REPORT_MGMT_FRAME_TO_MLME(pAd, pHeader, pData, DataSize, pRxD->PlcpRssi, pRxD->PlcpSignal);
+				      // end johnli
+				      DBGPRINT_RAW(RT_DEBUG_TRACE, "!!! report EAPOL/AIRONET DATA to MLME (len=%d) !!!\n", DataSize);
+				      break;	// end of processing this frame
+				    }
+				}
+			      //#endif
+			    }	
+			  //2007/12/21:Carella add to fix fragmentation bugs in 802.1x(End)
+			  if (pHeader->Frag == 0) 	// First or Only fragment
+			    {
+			      CONVERT_TO_802_3(Header802_3, pDA, pSA, pData, DataSize, pRemovedLLCSNAP);
+			      pAd->FragFrame.Flags &= 0xFFFFFFFE;
+
+			      // Firt Fragment & LLC/SNAP been removed. Keep the removed LLC/SNAP for later on
+			      // TKIP MIC verification.
+			      if (pHeader->FC.MoreFrag && pRemovedLLCSNAP)
+				{			
+				  NdisMoveMemory(pAd->FragFrame.Header802_11, pHeader, LENGTH_802_11);  // add by johnli, fix WPAPSK/WPA2PSK bugs for receiving EAPoL fragmentation packets
+				  NdisMoveMemory(pAd->FragFrame.Header_LLC, pRemovedLLCSNAP, LENGTH_802_1_H);
+				  pAd->FragFrame.Flags |= 0x01;								
+				}
+
+			      // One & The only fragment
+			      if (pHeader->FC.MoreFrag == FALSE)
+				{					
+				  if ((pHeader->FC.Order == 1)  && (Msdu2Size > 0)) // this is an aggregation
+				    {
+				      pAd->RalinkCounters.OneSecRxAggregationCount ++;
+				      Payload1Size = DataSize - Msdu2Size;
+				      Payload2Size = Msdu2Size - LENGTH_802_3;
+
+				      REPORT_ETHERNET_FRAME_TO_LLC(pAd, Header802_3, pData, Payload1Size, net_dev);
+				      DBGPRINT(RT_DEBUG_INFO, "!!! report segregated MSDU1 to LLC (len=%d, proto=%02x:%02x) %02x:%02x:%02x:%02x-%02x:%02x:%02x:%02x\n",
+					       LENGTH_802_3+Payload1Size, Header802_3[12], Header802_3[13],
+					       *pData, *(pData+1),*(pData+2),*(pData+3),*(pData+4),*(pData+5),*(pData+6),*(pData+7));									
+
+				      pData2 = pData + Payload1Size + LENGTH_802_3;
+				      REPORT_ETHERNET_FRAME_TO_LLC(pAd, pData + Payload1Size, pData2, Payload2Size, net_dev);
+				      DBGPRINT_RAW(RT_DEBUG_INFO, "!!! report segregated MSDU2 to LLC (len=%d, proto=%02x:%02x) %02x:%02x:%02x:%02x-%02x:%02x:%02x:%02x\n",
+						   LENGTH_802_3+Payload2Size, *(pData2 -2), *(pData2 - 1),
+						   *pData2, *(pData2+1),*(pData2+2),*(pData2+3),*(pData2+4),*(pData2+5),*(pData2+6),*(pData2+7));									
+				    }
+				  else
+				    {
+				      REPORT_ETHERNET_FRAME_TO_LLC(pAd, Header802_3, pData, DataSize, net_dev);
+				      DBGPRINT_RAW(RT_DEBUG_INFO, "!!! report DATA (no frag) to LLC (len=%d, proto=%02x:%02x) %02x:%02x:%02x:%02x-%02x:%02x:%02x:%02x\n",
+						   DataSize, Header802_3[12], Header802_3[13],
+						   *pData, *(pData+1),*(pData+2),*(pData+3),*(pData+4),*(pData+5),*(pData+6),*(pData+7));
+				    }
+				}
+			      // First fragment - record the 802.3 header and frame body
+			      else
+				{
+				  NdisMoveMemory(&pAd->FragFrame.Buffer[LENGTH_802_3], pData, DataSize);
+				  NdisMoveMemory(pAd->FragFrame.Header802_3, Header802_3, LENGTH_802_3);
+				  pAd->FragFrame.RxSize	 = DataSize;
+				  pAd->FragFrame.Sequence = pHeader->Sequence;
+				  pAd->FragFrame.LastFrag = pHeader->Frag;		// Should be 0
+				}
+			    } //First or Only fragment
+			  // Middle & End of fragment burst fragments
+			  else
+			    {
+			      // No LLC-SNAP header in except the first fragment frame
+			      if ((pHeader->Sequence != pAd->FragFrame.Sequence) ||
+				  (pHeader->Frag != (pAd->FragFrame.LastFrag + 1)))
+				{
+				  // Fragment is not the same sequence or out of fragment number order
+				  // Clear Fragment frame contents
+				  NdisZeroMemory(&pAd->FragFrame, sizeof(FRAGMENT_FRAME));
+				  break;
+				}
+			      else if ((pAd->FragFrame.RxSize + DataSize) > MAX_FRAME_SIZE)
+				{
+				  // Fragment frame is too large, it exeeds the maximum frame size.
+				  // Clear Fragment frame contents
+				  NdisZeroMemory(&pAd->FragFrame, sizeof(FRAGMENT_FRAME));
+				  break; // give up this frame
+				}
 							
-							// concatenate this fragment into the re-assembly buffer
-							NdisMoveMemory(&pAd->FragFrame.Buffer[LENGTH_802_3 + pAd->FragFrame.RxSize], pData, DataSize);
-							pAd->FragFrame.RxSize	+= DataSize;
-							pAd->FragFrame.LastFrag = pHeader->Frag;		// Update fragment number
+			      // concatenate this fragment into the re-assembly buffer
+			      NdisMoveMemory(&pAd->FragFrame.Buffer[LENGTH_802_3 + pAd->FragFrame.RxSize], pData, DataSize);
+			      pAd->FragFrame.RxSize	+= DataSize;
+			      pAd->FragFrame.LastFrag = pHeader->Frag;		// Update fragment number
  
-							// Last fragment
-							if (pHeader->FC.MoreFrag == FALSE)
-							{
-								// add by johnli, fix WPAPSK/WPA2PSK bugs for receiving EAPoL fragmentation packets
-								if (pAd->FragFrame.Flags & 0x00000001)
-								{
-									// originally there's an LLC/SNAP field in the first fragment
-									// but been removed in re-assembly buffer. here we have to include
-									// this LLC/SNAP field upon calculating TKIP MIC
-									// pData = pAd->FragFrame.Header_LLC;
-									// Copy LLC data to the position in front of real data for MIC calculation
-									NdisMoveMemory(&pAd->FragFrame.Buffer[LENGTH_802_3 - LENGTH_802_1_H],
-													pAd->FragFrame.Header_LLC, 
-													LENGTH_802_1_H);
-									pData = (PUCHAR) &pAd->FragFrame.Buffer[LENGTH_802_3 - LENGTH_802_1_H];										
-									DataSize = (USHORT)pAd->FragFrame.RxSize + LENGTH_802_1_H;
-								}
-								else
-								{
-									pData = (PUCHAR) &pAd->FragFrame.Buffer[LENGTH_802_3];
-									DataSize = (USHORT)pAd->FragFrame.RxSize;
-								}
-								// end johnli
-
-								// For TKIP frame, calculate the MIC value
-								if (pRxD->CipherAlg == CIPHER_TKIP)
-								{
-									pWpaKey = &pAd->SharedKey[0]; // pRxD->KeyIndex -> 0
-
-									// Minus MIC length
-									pAd->FragFrame.RxSize -= 8;
-									DataSize -= 8;  // add by johnli, fix WPAPSK/WPA2PSK bugs for receiving EAPoL fragmentation packets
-
-/* remove by johnli, fix WPAPSK/WPA2PSK bugs for receiving EAPoL fragmentation packets
-									if (pAd->FragFrame.Flags & 0x00000001)
-									{
-										// originally there's an LLC/SNAP field in the first fragment
-										// but been removed in re-assembly buffer. here we have to include
-										// this LLC/SNAP field upon calculating TKIP MIC
-										// pData = pAd->FragFrame.Header_LLC;
-										// Copy LLC data to the position in front of real data for MIC calculation
-										NdisMoveMemory(&pAd->FragFrame.Buffer[LENGTH_802_3 - LENGTH_802_1_H],
-														pAd->FragFrame.Header_LLC, 
-														LENGTH_802_1_H);
-										pData = (PUCHAR) &pAd->FragFrame.Buffer[LENGTH_802_3 - LENGTH_802_1_H];										
-										DataSize = (USHORT)pAd->FragFrame.RxSize + LENGTH_802_1_H;
-									}
-									else
-									{
-										pData = (PUCHAR) &pAd->FragFrame.Buffer[LENGTH_802_3];
-										DataSize = (USHORT)pAd->FragFrame.RxSize;
-									}
-*/
+			      // Last fragment
+			      if (pHeader->FC.MoreFrag == FALSE)
+				{
+				  // add by johnli, fix WPAPSK/WPA2PSK bugs for receiving EAPoL fragmentation packets
+				  if (pAd->FragFrame.Flags & 0x00000001)
+				    {
+				      // originally there's an LLC/SNAP field in the first fragment
+				      // but been removed in re-assembly buffer. here we have to include
+				      // this LLC/SNAP field upon calculating TKIP MIC
+				      // pData = pAd->FragFrame.Header_LLC;
+				      // Copy LLC data to the position in front of real data for MIC calculation
+				      NdisMoveMemory(&pAd->FragFrame.Buffer[LENGTH_802_3 - LENGTH_802_1_H],
+						     pAd->FragFrame.Header_LLC, 
+						     LENGTH_802_1_H);
+				      pData = (PUCHAR) &pAd->FragFrame.Buffer[LENGTH_802_3 - LENGTH_802_1_H];										
+				      DataSize = (USHORT)pAd->FragFrame.RxSize + LENGTH_802_1_H;
+				    }
+				  else
+				    {
+				      pData = (PUCHAR) &pAd->FragFrame.Buffer[LENGTH_802_3];
+				      DataSize = (USHORT)pAd->FragFrame.RxSize;
+				    }
+				  // end johnli
+
+				  // For TKIP frame, calculate the MIC value
+				  if (pRxD->CipherAlg == CIPHER_TKIP)
+				    {
+				      pWpaKey = &pAd->SharedKey[0]; // pRxD->KeyIndex -> 0
+
+				      // Minus MIC length
+				      pAd->FragFrame.RxSize -= 8;
+				      DataSize -= 8;  // add by johnli, fix WPAPSK/WPA2PSK bugs for receiving EAPoL fragmentation packets
+
+				      /* remove by johnli, fix WPAPSK/WPA2PSK bugs for receiving EAPoL fragmentation packets
+					 if (pAd->FragFrame.Flags & 0x00000001)
+					 {
+					 // originally there's an LLC/SNAP field in the first fragment
+					 // but been removed in re-assembly buffer. here we have to include
+					 // this LLC/SNAP field upon calculating TKIP MIC
+					 // pData = pAd->FragFrame.Header_LLC;
+					 // Copy LLC data to the position in front of real data for MIC calculation
+					 NdisMoveMemory(&pAd->FragFrame.Buffer[LENGTH_802_3 - LENGTH_802_1_H],
+					 pAd->FragFrame.Header_LLC, 
+					 LENGTH_802_1_H);
+					 pData = (PUCHAR) &pAd->FragFrame.Buffer[LENGTH_802_3 - LENGTH_802_1_H];										
+					 DataSize = (USHORT)pAd->FragFrame.RxSize + LENGTH_802_1_H;
+					 }
+					 else
+					 {
+					 pData = (PUCHAR) &pAd->FragFrame.Buffer[LENGTH_802_3];
+					 DataSize = (USHORT)pAd->FragFrame.RxSize;
+					 }
+				      */
 									
-									if (RTMPTkipCompareMICValue(
-											pAd,
-											pData,
-											pDA,
-											pSA,
-											pWpaKey->RxMic,
-											DataSize) == FALSE)
-									{
-										DBGPRINT_RAW(RT_DEBUG_ERROR,"Rx MIC Value error 2\n");							
-										RTMPReportMicError(pAd, pWpaKey);
-										break;	// give up this frame										
-									}
-								}
-
-								// edit by johnli, fix WPAPSK/WPA2PSK bugs for receiving EAPoL fragmentation packets
-/*
-								pData = &pAd->FragFrame.Buffer[LENGTH_802_3];
-								REPORT_ETHERNET_FRAME_TO_LLC(pAd, pAd->FragFrame.Header802_3, pData, pAd->FragFrame.RxSize, net_dev);
-								DBGPRINT(RT_DEBUG_TRACE, "!!! report DATA (fragmented) to LLC (len=%d) !!!\n", pAd->FragFrame.RxSize);
-*/
-								// Special DATA frame that has to pass to MLME
-								//	 1. EAPOL handshaking frames when driver supplicant enabled, pass to MLME for special process
-								if ((pAd->FragFrame.Flags & 0x00000001) && 
-									NdisEqualMemory(EAPOL_LLC_SNAP, pData, LENGTH_802_1_H) && (pAd->PortCfg.WpaState != SS_NOTUSE))
-								{
-									REPORT_MGMT_FRAME_TO_MLME(pAd, pAd->FragFrame.Header802_11, pData, DataSize, pRxD->PlcpRssi, pRxD->PlcpSignal);
-									DBGPRINT_RAW(RT_DEBUG_TRACE, "!!! report EAPOL/AIRONET DATA to MLME (len=%d) !!!\n", DataSize);
-								}
-								else
-								{
-									pData = &pAd->FragFrame.Buffer[LENGTH_802_3];
-									REPORT_ETHERNET_FRAME_TO_LLC(pAd, pAd->FragFrame.Header802_3, pData, pAd->FragFrame.RxSize, net_dev);
-									DBGPRINT(RT_DEBUG_TRACE, "!!! report DATA (fragmented) to LLC (len=%d) !!!\n", pAd->FragFrame.RxSize);
-								}
-								// end johnli
-							}
-						}
+				      if (RTMPTkipCompareMICValue(
+								  pAd,
+								  pData,
+								  pDA,
+								  pSA,
+								  pWpaKey->RxMic,
+								  DataSize) == FALSE)
+					{
+					  DBGPRINT_RAW(RT_DEBUG_ERROR,"Rx MIC Value error 2\n");							
+					  RTMPReportMicError(pAd, pWpaKey);
+					  break;	// give up this frame										
 					}
-				} // FC.Type == BTYPE_DATA
-				//
-				// CASE II. receive a MGMT frame
-				//
-				else if (pHeader->FC.Type == BTYPE_MGMT)
-				{
-					// edit by johnli, fix WPAPSK/WPA2PSK bugs for receiving EAPoL fragmentation packets
-//					REPORT_MGMT_FRAME_TO_MLME(pAd, pHeader, pRxD->DataByteCnt, pRxD->PlcpRssi, pRxD->PlcpSignal);
-					REPORT_MGMT_FRAME_TO_MLME(pAd, pHeader, pData, DataSize, pRxD->PlcpRssi, pRxD->PlcpSignal);
-					// end johnli
-					break;	// end of processing this frame
+				    }
+
+				  // edit by johnli, fix WPAPSK/WPA2PSK bugs for receiving EAPoL fragmentation packets
+				  /*
+				    pData = &pAd->FragFrame.Buffer[LENGTH_802_3];
+				    REPORT_ETHERNET_FRAME_TO_LLC(pAd, pAd->FragFrame.Header802_3, pData, pAd->FragFrame.RxSize, net_dev);
+				    DBGPRINT(RT_DEBUG_TRACE, "!!! report DATA (fragmented) to LLC (len=%d) !!!\n", pAd->FragFrame.RxSize);
+				  */
+				  // Special DATA frame that has to pass to MLME
+				  //	 1. EAPOL handshaking frames when driver supplicant enabled, pass to MLME for special process
+				  if ((pAd->FragFrame.Flags & 0x00000001) && 
+				      NdisEqualMemory(EAPOL_LLC_SNAP, pData, LENGTH_802_1_H) && (pAd->PortCfg.WpaState != SS_NOTUSE))
+				    {
+				      REPORT_MGMT_FRAME_TO_MLME(pAd, pAd->FragFrame.Header802_11, pData, DataSize, pRxD->PlcpRssi, pRxD->PlcpSignal);
+				      DBGPRINT_RAW(RT_DEBUG_TRACE, "!!! report EAPOL/AIRONET DATA to MLME (len=%d) !!!\n", DataSize);
+				    }
+				  else
+				    {
+				      pData = &pAd->FragFrame.Buffer[LENGTH_802_3];
+				      REPORT_ETHERNET_FRAME_TO_LLC(pAd, pAd->FragFrame.Header802_3, pData, pAd->FragFrame.RxSize, net_dev);
+				      DBGPRINT(RT_DEBUG_TRACE, "!!! report DATA (fragmented) to LLC (len=%d) !!!\n", pAd->FragFrame.RxSize);
+				    }
+				  // end johnli
 				}
-				//
-				// CASE III. receive a CNTL frame
-				//
-				else if (pHeader->FC.Type == BTYPE_CNTL)
-					break; // give up this frame
-				//
-				// CASE IV. receive a frame of invalid type
-				//
-				else
-					break; // give up this frame
-			} while (FALSE); // ************* exit point *********
-
-		}//if (Status == NDIS_STATUS_SUCCESS)
-
-		else if (Status == NDIS_STATUS_RESET)
-		{
-			RTUSBEnqueueInternalCmd(pAd, RT_OID_USB_RESET_BULK_IN);
-			return;
-		}
+			    }
+			}
+		    } // FC.Type == BTYPE_DATA
+		  //
+		  // CASE II. receive a MGMT frame
+		  //
+		  else if (pHeader->FC.Type == BTYPE_MGMT)
+		    {
+		      // edit by johnli, fix WPAPSK/WPA2PSK bugs for receiving EAPoL fragmentation packets
+		      //					REPORT_MGMT_FRAME_TO_MLME(pAd, pHeader, pRxD->DataByteCnt, pRxD->PlcpRssi, pRxD->PlcpSignal);
+		      REPORT_MGMT_FRAME_TO_MLME(pAd, pHeader, pData, DataSize, pRxD->PlcpRssi, pRxD->PlcpSignal);
+		      // end johnli
+		      break;	// end of processing this frame
+		    }
+		  //
+		  // CASE III. receive a CNTL frame
+		  //
+		  else if (pHeader->FC.Type == BTYPE_CNTL)
+		    break; // give up this frame
+		  //
+		  // CASE IV. receive a frame of invalid type
+		  //
+		  else
+		    break; // give up this frame
+		} while (FALSE); // ************* exit point *********
+
+	    }//if (Status == NDIS_STATUS_SUCCESS)
+
+	  else if (Status == NDIS_STATUS_RESET)
+	    {
+	      RTUSBEnqueueInternalCmd(pAd, RT_OID_USB_RESET_BULK_IN);
+	      return;
+	    }
 
 #ifdef BIG_ENDIAN
-		RTMPFrameEndianChange(pAd, (PUCHAR)pHeader, DIR_WRITE, TRUE);
-		RTMPDescriptorEndianChange((PUCHAR)pRxD, TYPE_RXD);    
-		WriteBackToDescriptor((PUCHAR)pDestRxD, (PUCHAR)pRxD, FALSE, TYPE_RXD);
+	  RTMPFrameEndianChange(pAd, (PUCHAR)pHeader, DIR_WRITE, TRUE);
+	  RTMPDescriptorEndianChange((PUCHAR)pRxD, TYPE_RXD);    
+	  WriteBackToDescriptor((PUCHAR)pDestRxD, (PUCHAR)pRxD, FALSE, TYPE_RXD);
 #endif
-	  }//if (pRxContext->pUrb->actual_length >= sizeof(RXD_STRUC)+ LENGTH_802_11)
+	}//if (pRxContext->pUrb->actual_length >= sizeof(RXD_STRUC)+ LENGTH_802_11)
 		
 	   
-		pRxContext->InUse = FALSE;
-//iverson patch usb 1.1 or 2.0 2007 1109
-if(pAd->BulkOutMaxPacketSize == 512)
-{
-		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKIN_RESET)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+      pRxContext->InUse = FALSE;
+      //iverson patch usb 1.1 or 2.0 2007 1109
+      if(pAd->BulkOutMaxPacketSize == 512)
+	{
+	  if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+	      (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKIN_RESET)) &&
+	      (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF)) &&
+	      (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
 #ifdef RALINK_ATE			
-			(!(pAd->ate.Mode != ATE_STASTART)) &&
+	      (!(pAd->ate.Mode != ATE_STASTART)) &&
 #endif						
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
-		{
-			   RTUSBBulkReceive(pAd);
-		}
-}
-else
-{
-DBGPRINT_RAW(RT_DEBUG_INFO, "In USB 1.1 Mode \n");
-}
-//iversonend		
+	      (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
+	    {
+	      RTUSBBulkReceive(pAd);
+	    }
+	}
+      else
+	{
+	  DBGPRINT_RAW(RT_DEBUG_INFO, "In USB 1.1 Mode \n");
+	}
+      //iversonend		
 #ifdef RALINK_ATE			
-		//If the driver is in ATE mode and Rx frame is set into here.
-		if((pAd->ate.Mode != ATE_STASTART) && (pAd->ContinBulkIn == TRUE))		
-		{
-			RTUSBBulkReceive(pAd);
-		}
+      //If the driver is in ATE mode and Rx frame is set into here.
+      if((pAd->ate.Mode != ATE_STASTART) && (pAd->ContinBulkIn == TRUE))		
+	{
+	  RTUSBBulkReceive(pAd);
+	}
 		
 #endif
 		
-	} while (0);
+    } while (0);
 
-	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBRxPacket Complete\n");
+  DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBRxPacket Complete\n");
 }
 
 /*
-	========================================================================
+  ========================================================================
 	
-	Routine Description:
+  Routine Description:
 
-	Arguments:
+  Arguments:
 
-	Return Value:
+  Return Value:
 	
-	Note:
+  Note:
 	
-	========================================================================
+  ========================================================================
 */
 VOID	RTUSBDequeueMLMEPacket(
-	IN	PRTMP_ADAPTER	pAd)
+			       IN	PRTMP_ADAPTER	pAd)
 {
-	PMGMT_STRUC		pMgmt;
-	unsigned long	IrqFlags;
-	unsigned long	IrqFlags2;
+  PMGMT_STRUC		pMgmt;
+  unsigned long	IrqFlags;
+  unsigned long	IrqFlags2;
 	
-	DBGPRINT(RT_DEBUG_INFO, "RTUSBDequeueMLMEPacket\n");
+  DBGPRINT(RT_DEBUG_INFO, "RTUSBDequeueMLMEPacket\n");
 	
-	NdisAcquireSpinLock(&pAd->DeMGMTQueueLock, IrqFlags2);
-    if (pAd->DeMGMTQueueRunning)
+  NdisAcquireSpinLock(&pAd->DeMGMTQueueLock, IrqFlags2);
+  if (pAd->DeMGMTQueueRunning)
     {
-		DBGPRINT(RT_DEBUG_ERROR, "<---RTUSBDequeueMLMEPacket : DeMGMTQueueRunning\n");
-        NdisReleaseSpinLock(&pAd->DeMGMTQueueLock, IrqFlags2);
-        return;
+      DBGPRINT(RT_DEBUG_ERROR, "<---RTUSBDequeueMLMEPacket : DeMGMTQueueRunning\n");
+      NdisReleaseSpinLock(&pAd->DeMGMTQueueLock, IrqFlags2);
+      return;
     }
-    else
+  else
     {
-        pAd->DeMGMTQueueRunning = TRUE;
-        NdisReleaseSpinLock(&pAd->DeMGMTQueueLock, IrqFlags2);
+      pAd->DeMGMTQueueRunning = TRUE;
+      NdisReleaseSpinLock(&pAd->DeMGMTQueueLock, IrqFlags2);
     }
 
-	NdisAcquireSpinLock(&pAd->MLMEWaitQueueLock,  IrqFlags);
-	while ((pAd->PopMgmtIndex != pAd->PushMgmtIndex) || (atomic_read(&pAd->MgmtQueueSize) > 0))
-	{
-		pMgmt = &pAd->MgmtRing[pAd->PopMgmtIndex];
+  NdisAcquireSpinLock(&pAd->MLMEWaitQueueLock,  IrqFlags);
+  while ((pAd->PopMgmtIndex != pAd->PushMgmtIndex) || (atomic_read(&pAd->MgmtQueueSize) > 0))
+    {
+      pMgmt = &pAd->MgmtRing[pAd->PopMgmtIndex];
 
-		if (RTUSBFreeDescriptorRequest(pAd, PRIO_RING, 0, 1) == NDIS_STATUS_SUCCESS)
-		{
-			atomic_dec(&pAd->MgmtQueueSize);
-			pAd->PopMgmtIndex = (pAd->PopMgmtIndex + 1) % MGMT_RING_SIZE;
-			NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock,  IrqFlags);
+      if (RTUSBFreeDescriptorRequest(pAd, PRIO_RING, 0, 1) == NDIS_STATUS_SUCCESS)
+	{
+	  atomic_dec(&pAd->MgmtQueueSize);
+	  pAd->PopMgmtIndex = (pAd->PopMgmtIndex + 1) % MGMT_RING_SIZE;
+	  NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock,  IrqFlags);
 
-			RTUSBMlmeHardTransmit(pAd, pMgmt);
+	  RTUSBMlmeHardTransmit(pAd, pMgmt);
 
-			MlmeFreeMemory(pAd, pMgmt->pBuffer);
-			pMgmt->pBuffer = NULL;
-			pMgmt->Valid = FALSE;
+	  MlmeFreeMemory(pAd, pMgmt->pBuffer);
+	  pMgmt->pBuffer = NULL;
+	  pMgmt->Valid = FALSE;
 
-			NdisAcquireSpinLock(&pAd->MLMEWaitQueueLock,  IrqFlags);
-		}
-		else
-		{
-			DBGPRINT(RT_DEBUG_TRACE, "not enough space in PrioRing[pAdapter->MgmtQueueSize=%d]\n", atomic_read(&pAd->MgmtQueueSize));
-			DBGPRINT(RT_DEBUG_TRACE, "RTUSBDequeueMLMEPacket::PrioRingFirstIndex = %d, PrioRingTxCnt = %d, PopMgmtIndex = %d, PushMgmtIndex = %d, NextMLMEIndex = %d\n", 
-			pAd->PrioRingFirstIndex, pAd->PrioRingTxCnt, 
-			pAd->PopMgmtIndex, pAd->PushMgmtIndex, pAd->NextMLMEIndex);	
-			break;
-		}
+	  NdisAcquireSpinLock(&pAd->MLMEWaitQueueLock,  IrqFlags);
+	}
+      else
+	{
+	  DBGPRINT(RT_DEBUG_TRACE, "not enough space in PrioRing[pAdapter->MgmtQueueSize=%d]\n", atomic_read(&pAd->MgmtQueueSize));
+	  DBGPRINT(RT_DEBUG_TRACE, "RTUSBDequeueMLMEPacket::PrioRingFirstIndex = %d, PrioRingTxCnt = %d, PopMgmtIndex = %d, PushMgmtIndex = %d, NextMLMEIndex = %d\n", 
+		   pAd->PrioRingFirstIndex, pAd->PrioRingTxCnt, 
+		   pAd->PopMgmtIndex, pAd->PushMgmtIndex, pAd->NextMLMEIndex);	
+	  break;
 	}
-	NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock,  IrqFlags);
+    }
+  NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock,  IrqFlags);
 	
-	NdisAcquireSpinLock(&pAd->DeMGMTQueueLock, IrqFlags2);
-	pAd->DeMGMTQueueRunning = FALSE;
-	NdisReleaseSpinLock(&pAd->DeMGMTQueueLock, IrqFlags2);
+  NdisAcquireSpinLock(&pAd->DeMGMTQueueLock, IrqFlags2);
+  pAd->DeMGMTQueueRunning = FALSE;
+  NdisReleaseSpinLock(&pAd->DeMGMTQueueLock, IrqFlags2);
 }	 
 
 /*
-	========================================================================
+  ========================================================================
 	
-	Routine Description:
+  Routine Description:
 
-	Arguments:
+  Arguments:
 
-	Return Value:
+  Return Value:
 	
-	Note:
+  Note:
 	
-	========================================================================
+  ========================================================================
 */
 VOID	RTUSBCleanUpMLMEWaitQueue(
-	IN	PRTMP_ADAPTER	pAd)
+				  IN	PRTMP_ADAPTER	pAd)
 {
-	PMGMT_STRUC		pMgmt;
-	unsigned long	IrqFlags;
+  PMGMT_STRUC		pMgmt;
+  unsigned long	IrqFlags;
 	
-	DBGPRINT(RT_DEBUG_TRACE, "--->CleanUpMLMEWaitQueue\n");
+  DBGPRINT(RT_DEBUG_TRACE, "--->CleanUpMLMEWaitQueue\n");
+
+  NdisAcquireSpinLock(&pAd->MLMEWaitQueueLock,  IrqFlags);
+  while (pAd->PopMgmtIndex != pAd->PushMgmtIndex)
+    {
+      pMgmt = (PMGMT_STRUC)&pAd->MgmtRing[pAd->PopMgmtIndex];
+      MlmeFreeMemory(pAd, pMgmt->pBuffer);
+      pMgmt->pBuffer = NULL;
+      pMgmt->Valid = FALSE;
+      atomic_dec(&pAd->MgmtQueueSize);
 
-	NdisAcquireSpinLock(&pAd->MLMEWaitQueueLock,  IrqFlags);
-	while (pAd->PopMgmtIndex != pAd->PushMgmtIndex)
+      pAd->PopMgmtIndex++;
+      if (pAd->PopMgmtIndex >= MGMT_RING_SIZE)
 	{
-		pMgmt = (PMGMT_STRUC)&pAd->MgmtRing[pAd->PopMgmtIndex];
-		MlmeFreeMemory(pAd, pMgmt->pBuffer);
-		pMgmt->pBuffer = NULL;
-		pMgmt->Valid = FALSE;
-		atomic_dec(&pAd->MgmtQueueSize);
-
-		pAd->PopMgmtIndex++;
-		if (pAd->PopMgmtIndex >= MGMT_RING_SIZE)
-		{
-			pAd->PopMgmtIndex = 0;
-		}
+	  pAd->PopMgmtIndex = 0;
 	}
-	NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock, IrqFlags);
+    }
+  NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock, IrqFlags);
 
-	DBGPRINT(RT_DEBUG_TRACE, "<---CleanUpMLMEWaitQueue\n");
+  DBGPRINT(RT_DEBUG_TRACE, "<---CleanUpMLMEWaitQueue\n");
 }
 
 /*
-	========================================================================
+  ========================================================================
 
-	Routine	Description:
-		Suspend MSDU transmission
+  Routine	Description:
+  Suspend MSDU transmission
 		
-	Arguments:
-		pAd		Pointer	to our adapter
+  Arguments:
+  pAd		Pointer	to our adapter
 		
-	Return Value:
-		None
+  Return Value:
+  None
 		
-	Note:
+  Note:
 	
-	========================================================================
+  ========================================================================
 */
 VOID	RTUSBSuspendMsduTransmission(
-	IN	PRTMP_ADAPTER	pAd)
+				     IN	PRTMP_ADAPTER	pAd)
 {
-	DBGPRINT(RT_DEBUG_TRACE,"SCANNING, suspend MSDU transmission ...\n");
+  DBGPRINT(RT_DEBUG_TRACE,"SCANNING, suspend MSDU transmission ...\n");
 
-	//
-	// Before BSS_SCAN_IN_PROGRESS, we need to keep Current R17 value and
-	// use Lowbound as R17 value on ScanNextChannel(...)
-	//
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)) 
-		RTUSBReadBBPRegister(pAd, 17, &pAd->BbpTuning.R17CurrentValue);
+  //
+  // Before BSS_SCAN_IN_PROGRESS, we need to keep Current R17 value and
+  // use Lowbound as R17 value on ScanNextChannel(...)
+  //
+  if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)) 
+    RTUSBReadBBPRegister(pAd, 17, &pAd->BbpTuning.R17CurrentValue);
 	
-	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
+  RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
 }
 
 /*
-	========================================================================
+  ========================================================================
 
-	Routine	Description:
-		Resume MSDU transmission
+  Routine	Description:
+  Resume MSDU transmission
 		
-	Arguments:
-		pAd		Pointer	to our adapter
+  Arguments:
+  pAd		Pointer	to our adapter
 		
-	Return Value:
-		None
+  Return Value:
+  None
 		
-	Note:
+  Note:
 	
-	========================================================================
+  ========================================================================
 */
 VOID	RTUSBResumeMsduTransmission(
-	IN	PRTMP_ADAPTER	pAd)
+				    IN	PRTMP_ADAPTER	pAd)
 {
-	INT 	Index;
+  INT 	Index;
 	
-	DBGPRINT(RT_DEBUG_ERROR,"SCAN done, resume MSDU transmission ...\n");
-	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
+  DBGPRINT(RT_DEBUG_ERROR,"SCAN done, resume MSDU transmission ...\n");
+  RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
 
-	//
-	// After finish BSS_SCAN_IN_PROGRESS, we need to restore Current R17 value
-	//
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)) 
-		RTUSBWriteBBPRegister(pAd, 17, pAd->BbpTuning.R17CurrentValue);
+  //
+  // After finish BSS_SCAN_IN_PROGRESS, we need to restore Current R17 value
+  //
+  if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)) 
+    RTUSBWriteBBPRegister(pAd, 17, pAd->BbpTuning.R17CurrentValue);
 
-	if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-		(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-		(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF)))
+  if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+      (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+      (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF)))
+    {
+      // Dequeue all Tx software queue, if have been queued.
+      for (Index = 0; Index < 4; Index++)
 	{
-		// Dequeue all Tx software queue, if have been queued.
-		for (Index = 0; Index < 4; Index++)
-		{
-			if(pAd->SendTxWaitQueue[Index].Number > 0)
-			{
-				RTMPDeQueuePacket(pAd, Index);
-			}
-		}
+	  if(pAd->SendTxWaitQueue[Index].Number > 0)
+	    {
+	      RTMPDeQueuePacket(pAd, Index);
+	    }
 	}
+    }
 
-	// Kick bulk out
-	RTUSBKickBulkOut(pAd);
+  // Kick bulk out
+  RTUSBKickBulkOut(pAd);
 }
 
 /*
-	========================================================================
+  ========================================================================
 
-	Routine	Description:
-		API for MLME to transmit management frame to AP (BSS Mode)
-	or station (IBSS Mode)
+  Routine	Description:
+  API for MLME to transmit management frame to AP (BSS Mode)
+  or station (IBSS Mode)
 	
-	Arguments:
-		pAd			Pointer	to our adapter
-		Buffer		Pointer to	memory of outgoing frame
-		Length		Size of outgoing management frame
+  Arguments:
+  pAd			Pointer	to our adapter
+  Buffer		Pointer to	memory of outgoing frame
+  Length		Size of outgoing management frame
 		
-	Return Value:
-		NDIS_STATUS_FAILURE
-		NDIS_STATUS_PENDING
-		NDIS_STATUS_SUCCESS
+  Return Value:
+  NDIS_STATUS_FAILURE
+  NDIS_STATUS_PENDING
+  NDIS_STATUS_SUCCESS
 
-	Note:
+  Note:
 	
-	========================================================================
+  ========================================================================
 */
 VOID	MiniportMMRequest(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			QueIdx,
-	IN	PVOID			pBuffer,
-	IN	ULONG			Length)
+			  IN	PRTMP_ADAPTER	pAd,
+			  IN	UCHAR			QueIdx,
+			  IN	PVOID			pBuffer,
+			  IN	ULONG			Length)
 {
-	unsigned long	IrqFlags;
+  unsigned long	IrqFlags;
 	
-	DBGPRINT_RAW(RT_DEBUG_INFO, "---> MiniportMMRequest\n");
-
-	if (pBuffer)
-	{
-		PMGMT_STRUC	pMgmt;
+  DBGPRINT_RAW(RT_DEBUG_INFO, "---> MiniportMMRequest\n");
 
-		// Check management ring free avaliability
-		NdisAcquireSpinLock(&pAd->MLMEWaitQueueLock, IrqFlags);
-		pMgmt = (PMGMT_STRUC)&pAd->MgmtRing[pAd->PushMgmtIndex];
-		// This management cell has been occupied
-		if (pMgmt->Valid == TRUE)
-		{
-			NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock, IrqFlags);
-			MlmeFreeMemory(pAd, pBuffer);
-			pAd->RalinkCounters.MgmtRingFullCount++;
-			DBGPRINT_RAW(RT_DEBUG_WARN, "MiniportMMRequest (error:: MgmtRing full)\n");
-		}
-		// Insert this request into software managemnet ring
-		else
-		{
-			pMgmt->pBuffer = pBuffer;
-			pMgmt->Length  = Length;
-			pMgmt->Valid   = TRUE;
-			pAd->PushMgmtIndex++;
-			atomic_inc(&pAd->MgmtQueueSize);
-			if (pAd->PushMgmtIndex >= MGMT_RING_SIZE)
-			{
-				pAd->PushMgmtIndex = 0;
-			}
-			NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock, IrqFlags);
-		}
+  if (pBuffer)
+    {
+      PMGMT_STRUC	pMgmt;
+
+      // Check management ring free avaliability
+      NdisAcquireSpinLock(&pAd->MLMEWaitQueueLock, IrqFlags);
+      pMgmt = (PMGMT_STRUC)&pAd->MgmtRing[pAd->PushMgmtIndex];
+      // This management cell has been occupied
+      if (pMgmt->Valid == TRUE)
+	{
+	  NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock, IrqFlags);
+	  MlmeFreeMemory(pAd, pBuffer);
+	  pAd->RalinkCounters.MgmtRingFullCount++;
+	  DBGPRINT_RAW(RT_DEBUG_WARN, "MiniportMMRequest (error:: MgmtRing full)\n");
+	}
+      // Insert this request into software managemnet ring
+      else
+	{
+	  pMgmt->pBuffer = pBuffer;
+	  pMgmt->Length  = Length;
+	  pMgmt->Valid   = TRUE;
+	  pAd->PushMgmtIndex++;
+	  atomic_inc(&pAd->MgmtQueueSize);
+	  if (pAd->PushMgmtIndex >= MGMT_RING_SIZE)
+	    {
+	      pAd->PushMgmtIndex = 0;
+	    }
+	  NdisReleaseSpinLock(&pAd->MLMEWaitQueueLock, IrqFlags);
 	}
-	else
-		DBGPRINT(RT_DEBUG_WARN, "MiniportMMRequest (error:: NULL msg)\n");
+    }
+  else
+    DBGPRINT(RT_DEBUG_WARN, "MiniportMMRequest (error:: NULL msg)\n");
 	
-	RTUSBDequeueMLMEPacket(pAd);
+  RTUSBDequeueMLMEPacket(pAd);
 	
-	// If pAd->PrioRingTxCnt is larger than 0, this means that prio_ring have something to transmit.
-	// Then call KickBulkOut to transmit it
-	if (pAd->PrioRingTxCnt > 0)
-	{
-		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
-			AsicForceWakeup(pAd);
-		RTUSBKickBulkOut(pAd);
-	}
+  // If pAd->PrioRingTxCnt is larger than 0, this means that prio_ring have something to transmit.
+  // Then call KickBulkOut to transmit it
+  if (pAd->PrioRingTxCnt > 0)
+    {
+      if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
+	AsicForceWakeup(pAd);
+      RTUSBKickBulkOut(pAd);
+    }
 	
-	DBGPRINT_RAW(RT_DEBUG_INFO, "<--- MiniportMMRequest\n");
+  DBGPRINT_RAW(RT_DEBUG_INFO, "<--- MiniportMMRequest\n");
 }
 
 /*
-	========================================================================
+  ========================================================================
 
-	Routine	Description:
-		Search tuple cache for receive duplicate frame from unicast frames.
+  Routine	Description:
+  Search tuple cache for receive duplicate frame from unicast frames.
 		
-	Arguments:
-		pAd				Pointer	to our adapter
-		pHeader			802.11 header of receiving frame
+  Arguments:
+  pAd				Pointer	to our adapter
+  pHeader			802.11 header of receiving frame
 		
-	Return Value:
-		TRUE			found matched tuple cache
-		FALSE			no matched found
+  Return Value:
+  TRUE			found matched tuple cache
+  FALSE			no matched found
 
-	Note:
+  Note:
 	
-	========================================================================
+  ========================================================================
 */
 BOOLEAN	RTMPSearchTupleCache(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PHEADER_802_11	pHeader)
+			     IN	PRTMP_ADAPTER	pAd,
+			     IN	PHEADER_802_11	pHeader)
 {
-	INT	Index;
+  INT	Index;
 
-	for (Index = 0; Index < MAX_CLIENT; Index++)
-	{
-		if (pAd->TupleCache[Index].Valid == FALSE)
-			continue;
+  for (Index = 0; Index < MAX_CLIENT; Index++)
+    {
+      if (pAd->TupleCache[Index].Valid == FALSE)
+	continue;
 		
-		if (MAC_ADDR_EQUAL(pAd->TupleCache[Index].MacAddress, pHeader->Addr2) &&
-			(pAd->TupleCache[Index].Sequence == pHeader->Sequence) &&
-			(pAd->TupleCache[Index].Frag == pHeader->Frag))
-		{
-//			DBGPRINT(RT_DEBUG_TRACE,"DUPCHECK - duplicate frame hit entry %d\n", Index); 
-			return (TRUE);
-		}
+      if (MAC_ADDR_EQUAL(pAd->TupleCache[Index].MacAddress, pHeader->Addr2) &&
+	  (pAd->TupleCache[Index].Sequence == pHeader->Sequence) &&
+	  (pAd->TupleCache[Index].Frag == pHeader->Frag))
+	{
+	  //			DBGPRINT(RT_DEBUG_TRACE,"DUPCHECK - duplicate frame hit entry %d\n", Index); 
+	  return (TRUE);
 	}
-	return (FALSE);
+    }
+  return (FALSE);
 }
 
 /*
-	========================================================================
+  ========================================================================
 
-	Routine	Description:
-		Update tuple cache for new received unicast frames.
+  Routine	Description:
+  Update tuple cache for new received unicast frames.
 		
-	Arguments:
-		pAd				Pointer	to our adapter
-		pHeader			802.11 header of receiving frame
+  Arguments:
+  pAd				Pointer	to our adapter
+  pHeader			802.11 header of receiving frame
 		
-	Return Value:
-		None
+  Return Value:
+  None
 		
-	Note:
+  Note:
 	
-	========================================================================
+  ========================================================================
 */
 VOID	RTMPUpdateTupleCache(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PHEADER_802_11	pHeader)
+			     IN	PRTMP_ADAPTER	pAd,
+			     IN	PHEADER_802_11	pHeader)
 {
-	UCHAR	Index;
+  UCHAR	Index;
 
-	for (Index = 0; Index < MAX_CLIENT; Index++)
-	{
-		if (pAd->TupleCache[Index].Valid == FALSE)
-		{
-			// Add new entry
-			COPY_MAC_ADDR(pAd->TupleCache[Index].MacAddress, pHeader->Addr2);
-			pAd->TupleCache[Index].Sequence = pHeader->Sequence;
-			pAd->TupleCache[Index].Frag 	= pHeader->Frag;
-			pAd->TupleCache[Index].Valid	= TRUE;
-			pAd->TupleCacheLastUpdateIndex	= Index;
-			DBGPRINT(RT_DEBUG_INFO,"DUPCHECK - Add Entry %d, MAC=%02x:%02x:%02x:%02x:%02x:%02x\n", Index,
-				pAd->TupleCache[Index].MacAddress[0], pAd->TupleCache[Index].MacAddress[1],
-				pAd->TupleCache[Index].MacAddress[2], pAd->TupleCache[Index].MacAddress[3],
-				pAd->TupleCache[Index].MacAddress[4], pAd->TupleCache[Index].MacAddress[5]);
-			return;
-		}
-		else if (MAC_ADDR_EQUAL(pAd->TupleCache[Index].MacAddress, pHeader->Addr2))
-		{
-			// Update old entry
-			pAd->TupleCache[Index].Sequence = pHeader->Sequence;
-			pAd->TupleCache[Index].Frag 	= pHeader->Frag;
-			return;
-		}
+  for (Index = 0; Index < MAX_CLIENT; Index++)
+    {
+      if (pAd->TupleCache[Index].Valid == FALSE)
+	{
+	  // Add new entry
+	  COPY_MAC_ADDR(pAd->TupleCache[Index].MacAddress, pHeader->Addr2);
+	  pAd->TupleCache[Index].Sequence = pHeader->Sequence;
+	  pAd->TupleCache[Index].Frag 	= pHeader->Frag;
+	  pAd->TupleCache[Index].Valid	= TRUE;
+	  pAd->TupleCacheLastUpdateIndex	= Index;
+	  DBGPRINT(RT_DEBUG_INFO,"DUPCHECK - Add Entry %d, MAC=%02x:%02x:%02x:%02x:%02x:%02x\n", Index,
+		   pAd->TupleCache[Index].MacAddress[0], pAd->TupleCache[Index].MacAddress[1],
+		   pAd->TupleCache[Index].MacAddress[2], pAd->TupleCache[Index].MacAddress[3],
+		   pAd->TupleCache[Index].MacAddress[4], pAd->TupleCache[Index].MacAddress[5]);
+	  return;
+	}
+      else if (MAC_ADDR_EQUAL(pAd->TupleCache[Index].MacAddress, pHeader->Addr2))
+	{
+	  // Update old entry
+	  pAd->TupleCache[Index].Sequence = pHeader->Sequence;
+	  pAd->TupleCache[Index].Frag 	= pHeader->Frag;
+	  return;
 	}
+    }
 
-	// tuple cache full, replace the first inserted one (even though it may not be
-	// least referenced one)
-	if (Index == MAX_CLIENT)
-	{
-		pAd->TupleCacheLastUpdateIndex ++;
-		if (pAd->TupleCacheLastUpdateIndex >= MAX_CLIENT)
-			pAd->TupleCacheLastUpdateIndex = 0;
-		Index = pAd->TupleCacheLastUpdateIndex;
-
-		// replace with new entry
-		COPY_MAC_ADDR(pAd->TupleCache[Index].MacAddress, pHeader->Addr2);
-		pAd->TupleCache[Index].Sequence = pHeader->Sequence;
-		pAd->TupleCache[Index].Frag 	= pHeader->Frag;
-		pAd->TupleCache[Index].Valid	= TRUE;
-		DBGPRINT(RT_DEBUG_INFO,"DUPCHECK - replace Entry %d, MAC=%02x:%02x:%02x:%02x:%02x:%02x\n", Index,
-			pAd->TupleCache[Index].MacAddress[0], pAd->TupleCache[Index].MacAddress[1],
-			pAd->TupleCache[Index].MacAddress[2], pAd->TupleCache[Index].MacAddress[3],
-			pAd->TupleCache[Index].MacAddress[4], pAd->TupleCache[Index].MacAddress[5]);
-	}
+  // tuple cache full, replace the first inserted one (even though it may not be
+  // least referenced one)
+  if (Index == MAX_CLIENT)
+    {
+      pAd->TupleCacheLastUpdateIndex ++;
+      if (pAd->TupleCacheLastUpdateIndex >= MAX_CLIENT)
+	pAd->TupleCacheLastUpdateIndex = 0;
+      Index = pAd->TupleCacheLastUpdateIndex;
+
+      // replace with new entry
+      COPY_MAC_ADDR(pAd->TupleCache[Index].MacAddress, pHeader->Addr2);
+      pAd->TupleCache[Index].Sequence = pHeader->Sequence;
+      pAd->TupleCache[Index].Frag 	= pHeader->Frag;
+      pAd->TupleCache[Index].Valid	= TRUE;
+      DBGPRINT(RT_DEBUG_INFO,"DUPCHECK - replace Entry %d, MAC=%02x:%02x:%02x:%02x:%02x:%02x\n", Index,
+	       pAd->TupleCache[Index].MacAddress[0], pAd->TupleCache[Index].MacAddress[1],
+	       pAd->TupleCache[Index].MacAddress[2], pAd->TupleCache[Index].MacAddress[3],
+	       pAd->TupleCache[Index].MacAddress[4], pAd->TupleCache[Index].MacAddress[5]);
+    }
 }
 
 /*
-	========================================================================
+  ========================================================================
 
-	Routine	Description:
-		Apply packet filter policy, return NDIS_STATUS_FAILURE if this frame
-		should be dropped.
+  Routine	Description:
+  Apply packet filter policy, return NDIS_STATUS_FAILURE if this frame
+  should be dropped.
 		
-	Arguments:
-		pAd		Pointer	to our adapter
-		pRxD			Pointer	to the Rx descriptor
-		pHeader			Pointer to the 802.11 frame header
+  Arguments:
+  pAd		Pointer	to our adapter
+  pRxD			Pointer	to the Rx descriptor
+  pHeader			Pointer to the 802.11 frame header
 		
-	Return Value:
-		NDIS_STATUS_SUCCESS		Accept frame
-		NDIS_STATUS_FAILURE		Drop Frame
+  Return Value:
+  NDIS_STATUS_SUCCESS		Accept frame
+  NDIS_STATUS_FAILURE		Drop Frame
 			
-	Note:
-		Maganement frame should bypass this filtering rule.
+  Note:
+  Maganement frame should bypass this filtering rule.
 	
-	========================================================================
+  ========================================================================
 */
 NDIS_STATUS	RTMPApplyPacketFilter(
-	IN	PRTMP_ADAPTER	pAd, 
-	IN	PRXD_STRUC		pRxD, 
-	IN	PHEADER_802_11	pHeader)
+				      IN	PRTMP_ADAPTER	pAd, 
+				      IN	PRXD_STRUC		pRxD, 
+				      IN	PHEADER_802_11	pHeader)
 {
-	UCHAR	i;
+  UCHAR	i;
 	
-	// 0. Management frame should bypass all these filtering rules.
-	if (pHeader->FC.Type == BTYPE_MGMT)
-		return(NDIS_STATUS_SUCCESS);
+  // 0. Management frame should bypass all these filtering rules.
+  if (pHeader->FC.Type == BTYPE_MGMT)
+    return(NDIS_STATUS_SUCCESS);
 	
-	// 0.1	Drop all Rx frames if MIC countermeasures kicks in
-	if (pAd->PortCfg.MicErrCnt >= 2)
-	{
-		DBGPRINT(RT_DEBUG_TRACE,"Rx dropped by MIC countermeasure\n");
-		return(NDIS_STATUS_FAILURE);
-	}
+  // 0.1	Drop all Rx frames if MIC countermeasures kicks in
+  if (pAd->PortCfg.MicErrCnt >= 2)
+    {
+      DBGPRINT(RT_DEBUG_TRACE,"Rx dropped by MIC countermeasure\n");
+      return(NDIS_STATUS_FAILURE);
+    }
 	
-	// 1. Drop unicast to me packet if NDIS_PACKET_TYPE_DIRECTED is FALSE
-	if (pRxD->U2M) 
+  // 1. Drop unicast to me packet if NDIS_PACKET_TYPE_DIRECTED is FALSE
+  if (pRxD->U2M) 
+    {
+      if (pAd->bAcceptDirect == FALSE)
 	{
-		if (pAd->bAcceptDirect == FALSE)
-		{
-			DBGPRINT(RT_DEBUG_TRACE,"Rx U2M dropped by RX_FILTER\n");
-			return(NDIS_STATUS_FAILURE);
-		}
+	  DBGPRINT(RT_DEBUG_TRACE,"Rx U2M dropped by RX_FILTER\n");
+	  return(NDIS_STATUS_FAILURE);
 	}
+    }
 		
-	// 2. Drop broadcast packet if NDIS_PACKET_TYPE_BROADCAST is FALSE
-	else if (pRxD->Bcast)
+  // 2. Drop broadcast packet if NDIS_PACKET_TYPE_BROADCAST is FALSE
+  else if (pRxD->Bcast)
+    {
+      if (pAd->bAcceptBroadcast == FALSE)
 	{
-		if (pAd->bAcceptBroadcast == FALSE)
-		{
-			DBGPRINT(RT_DEBUG_TRACE,"Rx BCAST dropped by RX_FILTER\n");
-			return(NDIS_STATUS_FAILURE);
-		}
+	  DBGPRINT(RT_DEBUG_TRACE,"Rx BCAST dropped by RX_FILTER\n");
+	  return(NDIS_STATUS_FAILURE);
 	}
+    }
 			
-	// 3. Drop (non-Broadcast) multicast packet if NDIS_PACKET_TYPE_ALL_MULTICAST is false
-	//	  and NDIS_PACKET_TYPE_MULTICAST is false.
-	//	  If NDIS_PACKET_TYPE_MULTICAST is true, but NDIS_PACKET_TYPE_ALL_MULTICAST is false.
-	//	  We have to deal with multicast table lookup & drop not matched packets.
-	else if (pRxD->Mcast)
+  // 3. Drop (non-Broadcast) multicast packet if NDIS_PACKET_TYPE_ALL_MULTICAST is false
+  //	  and NDIS_PACKET_TYPE_MULTICAST is false.
+  //	  If NDIS_PACKET_TYPE_MULTICAST is true, but NDIS_PACKET_TYPE_ALL_MULTICAST is false.
+  //	  We have to deal with multicast table lookup & drop not matched packets.
+  else if (pRxD->Mcast)
+    {
+      if (pAd->bAcceptAllMulticast == FALSE)
 	{
-		if (pAd->bAcceptAllMulticast == FALSE)
+	  if (pAd->bAcceptMulticast == FALSE)
+	    {
+	      DBGPRINT(RT_DEBUG_INFO,"Rx MCAST dropped by RX_FILTER\n");
+	      return(NDIS_STATUS_FAILURE);
+	    }
+	  else
+	    {
+	      // Selected accept multicast packet based on multicast table
+	      for (i = 0; i < pAd->NumberOfMcastAddresses; i++)
 		{
-			if (pAd->bAcceptMulticast == FALSE)
-			{
-				DBGPRINT(RT_DEBUG_INFO,"Rx MCAST dropped by RX_FILTER\n");
-				return(NDIS_STATUS_FAILURE);
-			}
-			else
-			{
-				// Selected accept multicast packet based on multicast table
-				for (i = 0; i < pAd->NumberOfMcastAddresses; i++)
-				{
-					if (MAC_ADDR_EQUAL(pHeader->Addr1, pAd->McastTable[i]))
-						break;		// Matched
-				}
+		  if (MAC_ADDR_EQUAL(pHeader->Addr1, pAd->McastTable[i]))
+		    break;		// Matched
+		}
 
-				// Not matched
-				if (i == pAd->NumberOfMcastAddresses)
-				{
-					DBGPRINT(RT_DEBUG_INFO,"Rx MCAST %02x:%02x:%02x:%02x:%02x:%02x dropped by RX_FILTER\n",
-						pHeader->Addr1[0], pHeader->Addr1[1], pHeader->Addr1[2], 
-						pHeader->Addr1[3], pHeader->Addr1[4], pHeader->Addr1[5]);
-					return(NDIS_STATUS_FAILURE);
-				}
-				else
-				{
-					DBGPRINT(RT_DEBUG_INFO,"Accept multicast %02x:%02x:%02x:%02x:%02x:%02x\n",
-						pHeader->Addr1[0], pHeader->Addr1[1], pHeader->Addr1[2], 
-						pHeader->Addr1[3], pHeader->Addr1[4], pHeader->Addr1[5]);
-				}
-			}
+	      // Not matched
+	      if (i == pAd->NumberOfMcastAddresses)
+		{
+		  DBGPRINT(RT_DEBUG_INFO,"Rx MCAST %02x:%02x:%02x:%02x:%02x:%02x dropped by RX_FILTER\n",
+			   pHeader->Addr1[0], pHeader->Addr1[1], pHeader->Addr1[2], 
+			   pHeader->Addr1[3], pHeader->Addr1[4], pHeader->Addr1[5]);
+		  return(NDIS_STATUS_FAILURE);
+		}
+	      else
+		{
+		  DBGPRINT(RT_DEBUG_INFO,"Accept multicast %02x:%02x:%02x:%02x:%02x:%02x\n",
+			   pHeader->Addr1[0], pHeader->Addr1[1], pHeader->Addr1[2], 
+			   pHeader->Addr1[3], pHeader->Addr1[4], pHeader->Addr1[5]);
 		}
+	    }
 	}
+    }
 
-	// 4. Not U2M, not Mcast, not Bcast, must be unicast to other DA.
-	//	  Since we did not implement promiscuous mode, just drop this kind of packet for now.
-	else
-		return(NDIS_STATUS_FAILURE);
+  // 4. Not U2M, not Mcast, not Bcast, must be unicast to other DA.
+  //	  Since we did not implement promiscuous mode, just drop this kind of packet for now.
+  else
+    return(NDIS_STATUS_FAILURE);
 	
-	return(NDIS_STATUS_SUCCESS);	
+  return(NDIS_STATUS_SUCCESS);	
 }
 
 /*
-	========================================================================
+  ========================================================================
 
-	Routine	Description:
-		Check Rx descriptor, return NDIS_STATUS_FAILURE if any error dound
+  Routine	Description:
+  Check Rx descriptor, return NDIS_STATUS_FAILURE if any error dound
 		
-	Arguments:
-		pRxD		Pointer	to the Rx descriptor
+  Arguments:
+  pRxD		Pointer	to the Rx descriptor
 		
-	Return Value:
-		NDIS_STATUS_SUCCESS		No err
-		NDIS_STATUS_FAILURE		Error
+  Return Value:
+  NDIS_STATUS_SUCCESS		No err
+  NDIS_STATUS_FAILURE		Error
 		
-	Note:
+  Note:
 	
-	========================================================================
+  ========================================================================
 */
 NDIS_STATUS	RTMPCheckRxDescriptor(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PHEADER_802_11	pHeader,	
-	IN	PRXD_STRUC	pRxD)
+				      IN	PRTMP_ADAPTER	pAd,
+				      IN	PHEADER_802_11	pHeader,	
+				      IN	PRXD_STRUC	pRxD)
 {	
-	PCIPHER_KEY 	pWpaKey;
-
-	// Phy errors & CRC errors
-	if (/*(pRxD->PhyErr) ||*/ (pRxD->Crc))
-	{	
-		DBGPRINT_RAW(RT_DEBUG_ERROR, "pRxD->Crc error\n")
-		return (NDIS_STATUS_FAILURE);
-	}
+  PCIPHER_KEY 	pWpaKey;
 
-	// Drop ToDs promiscous frame, it is opened due to CCX 2 channel load statistics
-	if (pHeader->FC.ToDs)
-		return(NDIS_STATUS_FAILURE);
+  // Phy errors & CRC errors
+  if (/*(pRxD->PhyErr) ||*/ (pRxD->Crc))
+    {	
+      DBGPRINT_RAW(RT_DEBUG_ERROR, "pRxD->Crc error\n")
+	return (NDIS_STATUS_FAILURE);
+    }
 
-/*		
-	// Paul 04-03 for OFDM Rx length issue
-	if (pRxD->DataByteCnt > MAX_AGGREGATION_SIZE)
-	{
-		DBGPRINT_RAW(RT_DEBUG_ERROR, "received packet too long\n");
-		return (NDIS_STATUS_FAILURE);
-	}
-*/
-    // do not support AGGREGATION 
-	if (pRxD->DataByteCnt > 1600)
-	{
-		//DBGPRINT_RAW(RT_DEBUG_ERROR, "received packet too long\n");
-		return (NDIS_STATUS_FAILURE);
-	}
+  // Drop ToDs promiscous frame, it is opened due to CCX 2 channel load statistics
+  if (pHeader->FC.ToDs)
+    return(NDIS_STATUS_FAILURE);
+
+  /*		
+  // Paul 04-03 for OFDM Rx length issue
+  if (pRxD->DataByteCnt > MAX_AGGREGATION_SIZE)
+  {
+  DBGPRINT_RAW(RT_DEBUG_ERROR, "received packet too long\n");
+  return (NDIS_STATUS_FAILURE);
+  }
+  */
+  // do not support AGGREGATION 
+  if (pRxD->DataByteCnt > 1600)
+    {
+      //DBGPRINT_RAW(RT_DEBUG_ERROR, "received packet too long\n");
+      return (NDIS_STATUS_FAILURE);
+    }
 
 
-	// Drop not U2M frames, cant's drop here because we will drop beacon in this case
-	// I am kind of doubting the U2M bit operation
-	// if (pRxD->U2M == 0)
-	//	return(NDIS_STATUS_FAILURE);
+  // Drop not U2M frames, cant's drop here because we will drop beacon in this case
+  // I am kind of doubting the U2M bit operation
+  // if (pRxD->U2M == 0)
+  //	return(NDIS_STATUS_FAILURE);
 
-	// drop decyption fail frame
-	if (pRxD->CipherErr)
-	{
-		DBGPRINT_RAW(RT_DEBUG_TRACE,"ERROR: CRC ok but CipherErr %d (len = %d, Mcast=%d, Cipher=%s, KeyId=%d)\n", 
-			pRxD->CipherErr,
-			pRxD->DataByteCnt, 
-			pRxD->Mcast | pRxD->Bcast,
-			CipherName[pRxD->CipherAlg],
-			pRxD->KeyIndex);
+  // drop decyption fail frame
+  if (pRxD->CipherErr)
+    {
+      DBGPRINT_RAW(RT_DEBUG_TRACE,"ERROR: CRC ok but CipherErr %d (len = %d, Mcast=%d, Cipher=%s, KeyId=%d)\n", 
+		   pRxD->CipherErr,
+		   pRxD->DataByteCnt, 
+		   pRxD->Mcast | pRxD->Bcast,
+		   CipherName[pRxD->CipherAlg],
+		   pRxD->KeyIndex);
  
-		//
-		// MIC Error
-		//
-		if (pRxD->CipherErr == 2)
-		{			
-			pWpaKey = &pAd->SharedKey[pRxD->KeyIndex];
-			RTMPReportMicError(pAd, pWpaKey);
-			DBGPRINT_RAW(RT_DEBUG_ERROR,"Rx MIC Value error\n");
-		}
+      //
+      // MIC Error
+      //
+      if (pRxD->CipherErr == 2)
+	{			
+	  pWpaKey = &pAd->SharedKey[pRxD->KeyIndex];
+	  RTMPReportMicError(pAd, pWpaKey);
+	  DBGPRINT_RAW(RT_DEBUG_ERROR,"Rx MIC Value error\n");
+	}
 		
-		if ((pRxD->CipherAlg == CIPHER_AES) &&
-			(pHeader->Sequence == pAd->FragFrame.Sequence))
-		{
-			//
-			// Acceptable since the First FragFrame no CipherErr problem.
-			//
-			return (NDIS_STATUS_FAILURE);
-		}
-
-		return (NDIS_STATUS_FAILURE);
+      if ((pRxD->CipherAlg == CIPHER_AES) &&
+	  (pHeader->Sequence == pAd->FragFrame.Sequence))
+	{
+	  //
+	  // Acceptable since the First FragFrame no CipherErr problem.
+	  //
+	  return (NDIS_STATUS_FAILURE);
 	}
 
-	return (NDIS_STATUS_SUCCESS);
+      return (NDIS_STATUS_FAILURE);
+    }
+
+  return (NDIS_STATUS_SUCCESS);
 }
 
 #ifdef RALINK_WPA_SUPPLICANT_SUPPORT
 static void ralink_michael_mic_failure(struct net_device *dev, PCIPHER_KEY pWpaKey)
 {
-	union iwreq_data wrqu;
-	char buf[128];
-
-	/* TODO: needed parameters: count, keyid, key type, TSC */
-	
-	//Check for Group or Pairwise MIC error
-	if (pWpaKey->Type == PAIRWISE_KEY)
-		sprintf(buf, "MLME-MICHAELMICFAILURE.indication unicast");
-	else
-		sprintf(buf, "MLME-MICHAELMICFAILURE.indication broadcast");
-	memset(&wrqu, 0, sizeof(wrqu));
-	wrqu.data.length = strlen(buf);
-	//send mic error event to wpa_supplicant
-	wireless_send_event(dev, IWEVCUSTOM, &wrqu, buf);
+  union iwreq_data wrqu;
+  char buf[128];
+
+  /* TODO: needed parameters: count, keyid, key type, TSC */
+	
+  //Check for Group or Pairwise MIC error
+  if (pWpaKey->Type == PAIRWISE_KEY)
+    sprintf(buf, "MLME-MICHAELMICFAILURE.indication unicast");
+  else
+    sprintf(buf, "MLME-MICHAELMICFAILURE.indication broadcast");
+  memset(&wrqu, 0, sizeof(wrqu));
+  wrqu.data.length = strlen(buf);
+  //send mic error event to wpa_supplicant
+  wireless_send_event(dev, IWEVCUSTOM, &wrqu, buf);
 }
 #endif
 
 /*
-	========================================================================
+  ========================================================================
 
-	Routine	Description:
-		Process MIC error indication and record MIC error timer.
+  Routine	Description:
+  Process MIC error indication and record MIC error timer.
 		
-	Arguments:
-		pAd		Pointer	to our adapter
-		pWpaKey			Pointer	to the WPA key structure
+  Arguments:
+  pAd		Pointer	to our adapter
+  pWpaKey			Pointer	to the WPA key structure
 		
-	Return Value:
-		None
+  Return Value:
+  None
 		
-	Note:
+  Note:
 	
-	========================================================================
+  ========================================================================
 */
 VOID	RTMPReportMicError(
-	IN	PRTMP_ADAPTER	pAd, 
-	IN	PCIPHER_KEY		pWpaKey)
+			   IN	PRTMP_ADAPTER	pAd, 
+			   IN	PCIPHER_KEY		pWpaKey)
 {
-	ULONG	Now;
-	UCHAR   unicastKey = (pWpaKey->Type == PAIRWISE_KEY ? 1:0); //BensonLiu 07-11-22 add for countermeature
-	struct
-	{
-		NDIS_802_11_STATUS_INDICATION		Status;
-		NDIS_802_11_AUTHENTICATION_REQUEST	Request;
-	}	Report;
-
-	DBGPRINT_RAW(RT_DEBUG_TRACE,"@@@@@@@@@@@@@ snowcarey mic error 1 @@@@@@@@@@@@@@@\n");
+  ULONG	Now;
+  UCHAR   unicastKey = (pWpaKey->Type == PAIRWISE_KEY ? 1:0); //BensonLiu 07-11-22 add for countermeature
+  struct
+  {
+    NDIS_802_11_STATUS_INDICATION		Status;
+    NDIS_802_11_AUTHENTICATION_REQUEST	Request;
+  }	Report;
+
+  DBGPRINT_RAW(RT_DEBUG_TRACE,"@@@@@@@@@@@@@ snowcarey mic error 1 @@@@@@@@@@@@@@@\n");
 #ifdef RALINK_WPA_SUPPLICANT_SUPPORT
-    if (pAd->PortCfg.WPA_Supplicant == TRUE) {
-        //report mic error to wpa_supplicant
-        ralink_michael_mic_failure(pAd->net_dev, pWpaKey);
-    }
+  if (pAd->PortCfg.WPA_Supplicant == TRUE) {
+    //report mic error to wpa_supplicant
+    ralink_michael_mic_failure(pAd->net_dev, pWpaKey);
+  }
 #endif
 
-	// 0. Set Status to indicate auth error
-	Report.Status.StatusType = Ndis802_11StatusType_Authentication;
+  // 0. Set Status to indicate auth error
+  Report.Status.StatusType = Ndis802_11StatusType_Authentication;
 	
-	// 1. Check for Group or Pairwise MIC error
-	if (pWpaKey->Type == PAIRWISE_KEY)
-		Report.Request.Flags = NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR;
-	else
-		Report.Request.Flags = NDIS_802_11_AUTH_REQUEST_GROUP_ERROR;
+  // 1. Check for Group or Pairwise MIC error
+  if (pWpaKey->Type == PAIRWISE_KEY)
+    Report.Request.Flags = NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR;
+  else
+    Report.Request.Flags = NDIS_802_11_AUTH_REQUEST_GROUP_ERROR;
 
-	// 2. Copy AP MAC address
-	COPY_MAC_ADDR(Report.Request.Bssid, pWpaKey->BssId);
+  // 2. Copy AP MAC address
+  COPY_MAC_ADDR(Report.Request.Bssid, pWpaKey->BssId);
 
-	// 3. Calculate length
-	Report.Request.Length = sizeof(NDIS_802_11_AUTHENTICATION_REQUEST);
+  // 3. Calculate length
+  Report.Request.Length = sizeof(NDIS_802_11_AUTHENTICATION_REQUEST);
 
-	// 4. Record Last MIC error time and count
-	Now = jiffies;
-	if (pAd->PortCfg.MicErrCnt == 0)
-	{
-		pAd->PortCfg.MicErrCnt++;
-		pAd->PortCfg.LastMicErrorTime = Now;
-	}
-	else if (pAd->PortCfg.MicErrCnt == 1)
+  // 4. Record Last MIC error time and count
+  Now = jiffies;
+  if (pAd->PortCfg.MicErrCnt == 0)
+    {
+      pAd->PortCfg.MicErrCnt++;
+      pAd->PortCfg.LastMicErrorTime = Now;
+    }
+  else if (pAd->PortCfg.MicErrCnt == 1)
+    {
+      //if ((pAd->PortCfg.LastMicErrorTime + (60 * 1000)) > Now)
+      if ((pAd->PortCfg.LastMicErrorTime + (60 * HZ)) < Now) //BensonLiu 07-11-22 add for countermeature
 	{
-		//if ((pAd->PortCfg.LastMicErrorTime + (60 * 1000)) > Now)
-		if ((pAd->PortCfg.LastMicErrorTime + (60 * HZ)) < Now) //BensonLiu 07-11-22 add for countermeature
-		{
-			// Update Last MIC error time, this did not violate two MIC errors within 60 seconds
-			pAd->PortCfg.LastMicErrorTime = Now;			
-		}
-		else
-		{
-			pAd->PortCfg.LastMicErrorTime = Now;			
-			// Violate MIC error counts, MIC countermeasures kicks in
-			pAd->PortCfg.MicErrCnt++;			
-			// We shall block all reception
-			// We shall clean all Tx ring and disassoicate from AP after next EAPOL frame
-			RTUSBRejectPendingPackets(pAd);
-			RTUSBCleanUpDataBulkOutQueue(pAd);
-		}
+	  // Update Last MIC error time, this did not violate two MIC errors within 60 seconds
+	  pAd->PortCfg.LastMicErrorTime = Now;			
 	}
-	else
+      else
 	{
-		// MIC error count >= 2
-		// This should not happen
-		;
+	  pAd->PortCfg.LastMicErrorTime = Now;			
+	  // Violate MIC error counts, MIC countermeasures kicks in
+	  pAd->PortCfg.MicErrCnt++;			
+	  // We shall block all reception
+	  // We shall clean all Tx ring and disassoicate from AP after next EAPOL frame
+	  RTUSBRejectPendingPackets(pAd);
+	  RTUSBCleanUpDataBulkOutQueue(pAd);
 	}
+    }
+  else
+    {
+      // MIC error count >= 2
+      // This should not happen
+      ;
+    }
 
-	//BensonLiu 07-11-22 start for countermeature
-	DBGPRINT_RAW(RT_DEBUG_TRACE,"@@@@@@@@@@@@@ snowcarey mic error 1 @@@@@@@@@@@@@@@\n");	
-	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, OID_802_11_MIC_FAILURE_REPORT_FRAME, 2, &unicastKey);
-	RTUSBMlmeUp(pAd);
+  //BensonLiu 07-11-22 start for countermeature
+  DBGPRINT_RAW(RT_DEBUG_TRACE,"@@@@@@@@@@@@@ snowcarey mic error 1 @@@@@@@@@@@@@@@\n");	
+  MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, OID_802_11_MIC_FAILURE_REPORT_FRAME, 2, &unicastKey);
+  RTUSBMlmeUp(pAd);
 
-	if (pAd->PortCfg.MicErrCnt == 2)
-		RTMPSetTimer(&pAd->PortCfg.WpaDisassocAndBlockAssocTimer, 100);
-	//BensonLiu 07-11-22 end for countermeature
+  if (pAd->PortCfg.MicErrCnt == 2)
+    RTMPSetTimer(&pAd->PortCfg.WpaDisassocAndBlockAssocTimer, 100);
+  //BensonLiu 07-11-22 end for countermeature
 }
 
 /* 
-	==========================================================================
-	Description:
-		Send out a NULL frame to AP. The prpose is to inform AP this client 
-		current PSM bit.
-	NOTE:
-		This routine should only be used in infrastructure mode.
-	==========================================================================
- */
+   ==========================================================================
+   Description:
+   Send out a NULL frame to AP. The prpose is to inform AP this client 
+   current PSM bit.
+   NOTE:
+   This routine should only be used in infrastructure mode.
+   ==========================================================================
+*/
 VOID	RTMPSendNullFrame(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			TxRate) 
+			  IN	PRTMP_ADAPTER	pAd,
+			  IN	UCHAR			TxRate) 
 {
-	PTX_CONTEXT		pNullContext;
-	PTXD_STRUC		pTxD;
+  PTX_CONTEXT		pNullContext;
+  PTXD_STRUC		pTxD;
 #ifdef BIG_ENDIAN
-	PTXD_STRUC		pDestTxD;
-	TXD_STRUC		TxD;
+  PTXD_STRUC		pDestTxD;
+  TXD_STRUC		TxD;
 #endif
-	UCHAR			QueIdx =QID_AC_VO;
-	PHEADER_802_11	pHdr80211;
-	ULONG			TransferBufferLength;
+  UCHAR			QueIdx =QID_AC_VO;
+  PHEADER_802_11	pHdr80211;
+  ULONG			TransferBufferLength;
 
 #ifdef RALINK_ATE
-	if(pAd->ate.Mode != ATE_STASTART)
-	{
-		return;
-	}
+  if(pAd->ate.Mode != ATE_STASTART)
+    {
+      return;
+    }
 #endif
 
-	if(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED))
-	{
-		QueIdx =QID_AC_VO;
-	}
-	else
-	{
-		QueIdx =QID_AC_BE;
-	}
+  if(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED))
+    {
+      QueIdx =QID_AC_VO;
+    }
+  else
+    {
+      QueIdx =QID_AC_BE;
+    }
 			
-	if ((RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) ||
-		(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)) ||
-		(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) ||
-		(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
-	{
-		return;
-	}
+  if ((RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) ||
+      (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)) ||
+      (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) ||
+      (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
+    {
+      return;
+    }
 	
-	// WPA 802.1x secured port control
-	if (((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA)    || 
-		 (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
-		 (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2)   ||
-		 (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+  // WPA 802.1x secured port control
+  if (((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA)    || 
+       (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
+       (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2)   ||
+       (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
 #ifdef RALINK_WPA_SUPPLICANT_SUPPORT
-	    || (pAd->PortCfg.IEEE8021X == TRUE)		
+       || (pAd->PortCfg.IEEE8021X == TRUE)		
 #endif 		
-        ) &&
-		(pAd->PortCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED))
-	{
-		return;
-	}
+       ) &&
+      (pAd->PortCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED))
+    {
+      return;
+    }
 
-	pNullContext = &(pAd->NullContext);
-	if (pNullContext->InUse == FALSE)
-	{
-		// Set the in use bit
-		pNullContext->InUse = TRUE;
+  pNullContext = &(pAd->NullContext);
+  if (pNullContext->InUse == FALSE)
+    {
+      // Set the in use bit
+      pNullContext->InUse = TRUE;
 
-		// Fill Null frame body and TxD
+      // Fill Null frame body and TxD
 #ifndef BIG_ENDIAN
-		pTxD  = (PTXD_STRUC) &pNullContext->TransferBuffer->TxDesc;
+      pTxD  = (PTXD_STRUC) &pNullContext->TransferBuffer->TxDesc;
 #else
-		pDestTxD  = (PTXD_STRUC) &pNullContext->TransferBuffer->TxDesc;
-		TxD = *pDestTxD;
-		pTxD = &TxD;
-		RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+      pDestTxD  = (PTXD_STRUC) &pNullContext->TransferBuffer->TxDesc;
+      TxD = *pDestTxD;
+      pTxD = &TxD;
+      RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
 #endif
-		NdisZeroMemory(pTxD, sizeof(TXD_STRUC));
+      NdisZeroMemory(pTxD, sizeof(TXD_STRUC));
 
-		pHdr80211 = (PHEADER_802_11) &pAd->NullContext.TransferBuffer->u.NullFrame;
-		MgtMacHeaderInit(pAd, pHdr80211, SUBTYPE_NULL_FUNC, 1, pAd->PortCfg.Bssid, pAd->PortCfg.Bssid);
-		pHdr80211->Duration = RTMPCalcDuration(pAd, TxRate, 14);
-		pHdr80211->FC.Type = BTYPE_DATA;
-		pHdr80211->FC.PwrMgmt = (pAd->PortCfg.Psm == PWR_SAVE);
+      pHdr80211 = (PHEADER_802_11) &pAd->NullContext.TransferBuffer->u.NullFrame;
+      MgtMacHeaderInit(pAd, pHdr80211, SUBTYPE_NULL_FUNC, 1, pAd->PortCfg.Bssid, pAd->PortCfg.Bssid);
+      pHdr80211->Duration = RTMPCalcDuration(pAd, TxRate, 14);
+      pHdr80211->FC.Type = BTYPE_DATA;
+      pHdr80211->FC.PwrMgmt = (pAd->PortCfg.Psm == PWR_SAVE);
 
 
 #ifdef BIG_ENDIAN
-		RTMPFrameEndianChange(pAd, (PUCHAR)pHdr80211, DIR_WRITE, FALSE);
-		RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
-		*pDestTxD = TxD;
-		pTxD = pDestTxD;
+      RTMPFrameEndianChange(pAd, (PUCHAR)pHdr80211, DIR_WRITE, FALSE);
+      RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+      *pDestTxD = TxD;
+      pTxD = pDestTxD;
 #endif
-		RTUSBWriteTxDescriptor(pAd, pTxD, CIPHER_NONE, 0,0, FALSE, FALSE, FALSE, SHORT_RETRY,
-			IFS_BACKOFF, TxRate, sizeof(HEADER_802_11), QueIdx, PID_MGMT_FRAME, FALSE);
+      RTUSBWriteTxDescriptor(pAd, pTxD, CIPHER_NONE, 0,0, FALSE, FALSE, FALSE, SHORT_RETRY,
+			     IFS_BACKOFF, TxRate, sizeof(HEADER_802_11), QueIdx, PID_MGMT_FRAME, FALSE);
 
-		DBGPRINT(RT_DEBUG_TRACE, "SYNC - send NULL Frame @%d Mbps...\n", RateIdToMbps[TxRate]);
-	}	
+      DBGPRINT(RT_DEBUG_TRACE, "SYNC - send NULL Frame @%d Mbps...\n", RateIdToMbps[TxRate]);
+    }	
 
-	// Build our URB for USBD
-	TransferBufferLength = sizeof(TXD_STRUC) + sizeof(HEADER_802_11);
-	if ((TransferBufferLength % 2) == 1)
-		TransferBufferLength++;
-	if ((TransferBufferLength % pAd->BulkOutMaxPacketSize) == 0)
-		TransferBufferLength += 2;
+  // Build our URB for USBD
+  TransferBufferLength = sizeof(TXD_STRUC) + sizeof(HEADER_802_11);
+  if ((TransferBufferLength % 2) == 1)
+    TransferBufferLength++;
+  if ((TransferBufferLength % pAd->BulkOutMaxPacketSize) == 0)
+    TransferBufferLength += 2;
 
-	// Fill out frame length information for global Bulk out arbitor
-	pNullContext->BulkOutSize = TransferBufferLength;
-	RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NULL);
+  // Fill out frame length information for global Bulk out arbitor
+  pNullContext->BulkOutSize = TransferBufferLength;
+  RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NULL);
 
-	// Kick bulk out 
-	RTUSBKickBulkOut(pAd);
+  // Kick bulk out 
+  RTUSBKickBulkOut(pAd);
 }
 
 VOID	RTMPSendRTSCTSFrame(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PUCHAR			pDA,
-	IN	ULONG			NextMpduSize,
-	IN	UCHAR			TxRate,
-	IN	UCHAR			RTSRate,
-	IN	USHORT			AckDuration,
-	IN	UCHAR			QueIdx,
-	IN	UCHAR			FrameGap,
-	IN	UCHAR			Type)
+			    IN	PRTMP_ADAPTER	pAd,
+			    IN	PUCHAR			pDA,
+			    IN	ULONG			NextMpduSize,
+			    IN	UCHAR			TxRate,
+			    IN	UCHAR			RTSRate,
+			    IN	USHORT			AckDuration,
+			    IN	UCHAR			QueIdx,
+			    IN	UCHAR			FrameGap,
+			    IN	UCHAR			Type)
 {
-	PTX_CONTEXT 		pTxContext;
-	PTXD_STRUC			pTxD;
+  PTX_CONTEXT 		pTxContext;
+  PTXD_STRUC			pTxD;
 #ifdef BIG_ENDIAN
-	PTXD_STRUC			pDestTxD;
-	TXD_STRUC			TxD;
+  PTXD_STRUC			pDestTxD;
+  TXD_STRUC			TxD;
 #endif	
-	PRTS_FRAME			pRtsFrame;
-	PUCHAR				pBuf;
-	ULONG				Length = 0;
-	ULONG				TransferBufferLength = 0;
-	unsigned long                   IrqFlags;//BensonLiu modify
+  PRTS_FRAME			pRtsFrame;
+  PUCHAR				pBuf;
+  ULONG				Length = 0;
+  ULONG				TransferBufferLength = 0;
+  unsigned long                   IrqFlags;//BensonLiu modify
 
-	if ((Type != SUBTYPE_RTS) && ( Type != SUBTYPE_CTS))
-	{
-		DBGPRINT(RT_DEBUG_WARN, "Making RTS/CTS Frame failed, type not matched!\n");
-		return;
-	}
-	else if ((Type == SUBTYPE_RTS) && ((*pDA) & 0x01))
+  if ((Type != SUBTYPE_RTS) && ( Type != SUBTYPE_CTS))
+    {
+      DBGPRINT(RT_DEBUG_WARN, "Making RTS/CTS Frame failed, type not matched!\n");
+      return;
+    }
+  else if ((Type == SUBTYPE_RTS) && ((*pDA) & 0x01))
+    {
+      if ((*pDA) & 0x01)
 	{
-		if ((*pDA) & 0x01)
-		{
-			// should not use RTS/CTS to protect MCAST frame since no one will reply CTS
-			DBGPRINT(RT_DEBUG_INFO,"Not use RTS Frame to proect MCAST frame\n");
-			return;
-		}
+	  // should not use RTS/CTS to protect MCAST frame since no one will reply CTS
+	  DBGPRINT(RT_DEBUG_INFO,"Not use RTS Frame to proect MCAST frame\n");
+	  return;
 	}
+    }
 
-	NdisAcquireSpinLock(&pAd->TxRingLock, IrqFlags);//BensonLiu modify
+  NdisAcquireSpinLock(&pAd->TxRingLock, IrqFlags);//BensonLiu modify
 
-	pTxContext	= &pAd->TxContext[QueIdx][pAd->NextTxIndex[QueIdx]];
-	if (pTxContext->InUse == FALSE)
+  pTxContext	= &pAd->TxContext[QueIdx][pAd->NextTxIndex[QueIdx]];
+  if (pTxContext->InUse == FALSE)
+    {
+      pTxContext->InUse	= TRUE;
+      pTxContext->LastOne = FALSE;
+      pAd->NextTxIndex[QueIdx]++;
+      if (pAd->NextTxIndex[QueIdx] >= TX_RING_SIZE)
 	{
-		pTxContext->InUse	= TRUE;
-		pTxContext->LastOne = FALSE;
-		pAd->NextTxIndex[QueIdx]++;
-		if (pAd->NextTxIndex[QueIdx] >= TX_RING_SIZE)
-	    {
-            pAd->NextTxIndex[QueIdx] = 0;
+	  pAd->NextTxIndex[QueIdx] = 0;
         }
 
 #ifndef BIG_ENDIAN
-		pTxD = (PTXD_STRUC) &pTxContext->TransferBuffer->TxDesc;
+      pTxD = (PTXD_STRUC) &pTxContext->TransferBuffer->TxDesc;
 #else
-		pDestTxD = (PTXD_STRUC) &pTxContext->TransferBuffer->TxDesc;
-		TxD = *pDestTxD;
-		pTxD = &TxD;
-		RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+      pDestTxD = (PTXD_STRUC) &pTxContext->TransferBuffer->TxDesc;
+      TxD = *pDestTxD;
+      pTxD = &TxD;
+      RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
 #endif
 
-		pRtsFrame = (PRTS_FRAME) &pTxContext->TransferBuffer->u.RTSFrame;
-		pBuf = (PUCHAR) pRtsFrame;
+      pRtsFrame = (PRTS_FRAME) &pTxContext->TransferBuffer->u.RTSFrame;
+      pBuf = (PUCHAR) pRtsFrame;
 
-		NdisZeroMemory(pRtsFrame, sizeof(RTS_FRAME));
-		pRtsFrame->FC.Type	  = BTYPE_CNTL;
-		// CTS-to-self's duration = SIFS + MPDU
-		pRtsFrame->Duration = (2 * pAd->PortCfg.Dsifs) + RTMPCalcDuration(pAd, TxRate, NextMpduSize) + AckDuration;// SIFS + Data + SIFS + ACK
+      NdisZeroMemory(pRtsFrame, sizeof(RTS_FRAME));
+      pRtsFrame->FC.Type	  = BTYPE_CNTL;
+      // CTS-to-self's duration = SIFS + MPDU
+      pRtsFrame->Duration = (2 * pAd->PortCfg.Dsifs) + RTMPCalcDuration(pAd, TxRate, NextMpduSize) + AckDuration;// SIFS + Data + SIFS + ACK
 
-		// Write Tx descriptor
-		// Don't kick tx start until all frames are prepared
-		// RTS has to set more fragment bit for fragment burst
-		// RTS did not encrypt
-		if (Type == SUBTYPE_RTS)
-		{
-			DBGPRINT(RT_DEBUG_INFO,"Making RTS Frame\n");
+      // Write Tx descriptor
+      // Don't kick tx start until all frames are prepared
+      // RTS has to set more fragment bit for fragment burst
+      // RTS did not encrypt
+      if (Type == SUBTYPE_RTS)
+	{
+	  DBGPRINT(RT_DEBUG_INFO,"Making RTS Frame\n");
 		  
-			pRtsFrame->FC.SubType = SUBTYPE_RTS;		
-			COPY_MAC_ADDR(pRtsFrame->Addr1, pDA);
-			COPY_MAC_ADDR(pRtsFrame->Addr2, pAd->CurrentAddress);
+	  pRtsFrame->FC.SubType = SUBTYPE_RTS;		
+	  COPY_MAC_ADDR(pRtsFrame->Addr1, pDA);
+	  COPY_MAC_ADDR(pRtsFrame->Addr2, pAd->CurrentAddress);
 			
-			// RTS's duration need to include and extra (SIFS + CTS) time
-			pRtsFrame->Duration += (pAd->PortCfg.Dsifs + RTMPCalcDuration(pAd, RTSRate, 14)); // SIFS + CTS-Duration
+	  // RTS's duration need to include and extra (SIFS + CTS) time
+	  pRtsFrame->Duration += (pAd->PortCfg.Dsifs + RTMPCalcDuration(pAd, RTSRate, 14)); // SIFS + CTS-Duration
+
+	  rts_cts_frame_duration = pRtsFrame->Duration;
 
-			Length = sizeof(RTS_FRAME);
+	  Length = sizeof(RTS_FRAME);
 			
 #ifdef BIG_ENDIAN
-			RTMPFrameEndianChange(pAd, (PUCHAR)pRtsFrame, DIR_WRITE, FALSE);
-			RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
-			*pDestTxD = TxD;
-			pTxD = pDestTxD;
+	  RTMPFrameEndianChange(pAd, (PUCHAR)pRtsFrame, DIR_WRITE, FALSE);
+	  RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+	  *pDestTxD = TxD;
+	  pTxD = pDestTxD;
 #endif
-			RTUSBWriteTxDescriptor(pAd, pTxD, CIPHER_NONE, 0,0, TRUE, TRUE, FALSE, SHORT_RETRY,
-				FrameGap, RTSRate, Length, QueIdx, 0, FALSE);
-		}
-		else if (Type == SUBTYPE_CTS)
-		{
-			DBGPRINT(RT_DEBUG_INFO,"Making CTS-to-self Frame\n");
-			pRtsFrame->FC.SubType = SUBTYPE_CTS;		
-			COPY_MAC_ADDR(pRtsFrame->Addr1, pAd->CurrentAddress);
+	  RTUSBWriteTxDescriptor(pAd, pTxD, CIPHER_NONE, 0,0, TRUE, TRUE, FALSE, SHORT_RETRY,
+				 FrameGap, RTSRate, Length, QueIdx, 0, FALSE);
+	}
+      else if (Type == SUBTYPE_CTS)
+	{
+	  DBGPRINT(RT_DEBUG_INFO,"Making CTS-to-self Frame\n");
+	  pRtsFrame->FC.SubType = SUBTYPE_CTS;		
+	  COPY_MAC_ADDR(pRtsFrame->Addr1, pAd->CurrentAddress);
 
-			Length = 10;  //CTS frame length.
+	  Length = 10;  //CTS frame length.
 
 #ifdef BIG_ENDIAN
-			RTMPFrameEndianChange(pAd, (PUCHAR)pRtsFrame, DIR_WRITE, FALSE);
-			RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
-			*pDestTxD = TxD;
-			pTxD = pDestTxD;
+	  RTMPFrameEndianChange(pAd, (PUCHAR)pRtsFrame, DIR_WRITE, FALSE);
+	  RTMPDescriptorEndianChange((PUCHAR)pTxD, TYPE_TXD);
+	  *pDestTxD = TxD;
+	  pTxD = pDestTxD;
 #endif			
-			RTUSBWriteTxDescriptor(pAd, pTxD, CIPHER_NONE, 0,0, FALSE, TRUE, FALSE, SHORT_RETRY,
-				FrameGap, RTSRate, Length, QueIdx, 0, FALSE);	
-		}
+	  RTUSBWriteTxDescriptor(pAd, pTxD, CIPHER_NONE, 0,0, FALSE, TRUE, FALSE, SHORT_RETRY,
+				 FrameGap, RTSRate, Length, QueIdx, 0, FALSE);	
+	}
 
 
-		// Build our URB for USBD
-		TransferBufferLength = sizeof(TXD_STRUC) + Length;
-		if ((TransferBufferLength % 2) == 1)
-			TransferBufferLength++;
-		if ((TransferBufferLength % pAd->BulkOutMaxPacketSize) == 0)
-			TransferBufferLength += 2;
+      // Build our URB for USBD
+      TransferBufferLength = sizeof(TXD_STRUC) + Length;
+      if ((TransferBufferLength % 2) == 1)
+	TransferBufferLength++;
+      if ((TransferBufferLength % pAd->BulkOutMaxPacketSize) == 0)
+	TransferBufferLength += 2;
 
-		// Fill out frame length information for global Bulk out arbitor
-		pTxContext->BulkOutSize = TransferBufferLength;
-		pTxContext->bWaitingBulkOut = TRUE;
+      // Fill out frame length information for global Bulk out arbitor
+      pTxContext->BulkOutSize = TransferBufferLength;
+      pTxContext->bWaitingBulkOut = TRUE;
 		
 
-        pAd->TxRingTotalNumber[QueIdx]++;  // sync. to TxCount
-        pTxContext->LastOne = TRUE;
-		atomic_inc(&pAd->TxCount);
-		NdisReleaseSpinLock(&pAd->TxRingLock, IrqFlags);//BensonLiu modify
-		RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL << QueIdx);
-
-	}	
+      pAd->TxRingTotalNumber[QueIdx]++;  // sync. to TxCount
+      pTxContext->LastOne = TRUE;
+      atomic_inc(&pAd->TxCount);
+      NdisReleaseSpinLock(&pAd->TxRingLock, IrqFlags);//BensonLiu modify
+      RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL << QueIdx);
+    }	
 }
 
 /*
-	========================================================================
+  ========================================================================
 
-	Routine	Description:
-		Calculates the duration which is required to transmit out frames 
-	with given size and specified rate.
+  Routine	Description:
+  Calculates the duration which is required to transmit out frames 
+  with given size and specified rate.
 		
-	Arguments:
-		pAd				Pointer	to our adapter
-		Rate			Transmit rate
-		Size			Frame size in units of byte
+  Arguments:
+  pAd				Pointer	to our adapter
+  Rate			Transmit rate
+  Size			Frame size in units of byte
 		
-	Return Value:
-		Duration number in units of usec
+  Return Value:
+  Duration number in units of usec
 
-	Note:
+  Note:
 	
-	========================================================================
+  ========================================================================
 */
 USHORT	RTMPCalcDuration(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			Rate,
-	IN	ULONG			Size)
+			 IN	PRTMP_ADAPTER	pAd,
+			 IN	UCHAR			Rate,
+			 IN	ULONG			Size)
 {
-	ULONG	Duration = 0;
+  ULONG	Duration = 0;
 
-	if (Rate < RATE_FIRST_OFDM_RATE) // CCK
-	{
-		if ((Rate > RATE_1) && (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED)))
-			Duration = 96;	// 72+24 preamble+plcp
-		else
-			Duration = 192; // 144+48 preamble+plcp
+  if (Rate < RATE_FIRST_OFDM_RATE) // CCK
+    {
+      if ((Rate > RATE_1) && (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED)))
+	Duration = 96;	// 72+24 preamble+plcp
+      else
+	Duration = 192; // 144+48 preamble+plcp
 			
-		Duration += (USHORT)((Size << 4) / RateIdTo500Kbps[Rate]);
-		if ((Size << 4) % RateIdTo500Kbps[Rate])
-			Duration ++;
-	}
-	else // OFDM rates
-	{
-		Duration = 20 + 6;		// 16+4 preamble+plcp + Signal Extension
-		Duration += 4 * (USHORT)((11 + Size * 4) / RateIdTo500Kbps[Rate]);
-		if ((11 + Size * 4) % RateIdTo500Kbps[Rate])
-			Duration += 4;
-	}
+      Duration += (USHORT)((Size << 4) / RateIdTo500Kbps[Rate]);
+      if ((Size << 4) % RateIdTo500Kbps[Rate])
+	Duration ++;
+    }
+  else // OFDM rates
+    {
+      Duration = 20 + 6;		// 16+4 preamble+plcp + Signal Extension
+      Duration += 4 * (USHORT)((11 + Size * 4) / RateIdTo500Kbps[Rate]);
+      if ((11 + Size * 4) % RateIdTo500Kbps[Rate])
+	Duration += 4;
+    }
 	
-	return (USHORT)Duration;
+  return (USHORT)Duration;
 	
 }
 
 /*
-	========================================================================
+  ========================================================================
 
-	Routine	Description:
-		Check the out going frame, if this is an DHCP or ARP datagram
-	will be duplicate another frame at low data rate transmit.
+  Routine	Description:
+  Check the out going frame, if this is an DHCP or ARP datagram
+  will be duplicate another frame at low data rate transmit.
 		
-	Arguments:
-		pAd			Pointer	to our adapter
-		pSkb		Pointer to outgoing skb buffer
+  Arguments:
+  pAd			Pointer	to our adapter
+  pSkb		Pointer to outgoing skb buffer
 		
-	Return Value:		
-		TRUE		To be transmitted at Low data rate transmit. (1Mbps/6Mbps)
-		FALSE		Do nothing.
+  Return Value:		
+  TRUE		To be transmitted at Low data rate transmit. (1Mbps/6Mbps)
+  FALSE		Do nothing.
 
-	Note:
+  Note:
 
-		MAC header + IP Header + UDP Header
-		  14 Bytes	  20 Bytes
+  MAC header + IP Header + UDP Header
+  14 Bytes	  20 Bytes
 		  
-		UDP Header
-		00|01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|
-						Source Port
-		16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|
-					Destination Port
+  UDP Header
+  00|01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|
+  Source Port
+  16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|
+  Destination Port
 
-		port 0x43 means Bootstrap Protocol, server. 
-		Port 0x44 means Bootstrap Protocol, client. 
+  port 0x43 means Bootstrap Protocol, server. 
+  Port 0x44 means Bootstrap Protocol, client. 
 
-	========================================================================
+  ========================================================================
 */
 BOOLEAN 	RTMPCheckDHCPFrame(
-	IN	PRTMP_ADAPTER	pAd, 
-	IN	struct sk_buff	*pSkb)
+				   IN	PRTMP_ADAPTER	pAd, 
+				   IN	struct sk_buff	*pSkb)
 {
-	PUCHAR			pSrc;
-	ULONG			SrcLen = 0;
+  PUCHAR			pSrc;
+  ULONG			SrcLen = 0;
 
-	pSrc = (PVOID)pSkb->data;
-	SrcLen = pSkb->len;
+  pSrc = (PVOID)pSkb->data;
+  SrcLen = pSkb->len;
 
-	// Check ARP packet
-	if (SrcLen >= 13)
+  // Check ARP packet
+  if (SrcLen >= 13)
+    {
+      if ((pSrc[12] == 0x08) && (pSrc[13] == 0x06))
 	{
-		if ((pSrc[12] == 0x08) && (pSrc[13] == 0x06))
-		{
-			DBGPRINT(RT_DEBUG_INFO,"RTMPCheckDHCPFrame - ARP packet\n");
-			return TRUE;
-		}
+	  DBGPRINT(RT_DEBUG_INFO,"RTMPCheckDHCPFrame - ARP packet\n");
+	  return TRUE;
 	}
+    }
 
-	// Check foe DHCP & BOOTP protocol
-	if (SrcLen >= 37)
+  // Check foe DHCP & BOOTP protocol
+  if (SrcLen >= 37)
+    {
+      //if ((pSrc[35] == 0x43) && (pSrc[37] == 0x44))
+      if ((pSrc[35] == 0x44) && (pSrc[37] == 0x43))//[Richie20090714]DHCP Tx using high data rate
 	{
-		//if ((pSrc[35] == 0x43) && (pSrc[37] == 0x44))
-		if ((pSrc[35] == 0x44) && (pSrc[37] == 0x43))//[Richie20090714]DHCP Tx using high data rate
-		{
-			DBGPRINT(RT_DEBUG_INFO,"RTMPCheckDHCPFrame - DHCP packet\n");
-			return TRUE;
-		}
+	  DBGPRINT(RT_DEBUG_INFO,"RTMPCheckDHCPFrame - DHCP packet\n");
+	  return TRUE;
 	}
+    }
 
-	return FALSE;
+  return FALSE;
 }
 
 #ifdef RALINK_ATE
 //Setup Null Frame format.
 VOID	ATE_RTMPSendNullFrame(
-	IN	PRTMP_ADAPTER	pAd) 
+			      IN	PRTMP_ADAPTER	pAd) 
 {
-		PTXD_STRUC		pTxD;
-		HEADER_802_11 	Header_802_11;	
+  PTXD_STRUC		pTxD;
+  HEADER_802_11 	Header_802_11;	
 
-		PTX_CONTEXT		pNullContext;
-		UCHAR			QueIdx =QID_AC_VO;
-		ULONG			TransferBufferLength;
-		//unsigned long	IrqFlags;
+  PTX_CONTEXT		pNullContext;
+  UCHAR			QueIdx =QID_AC_VO;
+  ULONG			TransferBufferLength;
+  //unsigned long	IrqFlags;
 
-		QueIdx =QID_AC_BE;	
+  QueIdx =QID_AC_BE;	
 
-		pNullContext = &(pAd->NullContext);
-		if (pNullContext->InUse == FALSE)
-		{
-			// Set the in use bit
-			pNullContext->InUse = TRUE;
-
-			//Create Tx packet
-			NdisZeroMemory(&Header_802_11, sizeof(HEADER_802_11));
-			NdisMoveMemory(&Header_802_11.Addr1, pAd->ate.Addr1, ETH_LENGTH_OF_ADDRESS);
-			NdisMoveMemory(&Header_802_11.Addr2, pAd->ate.Addr2, ETH_LENGTH_OF_ADDRESS);
-			NdisMoveMemory(&Header_802_11.Addr3, pAd->ate.Addr3, ETH_LENGTH_OF_ADDRESS);
-			Header_802_11.Sequence = pAd->Sequence;
-			Header_802_11.FC.Type = BTYPE_DATA;
-			Header_802_11.FC.PwrMgmt = 0;
-			Header_802_11.Frag = 0;
-			Header_802_11.FC.MoreFrag = 0;
-			Header_802_11.Duration = 0;		
-		
-			pTxD = (PTXD_STRUC) &pNullContext->TransferBuffer->TxDesc;				
-			NdisZeroMemory(pTxD, sizeof(PTXD_STRUC));
-			NdisMoveMemory(&pNullContext->TransferBuffer->u.NullFrame, &Header_802_11, sizeof(Header_802_11));	
-
-			//Note
-			RTUSBWriteTxDescriptor(pAd, pTxD, CIPHER_NONE, 0,0, FALSE, FALSE, FALSE, SHORT_RETRY, IFS_BACKOFF, (UCHAR)pAd->ate.TxRate, pAd->ate.TxLength, QID_AC_BE, PID_NULL_AT_HIGH_RATE, FALSE);			
-		}	
-	
-		// Build our URB for USBD
-		TransferBufferLength = (pAd->ate.TxLength-(sizeof(TXD_STRUC) + sizeof(HEADER_802_11))+(sizeof(TXD_STRUC) + sizeof(HEADER_802_11)));
-		
-		if ((TransferBufferLength % 4) == 1)	
-			TransferBufferLength  += 3;
-		else if ((TransferBufferLength % 4) == 2)	
-			TransferBufferLength  += 2;
-		else if ((TransferBufferLength % 4) == 3)	
-			TransferBufferLength  += 1;
-
-		if ((TransferBufferLength % pAd->BulkOutMaxPacketSize) == 0)
-			TransferBufferLength += 4;
-		
-		// Fill out frame length information for global Bulk out arbitor
-		pNullContext->BulkOutSize = TransferBufferLength;
+  pNullContext = &(pAd->NullContext);
+  if (pNullContext->InUse == FALSE)
+    {
+      // Set the in use bit
+      pNullContext->InUse = TRUE;
+
+      //Create Tx packet
+      NdisZeroMemory(&Header_802_11, sizeof(HEADER_802_11));
+      NdisMoveMemory(&Header_802_11.Addr1, pAd->ate.Addr1, ETH_LENGTH_OF_ADDRESS);
+      NdisMoveMemory(&Header_802_11.Addr2, pAd->ate.Addr2, ETH_LENGTH_OF_ADDRESS);
+      NdisMoveMemory(&Header_802_11.Addr3, pAd->ate.Addr3, ETH_LENGTH_OF_ADDRESS);
+      Header_802_11.Sequence = pAd->Sequence;
+      Header_802_11.FC.Type = BTYPE_DATA;
+      Header_802_11.FC.PwrMgmt = 0;
+      Header_802_11.Frag = 0;
+      Header_802_11.FC.MoreFrag = 0;
+      Header_802_11.Duration = 0;		
+		
+      pTxD = (PTXD_STRUC) &pNullContext->TransferBuffer->TxDesc;				
+      NdisZeroMemory(pTxD, sizeof(PTXD_STRUC));
+      NdisMoveMemory(&pNullContext->TransferBuffer->u.NullFrame, &Header_802_11, sizeof(Header_802_11));	
+
+      //Note
+      RTUSBWriteTxDescriptor(pAd, pTxD, CIPHER_NONE, 0,0, FALSE, FALSE, FALSE, SHORT_RETRY, IFS_BACKOFF, (UCHAR)pAd->ate.TxRate, pAd->ate.TxLength, QID_AC_BE, PID_NULL_AT_HIGH_RATE, FALSE);			
+    }	
+	
+  // Build our URB for USBD
+  TransferBufferLength = (pAd->ate.TxLength-(sizeof(TXD_STRUC) + sizeof(HEADER_802_11))+(sizeof(TXD_STRUC) + sizeof(HEADER_802_11)));
+		
+  if ((TransferBufferLength % 4) == 1)	
+    TransferBufferLength  += 3;
+  else if ((TransferBufferLength % 4) == 2)	
+    TransferBufferLength  += 2;
+  else if ((TransferBufferLength % 4) == 3)	
+    TransferBufferLength  += 1;
+
+  if ((TransferBufferLength % pAd->BulkOutMaxPacketSize) == 0)
+    TransferBufferLength += 4;
+		
+  // Fill out frame length information for global Bulk out arbitor
+  pNullContext->BulkOutSize = TransferBufferLength;
 		
 }
 #endif
-
